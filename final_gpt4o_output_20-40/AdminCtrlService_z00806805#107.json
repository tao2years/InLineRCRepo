{
  "benchmark_id": "AdminCtrlService_z00806805#107",
  "timestamp": "2025-09-19T10:57:05.813261",
  "model_used": "gpt-4o-2024-11-20",
  "prompt_version": "v9_improved",
  "selected_region": "// 分页查询告警基线数据\npublic CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException",
  "target_implementation": "public CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException {\n        LOGGER.info(\"[begin listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n        try {\n            Map<String, Object> paramMap = getParamMap(requestBody);\n            IPage<BaseLineEntity> baseLinePage = new Page<>(requestBody.getPageNum(), requestBody.getPageSize());\n            // 若分表字段不为空，则去该分表查询\n            if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n                baseLinePage = baseLineMapper.selectPageByLabelId(baseLinePage, paramMap);\n            } else {\n                baseLinePage = baseLineMapper.selectPageByMap(baseLinePage, paramMap);\n            }\n            LOGGER.info(\"[end listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n            return CommonPage.restPage(baseLinePage);\n        } catch (Exception e) {\n            LOGGER.info(\"[get baseline list from database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody), e.toString());\n            throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"list baseline data error\");\n        }\n    }",
  "final_code_with_annotations": "  1: @Service\n  2: public class BaseLineServiceImpl implements BaseLineService {\n  3: \n  4:     private static final Logger LOGGER = LogManager.getLogger(BaseLineServiceImpl.class);\n  5: \n  6:     @Resource\n  7:     private CommonUtil commonUtil;\n  8: \n  9:     @Resource(name = \"redisPipelineDegradeUtils\")\n 10:     RedisPipelineDegradeUtils redisPipelineUtils;\n 11: \n 12:     @Resource(name = \"redis2PipelineDegradeUtils\")\n 13:     RedisPipelineDegradeUtils redis2PipelineUtils;\n 14: \n 15:     @Resource\n 16:     private BaseLineMapper baseLineMapper;\n 17: public CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException { // [禁止修改-目标实现]\n 18:         LOGGER.info(\"[begin listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody)); // [禁止修改-目标实现]\n 19:         try { // [禁止修改-目标实现]\n 20:             Map<String, Object> paramMap = getParamMap(requestBody); // [禁止修改-目标实现]\n 21:             IPage<BaseLineEntity> baseLinePage = new Page<>(requestBody.getPageNum(), requestBody.getPageSize()); // [禁止修改-目标实现]\n 22:             // 若分表字段不为空，则去该分表查询 // [禁止修改-目标实现]\n 23:             if (StringUtil.isNotEmpty(requestBody.getLabelId())) { // [禁止修改-目标实现]\n 24:                 baseLinePage = baseLineMapper.selectPageByLabelId(baseLinePage, paramMap); // [禁止修改-目标实现]\n 25:             } else { // [禁止修改-目标实现]\n 26:                 baseLinePage = baseLineMapper.selectPageByMap(baseLinePage, paramMap); // [禁止修改-目标实现]\n 27:             } // [禁止修改-目标实现]\n 28:             LOGGER.info(\"[end listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody)); // [禁止修改-目标实现]\n 29:             return CommonPage.restPage(baseLinePage); // [禁止修改-目标实现]\n 30:         } catch (Exception e) { // [禁止修改-目标实现]\n 31:             LOGGER.info(\"[get baseline list from database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody), e.toString()); // [禁止修改-目标实现]\n 32:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"list baseline data error\"); // [禁止修改-目标实现]\n 33:         } // [禁止修改-目标实现]\n 34:     } // [禁止修改-目标实现]\n 35: /**\n 36:      * 批量更新告警基线数据\n 37:      *\n 38:      * @param requestBody\n 39:      * @return 成功更新的条数\n 40:      * @throws VscServiceException\n 41:      **/\n 42:     @Override\n 43:     @Transactional(rollbackFor = Exception.class)\n 44:     public int batchUpdate(UpdateBaseLineRequestBody requestBody) throws VscServiceException {\n 45:         String operateUser = DevCloudTokenStore.getUserName();\n 46:         LOGGER.info(\"[begin batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n 47:         String operateUuid = UUID.randomUUID().toString();\n 48:         List<TableBatchLogContent> logContents = new ArrayList<>();\n 49:         try {\n 50:             // 根据表名对sid进行分组\n 51:             List<BatchBaseLineRequestBody> batchList = requestBody.getBatchList();\n 52:             Map<String, List<String>> tableGroup = getTableGroup(batchList);\n 53:             Map<String, Object> paramMap = getUpdateParamMap(requestBody);\n 54:             AtomicInteger affectRows = new AtomicInteger();\n 55:             // 分组对基线数据分表进行批量更新\n 56:             tableGroup.forEach((key, value) -> {\n 57:                 if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n 58:                     paramMap.put(\"tableName\", key);\n 59:                     paramMap.put(\"sids\", value);\n 60:                     int rows = baseLineMapper.updateBySids(paramMap);\n 61:                     affectRows.addAndGet(rows);\n 62:                     TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.UPDATE, key);\n 63:                     logContents.add(logContent);\n 64:                 }\n 65:             });\n 66:             commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n 67:             LOGGER.info(\"[end batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n 68:             return affectRows.get();\n 69:         } catch (Exception e) {\n 70:             LOGGER.error(\"[batch update baseline data to database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody),\n 71:                 e.toString());\n 72:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch update baseline data error\");\n 73:         }\n 74:     }\n 75: \n 76:     /**\n 77:      * 批量删除告警基线数据\n 78:      *\n 79:      * @param requestBodyList\n 80:      * @return 成功删除的条数\n 81:      * @throws VscServiceException\n 82:      **/\n 83:     @Override\n 84:     @Transactional(rollbackFor = Exception.class)\n 85:     public int batchDelete(List<BatchBaseLineRequestBody> requestBodyList) throws VscServiceException {\n 86:         String operateUser = DevCloudTokenStore.getUserName();\n 87:         LOGGER.info(\"[begin batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n 88:         if (CollectionUtils.isEmpty(requestBodyList)) {\n 89:             throw ExceptionUtils.handleServeException(CommonErrorCode.USER_ILLEGAL_ARGUMENT, \"batch delete baseline argument cannot be empty\");\n 90:         }\n 91:         String operateUuid = UUID.randomUUID().toString();\n 92:         List<TableBatchLogContent> logContents = new ArrayList<>();\n 93:         try {\n 94:             // 根据表名对sid进行分组\n 95:             Map<String, List<String>> tableGroup = getTableGroup(requestBodyList);\n 96:             Map<String, Object> paramMap = new HashMap<>();\n 97:             AtomicInteger affectRows = new AtomicInteger();\n 98:             // 分组对基线数据分表进行批量删除\n 99:             tableGroup.forEach((key, value) -> {\n100:                 if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n101:                     paramMap.put(\"tableName\", key);\n102:                     paramMap.put(\"sids\", value);\n103:                     int rows = baseLineMapper.deleteBySids(paramMap);\n104:                     affectRows.addAndGet(rows);\n105:                     TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.DELETE, key);\n106:                     logContents.add(logContent);\n107:                 }\n108:             });\n109:             // 清理缓存\n110:             String[] mergeKeys = requestBodyList.stream().map(BatchBaseLineRequestBody::getMergeKey).toArray(String[]::new);\n111:             LOGGER.info(\"[batch delete labelId from redis begin][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n112:             redisPipelineUtils.multiDel(mergeKeys);\n113:             redis2PipelineUtils.multiDel(mergeKeys);\n114:             LOGGER.info(\"[batch delete labelId from redis end][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n115:             commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n116:             LOGGER.info(\"[end batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n117:             return affectRows.get();\n118:         } catch (Exception e) {\n119:             LOGGER.error(\"[batch delete baseline data from database error][requestBodyList = {}, message = {}]\",\n120:                 JsonUtils.toJSONString(requestBodyList), e.toString());\n121:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch delete baseline data error\");\n122:         }\n123:     }\n124: \n125:     /**\n126:      * 将请求体转换成map\n127:      **/\n128:     private Map<String, Object> getParamMap(ListBaseLineRequestBody requestBody) throws VscUserException {\n129:         Map<String, Object> paramMap = new HashMap<>();\n130:         if (!CollectionUtils.isEmpty(requestBody.getMergeKeys())) {\n131:             paramMap.put(\"mergeKeys\", requestBody.getMergeKeys());\n132:         }\n133: \n134:         if (StringUtil.isNotEmpty(requestBody.getScanTaskId())) {\n135:             paramMap.put(\"scanTaskId\", requestBody.getScanTaskId());\n136:         }\n137: \n138:         if (StringUtil.isNotEmpty(requestBody.getAnalyseUser())) {\n139:             paramMap.put(\"analyseUser\", requestBody.getAnalyseUser());\n140:         }\n141: \n142:         if (StringUtil.isNotEmpty(requestBody.getApproveUser())) {\n143:             paramMap.put(\"approveUser\", requestBody.getApproveUser());\n144:         }\n145: \n146:         if (requestBody.getAnalyseResult() != null) {\n147:             paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n148:         }\n149: \n150:         if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeStart())) {\n151:             paramMap.put(\"synchronizeTimeStart\", requestBody.getSynchronizeTimeStart());\n152:         }\n153: \n154:         if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeEnd())) {\n155:             paramMap.put(\"synchronizeTimeEnd\", requestBody.getSynchronizeTimeEnd());\n156:         }\n157: \n158:         if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n159:             paramMap.put(\"labelId\", requestBody.getLabelId());\n160:             String tableName = TaskUtil.getAlarmBaselineTableName(requestBody.getLabelId());\n161:             paramMap.put(\"tableName\", tableName);\n162:         } else {\n163:             getTableNames(paramMap);\n164:         }\n165:         return paramMap;\n166:     }\n167: \n168:     /**\n169:      * 获取分表的所有表名\n170:      **/\n171:     private void getTableNames(Map<String, Object> paramMap) {\n172:         List<String> tableNames = new ArrayList<>();\n173:         for (int i = 0; i < 10; i++) {\n174:             tableNames.add(\"t_am_baseline_\" + i);\n175:         }\n176:         paramMap.put(\"tableName\", tableNames.get(0));\n177:         if (tableNames.size() > 1) {\n178:             String[] otherTables = new String[tableNames.size() - 1];\n179:             for (int i = 1; i < tableNames.size(); i++) {\n180:                 otherTables[i - 1] = tableNames.get(i);\n181:             }\n182:             paramMap.put(\"otherTables\", otherTables);\n183:         }\n184:     }\n185: \n186:     /**\n187:      * 将请求体转成更新map\n188:      **/\n189:     @NotNull\n190:     private Map<String, Object> getUpdateParamMap(UpdateBaseLineRequestBody requestBody) {\n191:         Map<String, Object> paramMap = new HashMap<>();\n192:         if (requestBody.getAnalyseResult() != null) {\n193:             paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n194:         }\n195:         if (StringUtil.isNotEmpty(requestBody.getAnalyseDetail())) {\n196:             paramMap.put(\"analyseDetail\", requestBody.getAnalyseDetail());\n197:         }\n198: \n199:         if (StringUtil.isNotEmpty(requestBody.getApproveDetail())) {\n200:             paramMap.put(\"approveDetail\", requestBody.getApproveDetail());\n201:         }\n202:         paramMap.put(\"lastUpdateUser\", DevCloudTokenStore.getUserName());\n203:         return paramMap;\n204:     }\n205: \n206:     /**\n207:      * 根据分表表名对sid进行分组\n208:      **/\n209:     @NotNull\n210:     private Map<String, List<String>> getTableGroup(List<BatchBaseLineRequestBody> requestBodyList) throws VscUserException {\n211:         Map<String, List<String>> tableGroup = new HashMap<>();\n212:         for (BatchBaseLineRequestBody item : requestBodyList) {\n213:             String tableName = TaskUtil.getAlarmBaselineTableName(item.getLabelId());\n214:             List<String> sids = tableGroup.getOrDefault(tableName, new ArrayList<>());\n215:             sids.add(item.getSid());\n216:             tableGroup.put(tableName, sids);\n217:         }\n218:         return tableGroup;\n219:     }\n220: }",
  "prompt": {
    "system_prompt": "(1) System Prompt\n\n你是资深 Java 工程师。现在给你一个完整的代码文件（最终状态），你需要**倒推**出为了达到这个最终状态而**刚刚**做过的3次递进式代码修改（Recent Changes）。\n\n核心逻辑：\n- 给出的代码是最终完整状态，每行都有行号标注\n- 你需要倒推出3个历史版本的修改过程\n- 演进路径：初始版本 → RC3 → RC2 → RC1 → 当前最终版本\n- **关键**：不要在最终状态基础上再做修改，而是倒推出达到最终状态的历史修改过程\n\n重要约束：\n1. **禁止修改区域**：不能修改标注为\"禁止修改\"的代码部分\n2. **只能修改**：其他未标注为禁止修改的代码部分\n3. **不新增**：import/依赖；不修改方法签名/可见性；不创建/删除类\n4. **RC目标**：每个RC都应该为实现目标功能做准备工作\n5. **diff格式**：使用标准的unified diff格式，包含行号和+/-操作\n6. **行号准确性**：diff中的行号必须与给出的带行号代码完全一致\n7. **倒推逻辑**：从最终状态向前倒推，不是在最终状态上继续修改\n\n**🔥 DIFF方向关键说明**：\n- hunks_3 / hunks_2 / hunks_1：每一步都是\"RC_k ➜ 下一步更接近最终\"的**正向补丁**\n- **+ 行**：在\"更接近最终的版本/最终版\"中存在的行（应与最终版行号、内容一致）\n- **- 行**：只存在于\"更早版本\"的行（在演进过程中被替换掉的内容）\n- **所有行号以你给的最终代码为准**，在 diff_content 的可见行里必须匹配\n\n技术要求：\n- 每个 hunk 包含：file_path、start_line、end_line、diff_content（标准unified diff格式）\n- 使用精确的行号定位，基于给出的带行号的代码\n- diff_content必须包含真实的删除(-)和新增(+)操作\n- **重要**：diff中的行号必须与最终代码的实际行号匹配\n\n(2) User Prompt\n\n[SELECTED_REGION] - 禁止修改\n选中的代码区域（不可修改）：\n{selected_region}\n\n[TARGET_IMPLEMENTATION] - 禁止修改\n目标实现代码（不可修改）：\n{target_implementation}\n\n[FINAL_CODE_WITH_LINE_NUMBERS] - 最终状态（带行号和标注）\n以下是最终完整代码状态，每行都有行号标注，并标注了禁止修改的区域：\n{final_code_with_annotations}\n\n[RC_CONSTRAINTS]\nRecent Changes约束：\n1. 只能修改未标注为\"禁止修改\"的代码部分\n2. 每个RC都应该为实现TARGET_IMPLEMENTATION做准备工作\n3. 使用精确的行号定位和标准diff格式\n4. RC应该体现真实的开发演进过程\n5. **关键**：diff中的行号必须与上面给出的最终代码行号完全一致\n6. **倒推思维**：从最终状态倒推历史修改，不是在最终状态上继续开发\n\n**🎯 DIFF方向再次强调**：\n- 每个RC都是朝着最终状态的**正向演进**\n- **+ 行**：最终版本中存在的内容（目标状态的行）\n- **- 行**：历史版本中存在但被替换的内容（旧状态的行）\n- **验证方法**：+ 行的内容应该能在最终代码的对应行号找到\n\n[INTENT]\n请倒推出为了实现TARGET_IMPLEMENTATION，开发者做过的3次递进式准备工作：\n- hunks_3: 倒数第三次修改（最早的准备工作）\n- hunks_2: 倒数第二次修改（中间准备）\n- hunks_1: 最近一次修改（最后的准备工作）\n\n每次修改都应该：\n1. 基于精确的行号定位（与最终代码行号完全一致）\n2. 使用标准的unified diff格式\n3. 为实现TARGET_IMPLEMENTATION做必要准备\n4. 体现真实的开发思维过程\n5. **验证**：确保diff中的行号与最终代码中的实际行号匹配\n6. **倒推验证**：确保是从最终状态向前倒推的修改过程\n7. **方向验证**：+ 行内容应该在最终代码中存在，- 行内容应该是被替换的历史内容\n\n[RETURN FORMAT]\n### hunks_3 (倒数第三次修改，最早的准备工作)\n```json\n[\n    {{\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }}\n]\n```\n\n### hunks_2 (倒数第二次修改，中间准备)\n```json\n[\n    {{\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }}\n]\n```\n\n### hunks_1 (最近一次修改，最后的准备工作)\n```json\n[\n    {{\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }}\n]\n```\n\n### notes\n简要说明这3次准备工作如何为实现TARGET_IMPLEMENTATION做准备，体现倒推的逻辑思维\n",
    "user_prompt": "[SELECTED_REGION] - 禁止修改\n选中的代码区域（不可修改）：\n// 分页查询告警基线数据\npublic CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException\n\n[TARGET_IMPLEMENTATION] - 禁止修改\n目标实现代码（不可修改）：\npublic CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException {\n        LOGGER.info(\"[begin listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n        try {\n            Map<String, Object> paramMap = getParamMap(requestBody);\n            IPage<BaseLineEntity> baseLinePage = new Page<>(requestBody.getPageNum(), requestBody.getPageSize());\n            // 若分表字段不为空，则去该分表查询\n            if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n                baseLinePage = baseLineMapper.selectPageByLabelId(baseLinePage, paramMap);\n            } else {\n                baseLinePage = baseLineMapper.selectPageByMap(baseLinePage, paramMap);\n            }\n            LOGGER.info(\"[end listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n            return CommonPage.restPage(baseLinePage);\n        } catch (Exception e) {\n            LOGGER.info(\"[get baseline list from database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody), e.toString());\n            throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"list baseline data error\");\n        }\n    }\n\n[FINAL_CODE_WITH_LINE_NUMBERS] - 最终状态（带行号和标注）\n以下是最终完整代码状态，每行都有行号标注，并标注了禁止修改的区域：\n  1: @Service\n  2: public class BaseLineServiceImpl implements BaseLineService {\n  3: \n  4:     private static final Logger LOGGER = LogManager.getLogger(BaseLineServiceImpl.class);\n  5: \n  6:     @Resource\n  7:     private CommonUtil commonUtil;\n  8: \n  9:     @Resource(name = \"redisPipelineDegradeUtils\")\n 10:     RedisPipelineDegradeUtils redisPipelineUtils;\n 11: \n 12:     @Resource(name = \"redis2PipelineDegradeUtils\")\n 13:     RedisPipelineDegradeUtils redis2PipelineUtils;\n 14: \n 15:     @Resource\n 16:     private BaseLineMapper baseLineMapper;\n 17: public CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException { // [禁止修改-目标实现]\n 18:         LOGGER.info(\"[begin listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody)); // [禁止修改-目标实现]\n 19:         try { // [禁止修改-目标实现]\n 20:             Map<String, Object> paramMap = getParamMap(requestBody); // [禁止修改-目标实现]\n 21:             IPage<BaseLineEntity> baseLinePage = new Page<>(requestBody.getPageNum(), requestBody.getPageSize()); // [禁止修改-目标实现]\n 22:             // 若分表字段不为空，则去该分表查询 // [禁止修改-目标实现]\n 23:             if (StringUtil.isNotEmpty(requestBody.getLabelId())) { // [禁止修改-目标实现]\n 24:                 baseLinePage = baseLineMapper.selectPageByLabelId(baseLinePage, paramMap); // [禁止修改-目标实现]\n 25:             } else { // [禁止修改-目标实现]\n 26:                 baseLinePage = baseLineMapper.selectPageByMap(baseLinePage, paramMap); // [禁止修改-目标实现]\n 27:             } // [禁止修改-目标实现]\n 28:             LOGGER.info(\"[end listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody)); // [禁止修改-目标实现]\n 29:             return CommonPage.restPage(baseLinePage); // [禁止修改-目标实现]\n 30:         } catch (Exception e) { // [禁止修改-目标实现]\n 31:             LOGGER.info(\"[get baseline list from database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody), e.toString()); // [禁止修改-目标实现]\n 32:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"list baseline data error\"); // [禁止修改-目标实现]\n 33:         } // [禁止修改-目标实现]\n 34:     } // [禁止修改-目标实现]\n 35: /**\n 36:      * 批量更新告警基线数据\n 37:      *\n 38:      * @param requestBody\n 39:      * @return 成功更新的条数\n 40:      * @throws VscServiceException\n 41:      **/\n 42:     @Override\n 43:     @Transactional(rollbackFor = Exception.class)\n 44:     public int batchUpdate(UpdateBaseLineRequestBody requestBody) throws VscServiceException {\n 45:         String operateUser = DevCloudTokenStore.getUserName();\n 46:         LOGGER.info(\"[begin batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n 47:         String operateUuid = UUID.randomUUID().toString();\n 48:         List<TableBatchLogContent> logContents = new ArrayList<>();\n 49:         try {\n 50:             // 根据表名对sid进行分组\n 51:             List<BatchBaseLineRequestBody> batchList = requestBody.getBatchList();\n 52:             Map<String, List<String>> tableGroup = getTableGroup(batchList);\n 53:             Map<String, Object> paramMap = getUpdateParamMap(requestBody);\n 54:             AtomicInteger affectRows = new AtomicInteger();\n 55:             // 分组对基线数据分表进行批量更新\n 56:             tableGroup.forEach((key, value) -> {\n 57:                 if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n 58:                     paramMap.put(\"tableName\", key);\n 59:                     paramMap.put(\"sids\", value);\n 60:                     int rows = baseLineMapper.updateBySids(paramMap);\n 61:                     affectRows.addAndGet(rows);\n 62:                     TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.UPDATE, key);\n 63:                     logContents.add(logContent);\n 64:                 }\n 65:             });\n 66:             commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n 67:             LOGGER.info(\"[end batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n 68:             return affectRows.get();\n 69:         } catch (Exception e) {\n 70:             LOGGER.error(\"[batch update baseline data to database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody),\n 71:                 e.toString());\n 72:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch update baseline data error\");\n 73:         }\n 74:     }\n 75: \n 76:     /**\n 77:      * 批量删除告警基线数据\n 78:      *\n 79:      * @param requestBodyList\n 80:      * @return 成功删除的条数\n 81:      * @throws VscServiceException\n 82:      **/\n 83:     @Override\n 84:     @Transactional(rollbackFor = Exception.class)\n 85:     public int batchDelete(List<BatchBaseLineRequestBody> requestBodyList) throws VscServiceException {\n 86:         String operateUser = DevCloudTokenStore.getUserName();\n 87:         LOGGER.info(\"[begin batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n 88:         if (CollectionUtils.isEmpty(requestBodyList)) {\n 89:             throw ExceptionUtils.handleServeException(CommonErrorCode.USER_ILLEGAL_ARGUMENT, \"batch delete baseline argument cannot be empty\");\n 90:         }\n 91:         String operateUuid = UUID.randomUUID().toString();\n 92:         List<TableBatchLogContent> logContents = new ArrayList<>();\n 93:         try {\n 94:             // 根据表名对sid进行分组\n 95:             Map<String, List<String>> tableGroup = getTableGroup(requestBodyList);\n 96:             Map<String, Object> paramMap = new HashMap<>();\n 97:             AtomicInteger affectRows = new AtomicInteger();\n 98:             // 分组对基线数据分表进行批量删除\n 99:             tableGroup.forEach((key, value) -> {\n100:                 if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n101:                     paramMap.put(\"tableName\", key);\n102:                     paramMap.put(\"sids\", value);\n103:                     int rows = baseLineMapper.deleteBySids(paramMap);\n104:                     affectRows.addAndGet(rows);\n105:                     TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.DELETE, key);\n106:                     logContents.add(logContent);\n107:                 }\n108:             });\n109:             // 清理缓存\n110:             String[] mergeKeys = requestBodyList.stream().map(BatchBaseLineRequestBody::getMergeKey).toArray(String[]::new);\n111:             LOGGER.info(\"[batch delete labelId from redis begin][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n112:             redisPipelineUtils.multiDel(mergeKeys);\n113:             redis2PipelineUtils.multiDel(mergeKeys);\n114:             LOGGER.info(\"[batch delete labelId from redis end][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n115:             commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n116:             LOGGER.info(\"[end batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n117:             return affectRows.get();\n118:         } catch (Exception e) {\n119:             LOGGER.error(\"[batch delete baseline data from database error][requestBodyList = {}, message = {}]\",\n120:                 JsonUtils.toJSONString(requestBodyList), e.toString());\n121:             throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch delete baseline data error\");\n122:         }\n123:     }\n124: \n125:     /**\n126:      * 将请求体转换成map\n127:      **/\n128:     private Map<String, Object> getParamMap(ListBaseLineRequestBody requestBody) throws VscUserException {\n129:         Map<String, Object> paramMap = new HashMap<>();\n130:         if (!CollectionUtils.isEmpty(requestBody.getMergeKeys())) {\n131:             paramMap.put(\"mergeKeys\", requestBody.getMergeKeys());\n132:         }\n133: \n134:         if (StringUtil.isNotEmpty(requestBody.getScanTaskId())) {\n135:             paramMap.put(\"scanTaskId\", requestBody.getScanTaskId());\n136:         }\n137: \n138:         if (StringUtil.isNotEmpty(requestBody.getAnalyseUser())) {\n139:             paramMap.put(\"analyseUser\", requestBody.getAnalyseUser());\n140:         }\n141: \n142:         if (StringUtil.isNotEmpty(requestBody.getApproveUser())) {\n143:             paramMap.put(\"approveUser\", requestBody.getApproveUser());\n144:         }\n145: \n146:         if (requestBody.getAnalyseResult() != null) {\n147:             paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n148:         }\n149: \n150:         if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeStart())) {\n151:             paramMap.put(\"synchronizeTimeStart\", requestBody.getSynchronizeTimeStart());\n152:         }\n153: \n154:         if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeEnd())) {\n155:             paramMap.put(\"synchronizeTimeEnd\", requestBody.getSynchronizeTimeEnd());\n156:         }\n157: \n158:         if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n159:             paramMap.put(\"labelId\", requestBody.getLabelId());\n160:             String tableName = TaskUtil.getAlarmBaselineTableName(requestBody.getLabelId());\n161:             paramMap.put(\"tableName\", tableName);\n162:         } else {\n163:             getTableNames(paramMap);\n164:         }\n165:         return paramMap;\n166:     }\n167: \n168:     /**\n169:      * 获取分表的所有表名\n170:      **/\n171:     private void getTableNames(Map<String, Object> paramMap) {\n172:         List<String> tableNames = new ArrayList<>();\n173:         for (int i = 0; i < 10; i++) {\n174:             tableNames.add(\"t_am_baseline_\" + i);\n175:         }\n176:         paramMap.put(\"tableName\", tableNames.get(0));\n177:         if (tableNames.size() > 1) {\n178:             String[] otherTables = new String[tableNames.size() - 1];\n179:             for (int i = 1; i < tableNames.size(); i++) {\n180:                 otherTables[i - 1] = tableNames.get(i);\n181:             }\n182:             paramMap.put(\"otherTables\", otherTables);\n183:         }\n184:     }\n185: \n186:     /**\n187:      * 将请求体转成更新map\n188:      **/\n189:     @NotNull\n190:     private Map<String, Object> getUpdateParamMap(UpdateBaseLineRequestBody requestBody) {\n191:         Map<String, Object> paramMap = new HashMap<>();\n192:         if (requestBody.getAnalyseResult() != null) {\n193:             paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n194:         }\n195:         if (StringUtil.isNotEmpty(requestBody.getAnalyseDetail())) {\n196:             paramMap.put(\"analyseDetail\", requestBody.getAnalyseDetail());\n197:         }\n198: \n199:         if (StringUtil.isNotEmpty(requestBody.getApproveDetail())) {\n200:             paramMap.put(\"approveDetail\", requestBody.getApproveDetail());\n201:         }\n202:         paramMap.put(\"lastUpdateUser\", DevCloudTokenStore.getUserName());\n203:         return paramMap;\n204:     }\n205: \n206:     /**\n207:      * 根据分表表名对sid进行分组\n208:      **/\n209:     @NotNull\n210:     private Map<String, List<String>> getTableGroup(List<BatchBaseLineRequestBody> requestBodyList) throws VscUserException {\n211:         Map<String, List<String>> tableGroup = new HashMap<>();\n212:         for (BatchBaseLineRequestBody item : requestBodyList) {\n213:             String tableName = TaskUtil.getAlarmBaselineTableName(item.getLabelId());\n214:             List<String> sids = tableGroup.getOrDefault(tableName, new ArrayList<>());\n215:             sids.add(item.getSid());\n216:             tableGroup.put(tableName, sids);\n217:         }\n218:         return tableGroup;\n219:     }\n220: }\n\n[RC_CONSTRAINTS]\nRecent Changes约束：\n1. 只能修改未标注为\"禁止修改\"的代码部分\n2. 每个RC都应该为实现TARGET_IMPLEMENTATION做准备工作\n3. 使用精确的行号定位和标准diff格式\n4. RC应该体现真实的开发演进过程\n5. **关键**：diff中的行号必须与上面给出的最终代码行号完全一致\n6. **倒推思维**：从最终状态倒推历史修改，不是在最终状态上继续开发\n\n[INTENT]\n请倒推出为了实现TARGET_IMPLEMENTATION，开发者做过的3次递进式准备工作：\n- hunks_3: 倒数第三次修改（最早的准备工作）\n- hunks_2: 倒数第二次修改（中间准备）\n- hunks_1: 最近一次修改（最后的准备工作）\n\n每次修改都应该：\n1. 基于精确的行号定位（与最终代码行号完全一致）\n2. 使用标准的unified diff格式\n3. 为实现TARGET_IMPLEMENTATION做必要准备\n4. 体现真实的开发思维过程\n5. **验证**：确保diff中的行号与最终代码中的实际行号匹配\n6. **倒推验证**：确保是从最终状态向前倒推的修改过程\n\n[RETURN FORMAT]\n### hunks_3 (倒数第三次修改，最早的准备工作)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### hunks_2 (倒数第二次修改，中间准备)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### hunks_1 (最近一次修改，最后的准备工作)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### notes\n简要说明这3次准备工作如何为实现TARGET_IMPLEMENTATION做准备，体现倒推的逻辑思维"
  },
  "llm_response": "",
  "parsed_hunks": {},
  "validation_results": {},
  "usage": {},
  "original_benchmark": {
    "prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\npublic class CommonPage {\n    public static <T> CommonPage<T> restPage(IPage<T> pageInfo); /* 将Page分页后的list转为分页信息 */\n}\n\npublic class ExceptionUtils {\n    public static VscServiceException getSqlException(DataAccessException dataAccessException, String msg);\n    public static VscUserException handleUserException(CommonErrorCode commonErrorCode, String msg); /* 处理用户侧异常函数 */\n    public static VscServerException handleServeException(CommonErrorCode commonErrorCode, String msg); /* 处理服务端异常函数 */\n}\n\npublic class CommonUtil {\n    public static int getQuerySwitch(Integer querySwitch); /* 检查前台传入的querySwitch配置参数,如果没传根据shardingSwitch判断 */\n    public boolean checkObjAllFieldsIsNull(Object obj) throws VscServerException; /* 任务列表查询条件不能为空 */\n    public String downloadFile(String srcFilePath, String dstFilePath) throws VscServerException;\n    public void insertLogToDb(List<? extends LogContent> list, Integer count, int operateType, String operateUser, String operateUuid); /* 将这次的操作记录到审计表 */\n    public void changeParamAndCheck(ShowTaskListDataRequestBody showTaskListDataRequestBody, HashMap<String, Object> map); /* 构造符合条件的map */\n    public OperLogEntity getOperLogEntity(List<? extends LogContent> list, Integer count, String operateUser, int operateType,\n                                          String operateLogUuid); /* 构建实体类 */\n    public TableBatchLogContent getOpTableBatchLogEntity(List<String> uuids, int status, String operateType, String tableName); /* 构造表批量操作日志消息体 */\n    public TableLogContent getOperateTableLogEntity(String uuid, int status, String operateType, String tableName); /* 构造scan维度操作日志消息体 */\n    public UserOperLogContent getUserLogEntity(String taskId, int httpStatus, int isForce, String operateType); /* 构造user维度操作日志消息体 */\n    public ArrayList<? extends SelectPageRequestBody> getNotNullField(SelectPageRequestBody selectPageRequestBody) throws IllegalAccessException; /* 判断变量是否为空，返回不为空的变量 只用于继承了SelectPageRequestBody的类 */\n    public ArrayList<? extends RequestBodyUuid> getNotNullField(TableRequestBody tableRequestBody) throws VscUserException, IllegalAccessException; /* 判断变量是否为空，返回不为空的变量 只用于继承了RequestBodyUuid的类 */\n    public List<UserTaskEntity> getUserTaskEntityByUserTaskId(List<String> userTaskIds, Integer querySwitch); /* 通过userTaskId，查找usertaskInfo */\n    public SetScanTaskRequestBody getSetScanTaskRequestBody(String userTaskId, String scanTaskId, String operateUser, Integer isForce); /* 设置失败，重新触发请求体  ---->taskctrl */\n    public CmdTaskRequestBody getCmdTaskRequestBody(String userTaskId, String operateUser, String uuid, Integer isForce); /* 暂停，停止请求体  --->taskctrl */\n    public String checkRouteId(String routeId);\n    public ResponseEntity<?> getPostResponseEntity(Object requestBody, String url, String routeId); /* post请求 */\n    public static void checkIds(String userTaskid, String scanTaskId) throws VscUserException, VscServerException;\n    public static String toCamelCase(String s); /* _|-转小驼峰 */\n    public static void cleanFile(String filePath);\n    public static Long getUploadTimeRange(Long fileSize); /* 获取文件上传需要时间长度 */\n    public static HashMap<String, Object> objectToMap(Object object); /* 将简单的对象转换成map集合,对象中数据不需要做处理，直接可以转换的可以用该函数 */\n    public static String getSubmitTime(String submitTime, String timePrefix, String timeSuffix);\n    public static boolean isNotFinishTask(TaskDataDo taskDataDo); /* 判断任务是否是结束状态， */\n}\n```\n\nThe context above is:\n```java\n@Service\npublic class BaseLineServiceImpl implements BaseLineService {\n\n    private static final Logger LOGGER = LogManager.getLogger(BaseLineServiceImpl.class);\n\n    @Resource\n    private CommonUtil commonUtil;\n\n    @Resource(name = \"redisPipelineDegradeUtils\")\n    RedisPipelineDegradeUtils redisPipelineUtils;\n\n    @Resource(name = \"redis2PipelineDegradeUtils\")\n    RedisPipelineDegradeUtils redis2PipelineUtils;\n\n    @Resource\n    private BaseLineMapper baseLineMapper;\n```\n\nThe context below is:\n```java\n\n    /**\n     * 批量更新告警基线数据\n     *\n     * @param requestBody\n     * @return 成功更新的条数\n     * @throws VscServiceException\n     **/\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public int batchUpdate(UpdateBaseLineRequestBody requestBody) throws VscServiceException {\n        String operateUser = DevCloudTokenStore.getUserName();\n        LOGGER.info(\"[begin batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n        String operateUuid = UUID.randomUUID().toString();\n        List<TableBatchLogContent> logContents = new ArrayList<>();\n        try {\n            // 根据表名对sid进行分组\n            List<BatchBaseLineRequestBody> batchList = requestBody.getBatchList();\n            Map<String, List<String>> tableGroup = getTableGroup(batchList);\n            Map<String, Object> paramMap = getUpdateParamMap(requestBody);\n            AtomicInteger affectRows = new AtomicInteger();\n            // 分组对基线数据分表进行批量更新\n            tableGroup.forEach((key, value) -> {\n                if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n                    paramMap.put(\"tableName\", key);\n                    paramMap.put(\"sids\", value);\n                    int rows = baseLineMapper.updateBySids(paramMap);\n                    affectRows.addAndGet(rows);\n                    TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.UPDATE, key);\n                    logContents.add(logContent);\n                }\n            });\n            commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n            LOGGER.info(\"[end batchUpdate baseline][operateUser = {}, requestBody = {}]\", operateUser, JsonUtils.toJSONString(requestBody));\n            return affectRows.get();\n        } catch (Exception e) {\n            LOGGER.error(\"[batch update baseline data to database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody),\n                e.toString());\n            throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch update baseline data error\");\n        }\n    }\n\n    /**\n     * 批量删除告警基线数据\n     *\n     * @param requestBodyList\n     * @return 成功删除的条数\n     * @throws VscServiceException\n     **/\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public int batchDelete(List<BatchBaseLineRequestBody> requestBodyList) throws VscServiceException {\n        String operateUser = DevCloudTokenStore.getUserName();\n        LOGGER.info(\"[begin batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n        if (CollectionUtils.isEmpty(requestBodyList)) {\n            throw ExceptionUtils.handleServeException(CommonErrorCode.USER_ILLEGAL_ARGUMENT, \"batch delete baseline argument cannot be empty\");\n        }\n        String operateUuid = UUID.randomUUID().toString();\n        List<TableBatchLogContent> logContents = new ArrayList<>();\n        try {\n            // 根据表名对sid进行分组\n            Map<String, List<String>> tableGroup = getTableGroup(requestBodyList);\n            Map<String, Object> paramMap = new HashMap<>();\n            AtomicInteger affectRows = new AtomicInteger();\n            // 分组对基线数据分表进行批量删除\n            tableGroup.forEach((key, value) -> {\n                if (StringUtil.isNotEmpty(key) && !CollectionUtils.isEmpty(value)) {\n                    paramMap.put(\"tableName\", key);\n                    paramMap.put(\"sids\", value);\n                    int rows = baseLineMapper.deleteBySids(paramMap);\n                    affectRows.addAndGet(rows);\n                    TableBatchLogContent logContent = commonUtil.getOpTableBatchLogEntity(value, rows, CommonConstans.DELETE, key);\n                    logContents.add(logContent);\n                }\n            });\n            // 清理缓存\n            String[] mergeKeys = requestBodyList.stream().map(BatchBaseLineRequestBody::getMergeKey).toArray(String[]::new);\n            LOGGER.info(\"[batch delete labelId from redis begin][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n            redisPipelineUtils.multiDel(mergeKeys);\n            redis2PipelineUtils.multiDel(mergeKeys);\n            LOGGER.info(\"[batch delete labelId from redis end][keys = {} ]\", JsonUtils.toJSONString(mergeKeys));\n            commonUtil.insertLogToDb(logContents, affectRows.get(), OperateType.CONFIG_CENTER.getCode(), operateUser, operateUuid);\n            LOGGER.info(\"[end batchDelete baseline][operateUser = {}, requestBodyList = {}]\", operateUser, JsonUtils.toJSONString(requestBodyList));\n            return affectRows.get();\n        } catch (Exception e) {\n            LOGGER.error(\"[batch delete baseline data from database error][requestBodyList = {}, message = {}]\",\n                JsonUtils.toJSONString(requestBodyList), e.toString());\n            throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"batch delete baseline data error\");\n        }\n    }\n\n    /**\n     * 将请求体转换成map\n     **/\n    private Map<String, Object> getParamMap(ListBaseLineRequestBody requestBody) throws VscUserException {\n        Map<String, Object> paramMap = new HashMap<>();\n        if (!CollectionUtils.isEmpty(requestBody.getMergeKeys())) {\n            paramMap.put(\"mergeKeys\", requestBody.getMergeKeys());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getScanTaskId())) {\n            paramMap.put(\"scanTaskId\", requestBody.getScanTaskId());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getAnalyseUser())) {\n            paramMap.put(\"analyseUser\", requestBody.getAnalyseUser());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getApproveUser())) {\n            paramMap.put(\"approveUser\", requestBody.getApproveUser());\n        }\n\n        if (requestBody.getAnalyseResult() != null) {\n            paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeStart())) {\n            paramMap.put(\"synchronizeTimeStart\", requestBody.getSynchronizeTimeStart());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getSynchronizeTimeEnd())) {\n            paramMap.put(\"synchronizeTimeEnd\", requestBody.getSynchronizeTimeEnd());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n            paramMap.put(\"labelId\", requestBody.getLabelId());\n            String tableName = TaskUtil.getAlarmBaselineTableName(requestBody.getLabelId());\n            paramMap.put(\"tableName\", tableName);\n        } else {\n            getTableNames(paramMap);\n        }\n        return paramMap;\n    }\n\n    /**\n     * 获取分表的所有表名\n     **/\n    private void getTableNames(Map<String, Object> paramMap) {\n        List<String> tableNames = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            tableNames.add(\"t_am_baseline_\" + i);\n        }\n        paramMap.put(\"tableName\", tableNames.get(0));\n        if (tableNames.size() > 1) {\n            String[] otherTables = new String[tableNames.size() - 1];\n            for (int i = 1; i < tableNames.size(); i++) {\n                otherTables[i - 1] = tableNames.get(i);\n            }\n            paramMap.put(\"otherTables\", otherTables);\n        }\n    }\n\n    /**\n     * 将请求体转成更新map\n     **/\n    @NotNull\n    private Map<String, Object> getUpdateParamMap(UpdateBaseLineRequestBody requestBody) {\n        Map<String, Object> paramMap = new HashMap<>();\n        if (requestBody.getAnalyseResult() != null) {\n            paramMap.put(\"analyseResult\", requestBody.getAnalyseResult());\n        }\n        if (StringUtil.isNotEmpty(requestBody.getAnalyseDetail())) {\n            paramMap.put(\"analyseDetail\", requestBody.getAnalyseDetail());\n        }\n\n        if (StringUtil.isNotEmpty(requestBody.getApproveDetail())) {\n            paramMap.put(\"approveDetail\", requestBody.getApproveDetail());\n        }\n        paramMap.put(\"lastUpdateUser\", DevCloudTokenStore.getUserName());\n        return paramMap;\n    }\n\n    /**\n     * 根据分表表名对sid进行分组\n     **/\n    @NotNull\n    private Map<String, List<String>> getTableGroup(List<BatchBaseLineRequestBody> requestBodyList) throws VscUserException {\n        Map<String, List<String>> tableGroup = new HashMap<>();\n        for (BatchBaseLineRequestBody item : requestBodyList) {\n            String tableName = TaskUtil.getAlarmBaselineTableName(item.getLabelId());\n            List<String> sids = tableGroup.getOrDefault(tableName, new ArrayList<>());\n            sids.add(item.getSid());\n            tableGroup.put(tableName, sids);\n        }\n        return tableGroup;\n    }\n}\n```\n\nThe new feature is 使用mybatis-plus-page构建分页条件.\n\nAnd here is the code snippet you are asked to modify:\n```java\n// 分页查询告警基线数据\npublic CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.",
    "domain": "nl2code_java",
    "id": "AdminCtrlService_z00806805#107",
    "good_example_response": "```java\n    public CommonPage<BaseLineEntity> listBaseLine(ListBaseLineRequestBody requestBody) throws VscServiceException {\n        LOGGER.info(\"[begin listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n        try {\n            Map<String, Object> paramMap = getParamMap(requestBody);\n            IPage<BaseLineEntity> baseLinePage = new Page<>(requestBody.getPageNum(), requestBody.getPageSize());\n            // 若分表字段不为空，则去该分表查询\n            if (StringUtil.isNotEmpty(requestBody.getLabelId())) {\n                baseLinePage = baseLineMapper.selectPageByLabelId(baseLinePage, paramMap);\n            } else {\n                baseLinePage = baseLineMapper.selectPageByMap(baseLinePage, paramMap);\n            }\n            LOGGER.info(\"[end listBaseLine][requestBody = {}]\", JsonUtils.toJSONString(requestBody));\n            return CommonPage.restPage(baseLinePage);\n        } catch (Exception e) {\n            LOGGER.info(\"[get baseline list from database error][requestBody = {}, message = {}]\", JsonUtils.toJSONString(requestBody), e.toString());\n            throw ExceptionUtils.handleServeException(CommonErrorCode.SERVER_INTERNAL_ERROR, \"list baseline data error\");\n        }\n    }\n```",
    "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true -Dcheckstyle.skip=true clean test -f pom.xml  -e -Dtest=/com/huawei/secguard/vscloud/vscloudadminctrlservice/service/impl/BaseLineServiceImplTest#test_list_base_line_should_return_not_null_when_test_data_combination",
    "extra_content": {
      "query": "使用mybatis-plus-page构建分页条件",
      "diff_path": "/docker/JavaRunProject/AdminCtrlService_z00806805/diff/107.patch",
      "test_result": "pass",
      "file_path": "/service/src/main/java/com/huawei/secguard/vscloud/vscloudadminctrlservice/service/impl/BaseLineServiceImpl.java",
      "start_line": 77,
      "end_line": 95,
      "work_dir": "/docker/JavaRunProject/AdminCtrlService_z00806805/"
    }
  }
}