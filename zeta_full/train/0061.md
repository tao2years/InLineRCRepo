<events>
User edited file: "src/services/transaction.rs":

```diff
@@ -2,7 +2,7 @@
                     Ok(mut conn) => {
                         let transaction = match conn.begin().await {
                             Ok(tx) => tx,
-                            Err(e) => return Err(DatabaseError::ConnectionFailed(e.to_string())),
+                            Err(e) => return Err(DatabaseError::ConnectionFailed(e.into())),
                         };

                         let account = match self.accounts.find_by_id(&account_id).await {
```

User edited file: "src/services/transaction.rs":

```diff
@@ -7,7 +7,7 @@

                         let account = match self.accounts.find_by_id(&account_id).await {
                             Ok(Some(account)) => account,
-                            Ok(None) => return Err(AccountError::NotFound),
+                            Ok(None) => return Err(AccountError::NotFound(account_id.to_string())),
                             Err(e) => return Err(DatabaseError::QueryFailed {
                                 operation: "find_account",
                                 details: e.to_string(),
```
</events>

<input>
```src/services/transaction.rs
                match self.pool.acquire().await {
                    Ok(mut conn) => {
                        let transaction = match conn.begin().await {
                            Ok(tx) => tx,
                            Err(e) => return Err(DatabaseError::ConnectionFailed(e.into())),
                        };

                        let account = match self.accounts.find_by_id(&account_id).await {
<|editable_region_start|>
                            Ok(Some(account)) => account,
                            Ok(None) => return Err(AccountError::NotFound(account_id.to_string()<|user_cursor_is_here|>)),
                            Err(e) => return Err(DatabaseError::QueryFailed {
                                operation: "find_account",
                                details: e.to_string(),
                                retry_allowed: true
                            }),
                        };

                        if !account.is_active {
                            return Err(AccountError::Inactive {
                                id: account.id.clone(),
                                since: account.deactivated_at.unwrap()
                            });
                        }

                        let balance = match self.balances.get_current(&transaction, &account_id).await {
                            Ok(balance) => balance,
                            Err(e) => return Err(DatabaseError::QueryFailed {
                                operation: "get_balance",
                                details: e.to_string(),
                                retry_allowed: false
                            }),
                        };

                        if amount > balance {
                            return Err(TransactionError::InsufficientFunds {
                                available: balance,
                                requested: amount
<|editable_region_end|>
                            });
                        }
```
</input>

<output>
```src/services/transaction.rs
                match self.pool.acquire().await {
                    Ok(mut conn) => {
                        let transaction = match conn.begin().await {
                            Ok(tx) => tx,
                            Err(e) => return Err(DatabaseError::ConnectionFailed(e.into())),
                        };

                        let account = match self.accounts.find_by_id(&account_id).await {
<|editable_region_start|>
                            Ok(Some(account)) => account,
                            Ok(None) => return Err(AccountError::NotFound(account_id.to_string())),
                            Err(e) => return Err(DatabaseError::QueryFailed {
                                operation: "find_account",
                                details: e.to_string(),
                                retry_allowed: true
                            }),
                        };

                        if !account.is_active {
                            return Err(AccountError::Inactive {
                                id: account.id.clone(),
                                since: account.deactivated_at.unwrap()
                            });
                        }

                        let balance = match self.balances.get_current(&transaction, &account_id).await {
                            Ok(balance) => balance,
                            Err(e) => return Err(DatabaseError::QueryFailed {
                                operation: "get_balance",
                                details: e.into(),
                                retry_allowed: false
                            }),
                        };

                        if amount > balance {
                            return Err(TransactionError::InsufficientFunds {
                                available: balance,
                                requested: amount
<|editable_region_end|>
                            });
                        }
```
</output>

<labels>
non-local-edit,complete-pattern
</labels>
