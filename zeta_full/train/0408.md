<rating>Positive</rating>
<feedback></feedback>
<events>
User edited "crates/fireworks/Cargo.toml":
```diff
@@ -9,7 +9,7 @@
 workspace = true
 
 [lib]
-path = "src/open_ai.rs"
+path = "src/fireworks.rs"
 
 [features]
 default = []

```

User edited "crates/fireworks/Cargo.toml":
```diff
@@ -1,5 +1,5 @@
 [package]
-name = "open_ai"
+name = "fireworks"
 version = "0.1.0"
 edition = "2021"
 publish = false

```

User edited "crates/fireworks/src/fireworks.rs":
```diff
@@ -16,7 +16,7 @@
 
 pub use supported_countries::*;
 
-pub const OPEN_AI_API_URL: &str = "https://api.openai.com/v1";
+pub const FIREWORKS_API_URL: &str = "https://api.openai.com/v1";
 
 fn is_none_or_empty<T: AsRef<[U]>, U>(opt: &Option<T>) -> bool {
     opt.as_ref().map_or(true, |v| v.as_ref().is_empty())

```

User edited "crates/fireworks/src/fireworks.rs":
```diff
@@ -94,7 +94,7 @@
         response.body_mut().read_to_string(&mut body).await?;
 
         #[derive(Deserialize)]
-        struct OpenAiResponse {
+        struct FireworksResponse {
             error: OpenAiError,
         }
 

```
</events>
<input>
```crates/fireworks/src/fireworks.rs
#[derive(Serialize, Deserialize, Debug)]
pub struct Choice {
    pub index: u32,
    pub message: RequestMessage,
    pub finish_reason: Option<String>,
}

pub async fn complete(
    client: &dyn HttpClient,
    api_url: &str,
    api_key: &str,
    request: CompletionRequest,
) -> Result<CompletionResponse> {
    let uri = format!("{api_url}/completions");
    let request_builder = HttpRequest::builder()
        .method(Method::POST)
        .uri(uri)
        .header("Content-Type", "application/json")
        .header("Authorization", format!("Bearer {}", api_key));
<|editable_region_start|>

    let request = request_builder.body(AsyncBody::from(serde_json::to_string(&request)?))?;
    let mut response = client.send(request).await?;

    if response.status().is_success() {
        let mut body = String::new();
        response.body_mut().read_to_string(&mut body).await?;
        let response = serde_json::from_str(&body)?;
        Ok(response)
    } else {
        let mut body = String::new();
        response.body_mut().read_to_string(&mut body).await?;

        #[derive(Deserialize)]
        struct Fireworks<|user_cursor_is_here|>Response {
            error: OpenAiError,
        }

        #[derive(Deserialize)]
        struct OpenAiError {
            message: String,
        }

        match serde_json::from_str::<OpenAiResponse>(&body) {
            Ok(response) if !response.error.message.is_empty() => Err(anyhow!(
                "Failed to connect to OpenAI API: {}",
                response.error.message,
            )),

            _ => Err(anyhow!(
                "Failed to connect to OpenAI API: {} {}",
                response.status(),
                body,
            )),
        }
    }
}

fn adapt_response_to_stream(response: Response) -> ResponseStreamEvent {
    ResponseStreamEvent {
        created: response.created as u32,
        model: response.model,
        choices: response
            .choices
<|editable_region_end|>
            .into_iter()
            .map(|choice| ChoiceDelta {
                index: choice.index,
                delta: ResponseMessageDelta {
```
</input>
<output>
```crates/fireworks/src/fireworks.rs
#[derive(Serialize, Deserialize, Debug)]
pub struct Choice {
    pub index: u32,
    pub message: RequestMessage,
    pub finish_reason: Option<String>,
}

pub async fn complete(
    client: &dyn HttpClient,
    api_url: &str,
    api_key: &str,
    request: CompletionRequest,
) -> Result<CompletionResponse> {
    let uri = format!("{api_url}/completions");
    let request_builder = HttpRequest::builder()
        .method(Method::POST)
        .uri(uri)
        .header("Content-Type", "application/json")
        .header("Authorization", format!("Bearer {}", api_key));
<|editable_region_start|>

    let request = request_builder.body(AsyncBody::from(serde_json::to_string(&request)?))?;
    let mut response = client.send(request).await?;

    if response.status().is_success() {
        let mut body = String::new();
        response.body_mut().read_to_string(&mut body).await?;
        let response = serde_json::from_str(&body)?;
        Ok(response)
    } else {
        let mut body = String::new();
        response.body_mut().read_to_string(&mut body).await?;

        #[derive(Deserialize)]
        struct FireworksResponse {
            error: FireworksError,
        }

        #[derive(Deserialize)]
        struct FireworksError {
            message: String,
        }

        match serde_json::from_str::<FireworksResponse>(&body) {
            Ok(response) if !response.error.message.is_empty() => Err(anyhow!(
                "Failed to connect to Fireworks API: {}",
                response.error.message,
            )),

            _ => Err(anyhow!(
                "Failed to connect to Fireworks API: {} {}",
                response.status(),
                body,
            )),
        }
    }
}

fn adapt_response_to_stream(response: Response) -> ResponseStreamEvent {
    ResponseStreamEvent {
        created: response.created as u32,
        model: response.model,
        choices: response
            .choices
<|editable_region_end|>
            .into_iter()
            .map(|choice| ChoiceDelta {
                index: choice.index,
                delta: ResponseMessageDelta {
```
</output>
<outline>
```crates/fireworks/src/fireworks.rs
pub const FIREWORKS_API_URL
pub struct CompletionRequest
 pub model
 pub prompt
 pub max_tokens
 pub temperature
 pub prediction
 pub rewrite_speculation
pub enum Prediction
 Content
  content
pub struct CompletionResponse
 pub id
 pub object
 pub created
 pub model
 pub choices
 pub usage
pub struct CompletionChoice
 pub text
pub struct Response
 pub id
 pub object
 pub created
 pub model
 pub choices
 pub usage
pub struct Choice
 pub index
 pub message
 pub finish_reason
pub async fn complete
 struct FireworksResponse
  error
 struct OpenAiError
  message
fn adapt_response_to_stream
pub async fn stream_completion
 struct OpenAiResponse
  error
 struct OpenAiError
  message
pub enum OpenAiEmbeddingModel
 TextEmbedding3Small
 TextEmbedding3Large
struct OpenAiEmbeddingRequest
 model
 input
pub struct OpenAiEmbeddingResponse
 pub data
pub struct OpenAiEmbedding
 pub embedding
pub fn embed
pub async fn extract_tool_args_from_events
pub fn extract_text_from_events
```

</outline>

<labels>
local-edit,complete-pattern
</labels>
