<rating>Positive</rating>
<feedback>Neat.</feedback>
<events>
User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1066,7 +1066,7 @@
                         let snapshot = buffer.read(cx).snapshot();
                         if new_completion.should_replace_completion(&old_completion, &snapshot) {
                             this.zeta.update(cx, |zeta, _cx| {
-                                zeta.completion_shown(&new_completion.completion.id)
+                                zeta.completion_shown(&new_completion)
                             });
                             this.current_completion = Some(new_completion);
                         }

```

User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1066,7 +1066,7 @@
                         let snapshot = buffer.read(cx).snapshot();
                         if new_completion.should_replace_completion(&old_completion, &snapshot) {
                             this.zeta.update(cx, |zeta, _cx| {
-                                zeta.completion_shown(&new_completion)
+                                zeta.completion_shown(&new_completion);
                             });
                             this.current_completion = Some(new_completion);
                         }

```
</events>
<input>
```crates/zeta/src/zeta.rs
                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;
            }

            let completion_request = this.update(&mut cx, |this, cx| {
                this.zeta.update(cx, |zeta, cx| {
                    zeta.request_completion(&buffer, position, cx)
                })
            });

            let completion = match completion_request {
                Ok(completion_request) => {
                    let completion_request = completion_request.await;
                    completion_request.map(|completion| CurrentInlineCompletion {
                        buffer_id: buffer.entity_id(),
                        completion,
                    })
                }
                Err(error) => Err(error),
            };
<|editable_region_start|>

            this.update(&mut cx, |this, cx| {
                if this.pending_completions[0].id == pending_completion_id {
                    this.pending_completions.remove(0);
                } else {
                    this.pending_completions.clear();
                }

                if let Some(new_completion) = completion.context("zeta prediction failed").log_err()
                {
                    if let Some(old_completion) = this.current_completion.as_ref() {
                        let snapshot = buffer.read(cx).snapshot();
                        if new_completion.should_replace_completion(&old_completion, &snapshot) {
                            this.zeta.update(cx, |zeta, _cx| {
                                zeta.completion_shown(&new_completion);<|user_cursor_is_here|>
                            });
                            this.current_completion = Some(new_completion);
                        }
                    } else {
                        this.zeta.update(cx, |zeta, _cx| {
                            zeta.completion_shown(new_completion.completion.id)
                        });
                        this.current_completion = Some(new_completion);
                    }
                }

                cx.notify();
            })
            .ok();
        });

        // We always maintain at most two pending completions. When we already
        // have two, we replace the newest one.
        if self.pending_completions.len() <= 1 {
            self.pending_completions.push(PendingCompletion {
                id: pending_completion_id,
                _task: task,
            });
        } else if self.pending_completions.len() == 2 {
            self.pending_completions.pop();
            self.pending_completions.push(PendingCompletion {
<|editable_region_end|>
                id: pending_completion_id,
                _task: task,
            });
        }
    }

    fn cycle(
```
</input>
<output>
```crates/zeta/src/zeta.rs
                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;
            }

            let completion_request = this.update(&mut cx, |this, cx| {
                this.zeta.update(cx, |zeta, cx| {
                    zeta.request_completion(&buffer, position, cx)
                })
            });

            let completion = match completion_request {
                Ok(completion_request) => {
                    let completion_request = completion_request.await;
                    completion_request.map(|completion| CurrentInlineCompletion {
                        buffer_id: buffer.entity_id(),
                        completion,
                    })
                }
                Err(error) => Err(error),
            };
<|editable_region_start|>

            this.update(&mut cx, |this, cx| {
                if this.pending_completions[0].id == pending_completion_id {
                    this.pending_completions.remove(0);
                } else {
                    this.pending_completions.clear();
                }

                if let Some(new_completion) = completion.context("zeta prediction failed").log_err()
                {
                    if let Some(old_completion) = this.current_completion.as_ref() {
                        let snapshot = buffer.read(cx).snapshot();
                        if new_completion.should_replace_completion(&old_completion, &snapshot) {
                            this.zeta.update(cx, |zeta, _cx| {
                                zeta.completion_shown(&new_completion);
                            });
                            this.current_completion = Some(new_completion);
                        }
                    } else {
                        this.zeta.update(cx, |zeta, _cx| {
                            zeta.completion_shown(&new_completion);
                        });
                        this.current_completion = Some(new_completion);
                    }
                }

                cx.notify();
            })
            .ok();
        });

        // We always maintain at most two pending completions. When we already
        // have two, we replace the newest one.
        if self.pending_completions.len() <= 1 {
            self.pending_completions.push(PendingCompletion {
                id: pending_completion_id,
                _task: task,
            });
        } else if self.pending_completions.len() == 2 {
            self.pending_completions.pop();
            self.pending_completions.push(PendingCompletion {
<|editable_region_end|>
                id: pending_completion_id,
                _task: task,
            });
        }
    }

    fn cycle(
```
</output>
<outline>
```crates/zeta/src/zeta.rs
mod rate_completion_modal
const CURSOR_MARKER
const START_OF_FILE_MARKER
const EDITABLE_REGION_START_MARKER
const EDITABLE_REGION_END_MARKER
const BUFFER_CHANGE_GROUPING_INTERVAL
pub struct InlineCompletionId
impl From<InlineCompletionId> for gpui::ElementId
 fn from
impl std::fmt::Display for InlineCompletionId
 fn fmt
impl InlineCompletionId
 fn new
struct ZetaGlobal
impl Global for ZetaGlobal
pub struct InlineCompletion
 id
 path
 excerpt_range
 edits
 snapshot
 input_outline
 input_events
 input_excerpt
 output_excerpt
 request_sent_at
 response_received_at
impl InlineCompletion
 fn latency
 fn interpolate
impl std::fmt::Debug for InlineCompletion
 fn fmt
pub struct Zeta
 client
 events
 registered_buffers
 shown_completions
 rated_completions
 llm_token
 _llm_token_subscription
impl Zeta
 pub fn global
 pub fn register
 pub fn clear_history
 fn new
 fn push_event
  const MAX_EVENT_COUNT
 pub fn register_buffer
 fn handle_buffer_event
 pub fn request_completion_impl
 pub fn fill_with_fake_completions
 pub fn fake_completion
 pub fn request_completion
 fn perform_predict_edits
 fn process_completion_response
 pub fn compute_edits
 pub fn is_completion_rated
 pub fn completion_shown
 pub fn rate_completion
 pub fn recent_completions
 pub fn recent_completions_len
 fn report_changes_for_buffer
fn common_prefix
fn prompt_for_outline
fn prompt_for_excerpt
fn excerpt_range_for_position
 const CONTEXT_LINES
struct RegisteredBuffer
 snapshot
 _subscriptions
enum Event
 BufferChange
  old_snapshot
  new_snapshot
  timestamp
impl Event
 fn to_prompt
struct CurrentInlineCompletion
 buffer_id
 completion
impl CurrentInlineCompletion
 fn should_replace_completion
struct PendingCompletion
 id
 _task
pub struct ZetaInlineCompletionProvider
 zeta
 pending_completions
 next_pending_completion_id
 current_completion
impl ZetaInlineCompletionProvider
 pub const DEBOUNCE_TIMEOUT
 pub fn new
impl inline_completion::InlineCompletionProvider for ZetaInlineCompletionProvider
 fn name
 fn display_name
 fn show_completions_in_menu
 fn show_completions_in_normal_mode
 fn is_enabled
 fn is_refreshing
 fn refresh
 fn cycle
 fn accept
 fn discard
 fn suggest
mod tests
 fn test_inline_completion_basic_interpolation
 async fn test_inline_completion_end_of_buffer
 fn to_completion_edits
 fn from_completion_edits
 fn init_logger
```

</outline>

<labels>
local-edit,infer-intent
</labels>
