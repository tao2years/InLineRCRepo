<rating>Negative</rating>
<feedback>This should add a comment, not delete what I just typed.</feedback>
<events>
User edited "crates/zeta/src/rate_completion_modal.rs":
```diff
@@ -26,6 +26,7 @@
     ]
 );
 
+///
 pub fn init(cx: &mut AppContext) {
     cx.observe_new_views(move |workspace: &mut Workspace, _cx| {
         workspace.register_action(|workspace, _: &RateCompletions, cx| {

```
</events>
<input>
```crates/zeta/src/rate_completion_modal.rs
<|start_of_file|>
use crate::{InlineCompletion, InlineCompletionRating, Zeta};
use editor::Editor;
use gpui::{
    actions, prelude::*, AppContext, DismissEvent, EventEmitter, FocusHandle, FocusableView,
    HighlightStyle, Model, StyledText, TextStyle, View, ViewContext,
};
use language::{language_settings, OffsetRangeExt};
use settings::Settings;
use std::time::Duration;
use theme::ThemeSettings;
use ui::{prelude::*, KeyBinding, List, ListItem, ListItemSpacing, Tooltip};
use workspace::{ModalView, Workspace};

actions!(
    zeta,
    [
        RateCompletions,
        ThumbsUp,
        ThumbsDown,
        ThumbsUpActiveCompletion,
        ThumbsDownActiveCompletion,
<|editable_region_start|>
        NextEdit,
        PreviousEdit,
        FocusCompletions,
        PreviewCompletion,
    ]
);

///<|user_cursor_is_here|>
pub fn init(cx: &mut AppContext) {
    cx.observe_new_views(move |workspace: &mut Workspace, _cx| {
        workspace.register_action(|workspace, _: &RateCompletions, cx| {
            RateCompletionModal::toggle(workspace, cx);
        });
    })
    .detach();
}

pub struct RateCompletionModal {
    zeta: Model<Zeta>,
    active_completion: Option<ActiveCompletion>,
    selected_index: usize,
    focus_handle: FocusHandle,
    _subscription: gpui::Subscription,
<|editable_region_end|>
}

struct ActiveCompletion {
    completion: InlineCompletion,
    feedback_editor: View<Editor>,
}

impl RateCompletionModal {
    pub fn toggle(workspace: &mut Workspace, cx: &mut ViewContext<Workspace>) {
        if let Some(zeta) = Zeta::global(cx) {
            workspace.toggle_modal(cx, |cx| RateCompletionModal::new(zeta, cx));
        }
    }

    pub fn new(zeta: Model<Zeta>, cx: &mut ViewContext<Self>) -> Self {
        let subscription = cx.observe(&zeta, |_, _, cx| cx.notify());
        Self {
            zeta,
            selected_index: 0,
            focus_handle: cx.focus_handle(),
            active_completion: None,
            _subscription: subscription,
```
</input>
<output>
```crates/zeta/src/rate_completion_modal.rs
<|start_of_file|>
use crate::{InlineCompletion, InlineCompletionRating, Zeta};
use editor::Editor;
use gpui::{
    actions, prelude::*, AppContext, DismissEvent, EventEmitter, FocusHandle, FocusableView,
    HighlightStyle, Model, StyledText, TextStyle, View, ViewContext,
};
use language::{language_settings, OffsetRangeExt};
use settings::Settings;
use std::time::Duration;
use theme::ThemeSettings;
use ui::{prelude::*, KeyBinding, List, ListItem, ListItemSpacing, Tooltip};
use workspace::{ModalView, Workspace};

actions!(
    zeta,
    [
        RateCompletions,
        ThumbsUp,
        ThumbsDown,
        ThumbsUpActiveCompletion,
        ThumbsDownActiveCompletion,
<|editable_region_start|>
        NextEdit,
        PreviousEdit,
        FocusCompletions,
        PreviewCompletion,
    ]
);

/// Initialize the rate completion modal.
pub fn init(cx: &mut AppContext) {
    cx.observe_new_views(move |workspace: &mut Workspace, _cx| {
        workspace.register_action(|workspace, _: &RateCompletions, cx| {
            RateCompletionModal::toggle(workspace, cx);
        });
    })
    .detach();
}

pub struct RateCompletionModal {
    zeta: Model<Zeta>,
    active_completion: Option<ActiveCompletion>,
    selected_index: usize,
    focus_handle: FocusHandle,
    _subscription: gpui::Subscription,
<|editable_region_end|>
}

struct ActiveCompletion {
    completion: InlineCompletion,
    feedback_editor: View<Editor>,
}

impl RateCompletionModal {
    pub fn toggle(workspace: &mut Workspace, cx: &mut ViewContext<Workspace>) {
        if let Some(zeta) = Zeta::global(cx) {
            workspace.toggle_modal(cx, |cx| RateCompletionModal::new(zeta, cx));
        }
    }

    pub fn new(zeta: Model<Zeta>, cx: &mut ViewContext<Self>) -> Self {
        let subscription = cx.observe(&zeta, |_, _, cx| cx.notify());
        Self {
            zeta,
            selected_index: 0,
            focus_handle: cx.focus_handle(),
            active_completion: None,
            _subscription: subscription,
```
</output>
<outline>
```crates/zeta/src/rate_completion_modal.rs
pub fn init
pub struct RateCompletionModal
 zeta
 active_completion
 selected_index
 focus_handle
 _subscription
struct ActiveCompletion
 completion
 feedback_editor
impl RateCompletionModal
 pub fn toggle
 pub fn new
 fn dismiss
 fn select_next
 fn select_prev
 fn select_next_edit
 fn select_prev_edit
 fn select_first
 fn select_last
 fn thumbs_up
 fn thumbs_up_active
 fn thumbs_down_active
 fn focus_completions
 fn preview_completion
 fn confirm
 pub fn select_completion
 fn render_active_completion
impl Render for RateCompletionModal
 fn render
impl EventEmitter<DismissEvent> for RateCompletionModal
impl FocusableView for RateCompletionModal
 fn focus_handle
impl ModalView for RateCompletionModal
fn format_time_ago
```

</outline>

<labels>
local-edit,complete-pattern
</labels>
