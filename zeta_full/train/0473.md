<rating>Negative</rating>
<feedback>Bad, should be a no-op.</feedback>
<events>
User edited "src/chunk.rs":
```diff
@@ -19,6 +19,8 @@
         this.push_str(text);
         this
     }
+    
+    
 
     #[inline(always)]
     fn push_str(&mut self, text: &str) {

```
</events>
<input>
```src/chunk.rs
<|start_of_file|>
use crate::{OffsetUtf16, Point, PointUtf16};
use arrayvec::ArrayString;
use std::{cmp, ops::Range};
use util::debug_panic;

#[derive(Clone, Debug, Default)]
struct Chunk<const CAPACITY: usize> {
    chars: usize,
    chars_utf16: usize,
    tabs: usize,
    newlines: usize,
    text: ArrayString<CAPACITY>,
}

impl<const CAPACITY: usize> Chunk<CAPACITY> {
<|editable_region_start|>
    #[inline(always)]
    fn new(text: &str) -> Self {
        let mut this = Chunk::default();
        this.push_str(text);
        this
    }
    
    <|user_cursor_is_here|>

    #[inline(always)]
    fn push_str(&mut self, text: &str) {
        for (char_ix, c) in text.char_indices() {
            let ix = self.text.len() + char_ix;
            self.chars |= 1 << ix;
            self.chars_utf16 |= 1 << ix;
            self.chars_utf16 |= c.len_utf16() << ix;
            self.tabs |= ((c == '\t') as usize) << ix;
            self.newlines |= ((c == '\n') as usize) << ix;
        }
        self.text.push_str(text);
    }

    #[inline(always)]
    pub fn as_slice(&self) -> ChunkRef {
        ChunkRef {
            chars: self.chars,
            chars_utf16: self.chars_utf16,
            tabs: self.tabs,
            newlines: self.newlines,
            text: &self.text,
        }
    }

    #[inline(always)]
    pub fn slice(&self, range: Range<usize>) -> ChunkRef {
        self.as_slice().slice(range)
    }
}
<|editable_region_end|>

#[derive(Clone, Copy)]
pub struct ChunkRef<'a> {
    chars: usize,
    chars_utf16: usize,
    tabs: usize,
    newlines: usize,
    text: &'a str,
}

impl<'a> ChunkRef<'a> {
    #[inline(always)]
    pub fn slice(self, range: Range<usize>) -> Self {
```
</input>
<output>
```src/chunk.rs
<|start_of_file|>
use crate::{OffsetUtf16, Point, PointUtf16};
use arrayvec::ArrayString;
use std::{cmp, ops::Range};
use util::debug_panic;

#[derive(Clone, Debug, Default)]
struct Chunk<const CAPACITY: usize> {
    chars: usize,
    chars_utf16: usize,
    tabs: usize,
    newlines: usize,
    text: ArrayString<CAPACITY>,
}

impl<const CAPACITY: usize> Chunk<CAPACITY> {
<|editable_region_start|>
    #[inline(always)]
    fn new(text: &str) -> Self {
        let mut this = Chunk::default();
        this.push_str(text);
        this
    }
    
    

    #[inline(always)]
    fn push_str(&mut self, text: &str) {
        for (char_ix, c) in text.char_indices() {
            let ix = self.text.len() + char_ix;
            self.chars |= 1 << ix;
            self.chars_utf16 |= 1 << ix;
            self.chars_utf16 |= c.len_utf16() << ix;
            self.tabs |= ((c == '\t') as usize) << ix;
            self.newlines |= ((c == '\n') as usize) << ix;
        }
        self.text.push_str(text);
    }

    #[inline(always)]
    pub fn as_slice(&self) -> ChunkRef {
        ChunkRef {
            chars: self.chars,
            chars_utf16: self.chars_utf16,
            tabs: self.tabs,
            newlines: self.newlines,
            text: &self.text,
        }
    }

    #[inline(always)]
    pub fn slice(&self, range: Range<usize>) -> ChunkRef {
        self.as_slice().slice(range)
    }
}
<|editable_region_end|>

#[derive(Clone, Copy)]
pub struct ChunkRef<'a> {
    chars: usize,
    chars_utf16: usize,
    tabs: usize,
    newlines: usize,
    text: &'a str,
}

impl<'a> ChunkRef<'a> {
    #[inline(always)]
    pub fn slice(self, range: Range<usize>) -> Self {
```
</output>
<outline>
```src/chunk.rs
struct Chunk
 chars
 chars_utf16
 tabs
 newlines
 text
impl Chunk<CAPACITY>
 fn new
 fn push_str
 pub fn as_slice
 pub fn slice
pub struct ChunkRef
 chars
 chars_utf16
 tabs
 newlines
 text
impl ChunkRef<'a>
 pub fn slice
 pub fn len
 pub fn len_utf16
 pub fn lines
 pub fn first_line_chars
 pub fn last_line_chars
 pub fn last_line_len_utf16
 pub fn longest_row
 fn point_for_offset
 fn offset_for_point
 fn offset_to_offset_utf16
 fn offset_utf16_to_offset
 fn offset_to_point_utf16
 fn point_to_point_utf16
 fn point_utf16_to_offset
fn nth_set_bit
mod tests
 fn init_logger
 fn test_random_chunks
 fn test_nth_set_bit
 fn verify_chunk
```

</outline>

<labels>
no-op,unknown
</labels>
