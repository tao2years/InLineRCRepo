<rating>Negative</rating>
<feedback>This is bad because I just typed this and I want the model to add the trailing curly and indent the async move.</feedback>
<events>
User edited "crates/zeta/src/zeta.rs":
```diff
@@ -302,7 +302,7 @@
 
             let (input_events, input_excerpt, input_outline) = cx
                 .background_executor()
-                .spawn(async move {
+                .spawn({async move {
                     let mut input_events = String::new();
                     for event in events {
                         if !input_events.is_empty() {

```
</events>
<input>
```crates/zeta/src/zeta.rs
            _ => {}
        }
    }

    pub fn request_completion_impl<F, R>(
        &mut self,
        buffer: &Model<Buffer>,
<|editable_region_start|>
        position: language::Anchor,
        cx: &mut ModelContext<Self>,
        perform_predict_edits: F,
    ) -> Task<Result<InlineCompletion>>
    where
        F: FnOnce(Arc<Client>, LlmApiToken, PredictEditsParams) -> R + 'static,
        R: Future<Output = Result<PredictEditsResponse>> + Send + 'static,
    {
        let snapshot = self.report_changes_for_buffer(buffer, cx);
        let point = position.to_point(&snapshot);
        let offset = point.to_offset(&snapshot);
        let excerpt_range = excerpt_range_for_position(point, &snapshot);
        let events = self.events.clone();
        let path = snapshot
            .file()
            .map(|f| f.path().clone())
            .unwrap_or_else(|| Arc::from(Path::new("untitled")));

        let client = self.client.clone();
        let llm_token = self.llm_token.clone();

        cx.spawn(|this, mut cx| async move {
            let request_sent_at = Instant::now();

            let (input_events, input_excerpt, input_outline) = cx
                .background_executor()
                .spawn({<|user_cursor_is_here|>async move {
                    let mut input_events = String::new();
                    for event in events {
                        if !input_events.is_empty() {
                            input_events.push('\n');
                            input_events.push('\n');
                        }
                        input_events.push_str(&event.to_prompt());
                    }

                    let input_excerpt = prompt_for_excerpt(&snapshot, &excerpt_range, offset);
                    let input_outline = prompt_for_outline(&snapshot);

                    (input_events, input_excerpt, input_outline)
                })
                .await;

            log::debug!("Events:\n{}\nExcerpt:\n{}", input_events, input_excerpt);

            let body = PredictEditsParams {
                input_events: input_events.clone(),
                input_excerpt: input_excerpt.clone(),
                outline: input_outline.clone(),
            };

            let response = perform_predict_edits(client, llm_token, body).await?;

            let output_excerpt = response.output_excerpt;
            log::debug!("completion response: {}", output_excerpt);

            let inline_completion = Self::process_completion_response(
                output_excerpt,
                &snapshot,
<|editable_region_end|>
                excerpt_range,
```
</input>
<output>
```crates/zeta/src/zeta.rs
            _ => {}
        }
    }

    pub fn request_completion_impl<F, R>(
        &mut self,
        buffer: &Model<Buffer>,
<|editable_region_start|>
        position: language::Anchor,
        cx: &mut ModelContext<Self>,
        perform_predict_edits: F,
    ) -> Task<Result<InlineCompletion>>
    where
        F: FnOnce(Arc<Client>, LlmApiToken, PredictEditsParams) -> R + 'static,
        R: Future<Output = Result<PredictEditsResponse>> + Send + 'static,
    {
        let snapshot = self.report_changes_for_buffer(buffer, cx);
        let point = position.to_point(&snapshot);
        let offset = point.to_offset(&snapshot);
        let excerpt_range = excerpt_range_for_position(point, &snapshot);
        let events = self.events.clone();
        let path = snapshot
            .file()
            .map(|f| f.path().clone())
            .unwrap_or_else(|| Arc::from(Path::new("untitled")));

        let client = self.client.clone();
        let llm_token = self.llm_token.clone();

        cx.spawn(|this, mut cx| async move {
            let request_sent_at = Instant::now();

            let (input_events, input_excerpt, input_outline) = cx
                .background_executor()
                .spawn({
                    async move {
                        let mut input_events = String::new();
                        for event in events {
                            if !input_events.is_empty() {
                                input_events.push('\n');
                                input_events.push('\n');
                            }
                            input_events.push_str(&event.to_prompt());
                        }

                        let input_excerpt = prompt_for_excerpt(&snapshot, &excerpt_range, offset);
                        let input_outline = prompt_for_outline(&snapshot);

                        (input_events, input_excerpt, input_outline)
                    }
                })
                .await;

            log::debug!("Events:\n{}\nExcerpt:\n{}", input_events, input_excerpt);

            let body = PredictEditsParams {
                input_events: input_events.clone(),
                input_excerpt: input_excerpt.clone(),
                outline: input_outline.clone(),
            };

            let response = perform_predict_edits(client, llm_token, body).await?;

            let output_excerpt = response.output_excerpt;
            log::debug!("completion response: {}", output_excerpt);

            let inline_completion = Self::process_completion_response(
                output_excerpt,
                &snapshot,
<|editable_region_end|>
                excerpt_range,
```
</output>
<outline>
```crates/zeta/src/zeta.rs
mod rate_completion_modal
const CURSOR_MARKER
const START_OF_FILE_MARKER
const EDITABLE_REGION_START_MARKER
const EDITABLE_REGION_END_MARKER
const BUFFER_CHANGE_GROUPING_INTERVAL
pub struct InlineCompletionId
impl From<InlineCompletionId> for gpui::ElementId
 fn from
impl std::fmt::Display for InlineCompletionId
 fn fmt
impl InlineCompletionId
 fn new
struct ZetaGlobal
impl Global for ZetaGlobal
pub struct InlineCompletion
 id
 path
 excerpt_range
 edits
 snapshot
 input_outline
 input_events
 input_excerpt
 output_excerpt
 request_sent_at
 response_received_at
impl InlineCompletion
 fn latency
 fn interpolate
impl std::fmt::Debug for InlineCompletion
 fn fmt
pub struct Zeta
 client
 events
 registered_buffers
 recent_completions
 rated_completions
 shown_completions
 llm_token
 _llm_token_subscription
pub fn global
pub fn register
pub fn clear_history
fn new
fn push_event
 const MAX_EVENT_COUNT
pub fn register_buffer
fn handle_buffer_event
pub fn fill_with_fake_completions
pub fn fake_completion
pub fn request_completion
fn perform_predict_edits
fn process_completion_response
pub fn compute_edits
pub fn is_completion_rated
pub fn was_completion_shown
pub fn completion_shown
pub fn rate_completion
pub fn recent_completions
pub fn recent_completions_len
fn report_changes_for_buffer
fn common_prefix
fn prompt_for_outline
fn prompt_for_excerpt
fn excerpt_range_for_position
 const CONTEXT_LINES
struct RegisteredBuffer
 snapshot
 _subscriptions
enum Event
 BufferChange
  old_snapshot
  new_snapshot
  timestamp
impl Event
 fn to_prompt
struct CurrentInlineCompletion
 buffer_id
 completion
impl CurrentInlineCompletion
 fn should_replace_completion
struct PendingCompletion
 id
 _task
pub struct ZetaInlineCompletionProvider
 zeta
 pending_completions
 next_pending_completion_id
 current_completion
impl ZetaInlineCompletionProvider
 pub const DEBOUNCE_TIMEOUT
 pub fn new
impl inline_completion::InlineCompletionProvider for ZetaInlineCompletionProvider
 fn name
 fn display_name
 fn show_completions_in_menu
 fn show_completions_in_normal_mode
 fn is_enabled
 fn refresh
 fn cycle
 fn accept
 fn discard
 fn suggest
mod tests
 fn test_inline_completion_basic_interpolation
 async fn test_inline_completion_end_of_buffer
 fn to_completion_edits
 fn from_completion_edits
 fn init_logger
```

</outline>

<labels>
local-edit,complete-pattern
</labels>
