<rating>Positive</rating>
<feedback>I extracted a variable for the start of a range. It correctly extracted a variable for the end.</feedback>
<events>
User edited "crates/editor/src/display_map/diff_map.rs":
```diff
@@ -280,13 +280,14 @@
             let buffer = buffer.read(cx);
             let excerpt_start = changed_buffer_range.start.to_offset(buffer);
             let changed_inlay_range = {
-                self.snapshot
+                let start = self.snapshot
                     .inlay_snapshot
-                    .to_inlay_offset(changed_multibuffer_range.start)
+                    .to_inlay_offset(changed_multibuffer_range.start);
+                
                     ..self
                         .snapshot
                         .inlay_snapshot
-                        .to_inlay_offset(changed_multibuffer_range.end)
+                        .to_inlay_offset(changed_multibuffer_range.end);
             };
 
             new_transforms.append(

```
</events>
<input>
```crates/editor/src/display_map/diff_map.rs
        let mut new_transforms = SumTree::default();
        let mut edits = Patch::default();

        for (excerpt_id, buffer_id, changed_multibuffer_range, changed_buffer_range) in
            changed_ranges
        {
            let Some(buffer) = self.multibuffer.read(cx).buffer(buffer_id) else {
<|editable_region_start|>
                continue;
            };
            let change_set_state = self.snapshot.diffs.get(&buffer_id);

            let buffer = buffer.read(cx);
            let excerpt_start = changed_buffer_range.start.to_offset(buffer);
            let changed_inlay_range = {
                let start = self.snapshot
                    .inlay_snapshot
                    .to_inlay_offset(changed_multibuffer_range.start);
                <|user_cursor_is_here|>
                    ..self
                        .snapshot
                        .inlay_snapshot
                        .to_inlay_offset(changed_multibuffer_range.end);
            };

            new_transforms.append(
                cursor.slice(&changed_inlay_range.start, Bias::Left, &()),
                &(),
            );

            if let Some(change_set_state) = change_set_state {
                let diff = &change_set_state.diff;
                let base_text = &change_set_state.base_text;

                for hunk in diff.hunks_intersecting_range(changed_buffer_range.clone(), buffer) {
<|editable_region_end|>
                    let hunk_anchor_range = multi_buffer::Anchor {
```
</input>
<output>
```crates/editor/src/display_map/diff_map.rs
        let mut new_transforms = SumTree::default();
        let mut edits = Patch::default();

        for (excerpt_id, buffer_id, changed_multibuffer_range, changed_buffer_range) in
            changed_ranges
        {
            let Some(buffer) = self.multibuffer.read(cx).buffer(buffer_id) else {
<|editable_region_start|>
                continue;
            };
            let change_set_state = self.snapshot.diffs.get(&buffer_id);

            let buffer = buffer.read(cx);
            let excerpt_start = changed_buffer_range.start.to_offset(buffer);
            let changed_inlay_range = {
                let start = self.snapshot
                    .inlay_snapshot
                    .to_inlay_offset(changed_multibuffer_range.start);
                let end = self.snapshot
                    .inlay_snapshot
                    .to_inlay_offset(changed_multibuffer_range.end);
                start..end
            };

            new_transforms.append(
                cursor.slice(&changed_inlay_range.start, Bias::Left, &()),
                &(),
            );

            if let Some(change_set_state) = change_set_state {
                let diff = &change_set_state.diff;
                let base_text = &change_set_state.base_text;

                for hunk in diff.hunks_intersecting_range(changed_buffer_range.clone(), buffer) {
<|editable_region_end|>
                    let hunk_anchor_range = multi_buffer::Anchor {
```
</output>

<labels>
local-edit,complete-pattern
</labels>
