<rating>Positive</rating>
<feedback></feedback>
<events>
User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1,7 +1,7 @@
-mod completion_element;
+mod rate_completion_element;
 mod rate_completion_modal;
 
-pub(crate) use completion_element::*;
+pub(crate) use rate_completion_element::*;
 pub use rate_completion_modal::*;
 
 use anyhow::{anyhow, Context as _, Result};

```
</events>
<input>
```crates/zeta/src/rate_completion_element.rs
<|start_of_file|>
<|editable_region_start|>
pub struct <|user_cursor_is_here|>CompletionElement {
    
}

impl CompletionElement {
    fn render_active_completion(completion: ) -> Option<impl IntoElement> {
        let active_completion = self.active_completion.as_ref()?;
        let completion_id = active_completion.completion.id;
        let focus_handle = &self.focus_handle(cx);

        let mut diff = active_completion
            .completion
            .snapshot
            .text_for_range(active_completion.completion.excerpt_range.clone())
            .collect::<String>();

        let mut delta = 0;
        let mut diff_highlights = Vec::new();
        for (old_range, new_text) in active_completion.completion.edits.iter() {
            let old_range = old_range.to_offset(&active_completion.completion.snapshot);
            let old_start_in_text =
                old_range.start - active_completion.completion.excerpt_range.start + delta;
            let old_end_in_text =
                old_range.end - active_completion.completion.excerpt_range.start + delta;
            if old_start_in_text < old_end_in_text {
                diff_highlights.push((
                    old_start_in_text..old_end_in_text,
                    HighlightStyle {
                        background_color: Some(cx.theme().status().deleted_background),
                        strikethrough: Some(gpui::StrikethroughStyle {
                            thickness: px(1.),
                            color: Some(cx.theme().colors().text_muted),
                        }),
                        ..Default::default()
                    },
                ));
            }

            if !new_text.is_empty() {
                diff.insert_str(old_end_in_text, new_text);
                diff_highlights.push((
                    old_end_in_text..old_end_in_text + new_text.len(),
                    HighlightStyle {
                        background_color: Some(cx.theme().status().created_background),
                        ..Default::default()
                    },
                ));
                delta += new_text.len();
            }
        }
<|editable_region_end|>

        let settings = ThemeSettings::get_global(cx).clone();
        let text_style = TextStyle {
            color: cx.theme().colors().editor_foreground,
            font_size: settings.buffer_font_size(cx).into(),
            font_family: settings.buffer_font.family,
            font_features: settings.buffer_font.features,
            font_fallbacks: settings.buffer_font.fallbacks,
            line_height: relative(settings.buffer_line_height.value()),
            font_weight: settings.buffer_font.weight,
            font_style: settings.buffer_font.style,
            ..Default::default()
        };
        let border_color = cx.theme().colors().border;
        let bg_color = cx.theme().colors().editor_background;
```
</input>
<output>
```crates/zeta/src/rate_completion_element.rs
<|start_of_file|>
<|editable_region_start|>
pub struct RateCompletionElement {
    
}

impl RateCompletionElement {
    fn render_active_completion(completion: ) -> Option<impl IntoElement> {
        let active_completion = self.active_completion.as_ref()?;
        let completion_id = active_completion.completion.id;
        let focus_handle = &self.focus_handle(cx);

        let mut diff = active_completion
            .completion
            .snapshot
            .text_for_range(active_completion.completion.excerpt_range.clone())
            .collect::<String>();

        let mut delta = 0;
        let mut diff_highlights = Vec::new();
        for (old_range, new_text) in active_completion.completion.edits.iter() {
            let old_range = old_range.to_offset(&active_completion.completion.snapshot);
            let old_start_in_text =
                old_range.start - active_completion.completion.excerpt_range.start + delta;
            let old_end_in_text =
                old_range.end - active_completion.completion.excerpt_range.start + delta;
            if old_start_in_text < old_end_in_text {
                diff_highlights.push((
                    old_start_in_text..old_end_in_text,
                    HighlightStyle {
                        background_color: Some(cx.theme().status().deleted_background),
                        strikethrough: Some(gpui::StrikethroughStyle {
                            thickness: px(1.),
                            color: Some(cx.theme().colors().text_muted),
                        }),
                        ..Default::default()
                    },
                ));
            }

            if !new_text.is_empty() {
                diff.insert_str(old_end_in_text, new_text);
                diff_highlights.push((
                    old_end_in_text..old_end_in_text + new_text.len(),
                    HighlightStyle {
                        background_color: Some(cx.theme().status().created_background),
                        ..Default::default()
                    },
                ));
                delta += new_text.len();
            }
        }
<|editable_region_end|>

        let settings = ThemeSettings::get_global(cx).clone();
        let text_style = TextStyle {
            color: cx.theme().colors().editor_foreground,
            font_size: settings.buffer_font_size(cx).into(),
            font_family: settings.buffer_font.family,
            font_features: settings.buffer_font.features,
            font_fallbacks: settings.buffer_font.fallbacks,
            line_height: relative(settings.buffer_line_height.value()),
            font_weight: settings.buffer_font.weight,
            font_style: settings.buffer_font.style,
            ..Default::default()
        };
        let border_color = cx.theme().colors().border;
        let bg_color = cx.theme().colors().editor_background;
```
</output>
<outline>
```crates/zeta/src/rate_completion_element.rs
pub struct CompletionElement
impl CompletionElement
 fn render_active_completion
```

</outline>

<labels>
local-edit,infer-intent
</labels>
