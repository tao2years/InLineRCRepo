<rating>Negative</rating>
<feedback>Don't delete, suggest an `elif data.get('video'):` here and a newline and indentation</feedback>
<events>
User edited "main.py":
```diff
@@ -102,6 +102,7 @@
                         audio_stream += audio_chunk
                         play(audio_chunk)  # Play each chunk as it's received
                         logging.debug("Played audio chunk")
+                        
                     elif data.get('isFinal'):
                         logging.info("Received final message")
                         break

```

User edited "main.py":
```diff
@@ -102,7 +102,7 @@
                         audio_stream += audio_chunk
                         play(audio_chunk)  # Play each chunk as it's received
                         logging.debug("Played audio chunk")
-                        
+                    
                     elif data.get('isFinal'):
                         logging.info("Received final message")
                         break

```
</events>
<input>
```main.py
    async def chunk_text(text):
        sentences = re.split('(?<=[.,?!;:—\-()[\]{}]) +', text)
        for sentence in sentences:
            yield sentence + " "

    try:
        logging.info("Connecting to ElevenLabs API")
        async with websockets.connect(uri, extra_headers={'xi-api-key': ELEVEN_LABS_API_KEY}) as websocket:
            logging.info("Connected to ElevenLabs API")
            await websocket.send(json.dumps({
                "text": " ",
                "voice_settings": {"stability": 0.5, "similarity_boost": 0.75},
                "xi_api_key": ELEVEN_LABS_API_KEY,
            }))

            audio_stream = AudioSegment.empty()
            async for chunk in chunk_text(text):
                logging.debug(f"Sending chunk: {chunk}")
                await websocket.send(json.dumps({"text": chunk, "try_trigger_generation": True}))

            await websocket.send(json.dumps({"text": ""}))  # Closing message
            logging.info("Sent all text chunks")

            while True:
                try:
                    message = await websocket.recv()
                    data = json.loads(message)
                    if data.get('audio'):
                        audio_data = base64.b64decode(data['audio'])
                        audio_chunk = AudioSegment.from_mp3(io.BytesIO(audio_data))
                        audio_stream += audio_chunk
                        play(audio_chunk)  # Play each chunk as it's received
<|editable_region_start|>
                        logging.debug("Played audio chunk")
                    <|user_cursor_is_here|>
                    elif data.get('isFinal'):
                        logging.info("Received final message")
                        break
                except websockets.exceptions.ConnectionClosed:
                    logging.error("WebSocket connection closed unexpectedly")
                    console.print("WebSocket connection closed unexpectedly", style="bold red")
                    break

    except websockets.exceptions.InvalidStatusCode as e:
        logging.error(f"Failed to connect to ElevenLabs API: {e}")
        console.print(f"Failed to connect to ElevenLabs API: {e}", style="bold red")
        console.print("Fallback: Printing the text instead.", style="bold yellow")
        console.print(text)
    except Exception as e:
        logging.error(f"Error in text-to-speech: {str(e)}")
        console.print(f"Error in text-to-speech: {str(e)}", style="bold red")
        console.print("Fallback: Printing the text instead.", style="bold yellow")
        console.print(text)

def initialize_speech_recognition():
    global recognizer, microphone
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    
    # Adjust for ambient noise
    with microphone as source:
        recognizer.adjust_for_ambient_noise(source, duration=1)
    
    logging.info("Speech recognition initialized")

async def voice_input(max_retries=3):
    global recognizer, microphone
<|editable_region_end|>
```
</input>
<output>
```main.py
    async def chunk_text(text):
        sentences = re.split('(?<=[.,?!;:—\-()[\]{}]) +', text)
        for sentence in sentences:
            yield sentence + " "

    try:
        logging.info("Connecting to ElevenLabs API")
        async with websockets.connect(uri, extra_headers={'xi-api-key': ELEVEN_LABS_API_KEY}) as websocket:
            logging.info("Connected to ElevenLabs API")
            await websocket.send(json.dumps({
                "text": " ",
                "voice_settings": {"stability": 0.5, "similarity_boost": 0.75},
                "xi_api_key": ELEVEN_LABS_API_KEY,
            }))

            audio_stream = AudioSegment.empty()
            async for chunk in chunk_text(text):
                logging.debug(f"Sending chunk: {chunk}")
                await websocket.send(json.dumps({"text": chunk, "try_trigger_generation": True}))

            await websocket.send(json.dumps({"text": ""}))  # Closing message
            logging.info("Sent all text chunks")

            while True:
                try:
                    message = await websocket.recv()
                    data = json.loads(message)
                    if data.get('audio'):
                        audio_data = base64.b64decode(data['audio'])
                        audio_chunk = AudioSegment.from_mp3(io.BytesIO(audio_data))
                        audio_stream += audio_chunk
                        play(audio_chunk)  # Play each chunk as it's received
<|editable_region_start|>
                        logging.debug("Played audio chunk")
                    elif data.get('error'):
                        logging.error(f"ElevenLabs API error: {data['error']}")
                        console.print(f"ElevenLabs API error: {data['error']}", style="bold red")
                    elif data.get('isFinal'):
                        logging.info("Received final message")
                        break
                except websockets.exceptions.ConnectionClosed:
                    logging.error("WebSocket connection closed unexpectedly")
                    console.print("WebSocket connection closed unexpectedly", style="bold red")
                    break

    except websockets.exceptions.InvalidStatusCode as e:
        logging.error(f"Failed to connect to ElevenLabs API: {e}")
        console.print(f"Failed to connect to ElevenLabs API: {e}", style="bold red")
        console.print("Fallback: Printing the text instead.", style="bold yellow")
        console.print(text)
    except Exception as e:
        logging.error(f"Error in text-to-speech: {str(e)}")
        console.print(f"Error in text-to-speech: {str(e)}", style="bold red")
        console.print("Fallback: Printing the text instead.", style="bold yellow")
        console.print(text)

def initialize_speech_recognition():
    global recognizer, microphone
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    
    # Adjust for ambient noise
    with microphone as source:
        recognizer.adjust_for_ambient_noise(source, duration=1)
    
    logging.info("Speech recognition initialized")

async def voice_input(max_retries=3):
    global recognizer, microphone
<|editable_region_end|>
```
</output>
<outline>
```main.py
async def text_to_speech
 async def chunk_text
def initialize_speech_recognition
async def voice_input
def cleanup_speech_recognition
def process_voice_command
async def get_user_input
def setup_virtual_environment
def update_system_prompt
def create_folders
def create_files
async def generate_edit_instructions
def validate_ai_response
def parse_search_replace_blocks
async def edit_and_apply_multiple
async def apply_edits
def highlight_diff
def generate_diff
async def execute_code
def read_multiple_files
def list_files
def tavily_search
def stop_process
def run_shell_command
async def decide_retry
async def execute_tool
def scan_folder
def encode_image_to_base64
async def send_to_ai_for_executing
def save_chat
async def chat_with_claude
def reset_code_editor_memory
def reset_conversation
def display_token_usage
async def test_voice_mode
async def main
def validate_files_structure
```

</outline>

<labels>
local-edit,complete-pattern
</labels>
