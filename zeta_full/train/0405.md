<rating>Positive</rating>
<feedback></feedback>
<events>
User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1054,10 +1054,10 @@
             });
 
             let mut completion = match completion_request {
-                Ok(completion_request) => Some(CurrentInlineCompletion {
+                Ok(completion_request) => {Some(CurrentInlineCompletion {
                     buffer_id: buffer.entity_id(),
                     completion: completion_request.await?,
-                }),
+                })},
                 Err(error) => Err(error),
             };
 

```

User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1054,7 +1054,9 @@
             });
 
             let mut completion = match completion_request {
-                Ok(completion_request) => {Some(CurrentInlineCompletion {
+                Ok(completion_request) => {
+                    let completion_request = completion_request.await?;
+                    Some(CurrentInlineCompletion {
                     buffer_id: buffer.entity_id(),
                     completion: completion_request.await?,
                 })},

```

User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1058,7 +1058,7 @@
                     let completion_request = completion_request.await?;
                     Some(CurrentInlineCompletion {
                     buffer_id: buffer.entity_id(),
-                    completion: completion_request.await?,
+                    completion: completion_request,
                 })},
                 Err(error) => Err(error),
             };

```

User edited "crates/zeta/src/zeta.rs":
```diff
@@ -1055,7 +1055,8 @@
 
             let mut completion = match completion_request {
                 Ok(completion_request) => {
-                    let completion_request = completion_request.await?;
+                    let completion_request = completion_request.await;
+                    completion_request.m
                     Some(CurrentInlineCompletion {
                     buffer_id: buffer.entity_id(),
                     completion: completion_request,

```
</events>
<input>
```crates/zeta/src/zeta.rs
        let language = buffer.language_at(cursor_position);
        let settings = all_language_settings(file, cx);
        settings.inline_completions_enabled(language.as_ref(), file.map(|f| f.path().as_ref()), cx)
    }

    fn is_refreshing(&self) -> bool {
        !self.pending_completions.is_empty()
    }

    fn refresh(
        &mut self,
        buffer: Model<Buffer>,
        position: language::Anchor,
        debounce: bool,
        cx: &mut ModelContext<Self>,
    ) {
        let pending_completion_id = self.next_pending_completion_id;
        self.next_pending_completion_id += 1;

        let task = cx.spawn(|this, mut cx| async move {
            if debounce {
                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;
            }

<|editable_region_start|>
            let completion_request = this.update(&mut cx, |this, cx| {
                this.zeta.update(cx, |zeta, cx| {
                    zeta.request_completion(&buffer, position, cx)
                })
            });

            let mut completion = match completion_request {
                Ok(completion_request) => {
                    let completion_request = completion_request.await;
                    completion_request.m<|user_cursor_is_here|>
                    Some(CurrentInlineCompletion {
                    buffer_id: buffer.entity_id(),
                    completion: completion_request,
                })},
                Err(error) => Err(error),
            };

            this.update(&mut cx, |this, cx| {
                if this.pending_completions[0].id == pending_completion_id {
                    this.pending_completions.remove(0);
                } else {
                    this.pending_completions.clear();
                }

                if let Some(new_completion) = completion {
                    if let Some(old_completion) = this.current_completion.as_ref() {
                        let snapshot = buffer.read(cx).snapshot();
                        if new_completion.should_replace_completion(&old_completion, &snapshot) {
                            this.zeta.update(cx, |zeta, _cx| {
                                zeta.completion_shown(new_completion.completion.id)
                            });
                            this.current_completion = Some(new_completion);
                        }
                    } else {
                        this.zeta.update(cx, |zeta, _cx| {
                            zeta.completion_shown(new_completion.completion.id)
                        });
                        this.current_completion = Some(new_completion);
                    }
                } else {
                    this.current_completion = None;
                }
<|editable_region_end|>
```
</input>
<output>
```crates/zeta/src/zeta.rs
        let language = buffer.language_at(cursor_position);
        let settings = all_language_settings(file, cx);
        settings.inline_completions_enabled(language.as_ref(), file.map(|f| f.path().as_ref()), cx)
    }

    fn is_refreshing(&self) -> bool {
        !self.pending_completions.is_empty()
    }

    fn refresh(
        &mut self,
        buffer: Model<Buffer>,
        position: language::Anchor,
        debounce: bool,
        cx: &mut ModelContext<Self>,
    ) {
        let pending_completion_id = self.next_pending_completion_id;
        self.next_pending_completion_id += 1;

        let task = cx.spawn(|this, mut cx| async move {
            if debounce {
                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;
            }

<|editable_region_start|>
            let completion_request = this.update(&mut cx, |this, cx| {
                this.zeta.update(cx, |zeta, cx| {
                    zeta.request_completion(&buffer, position, cx)
                })
            });

            let mut completion = match completion_request {
                Ok(completion_request) => {
                    let completion_request = completion_request.await;
                    completion_request.map(|completion| {
                        Some(CurrentInlineCompletion {
                            buffer_id: buffer.entity_id(),
                            completion,
                        })
                    })
                },
                Err(error) => Err(error),
            };

            this.update(&mut cx, |this, cx| {
                if this.pending_completions[0].id == pending_completion_id {
                    this.pending_completions.remove(0);
                } else {
                    this.pending_completions.clear();
                }

                if let Some(new_completion) = completion {
                    if let Some(old_completion) = this.current_completion.as_ref() {
                        let snapshot = buffer.read(cx).snapshot();
                        if new_completion.should_replace_completion(&old_completion, &snapshot) {
                            this.zeta.update(cx, |zeta, _cx| {
                                zeta.completion_shown(new_completion.completion.id)
                            });
                            this.current_completion = Some(new_completion);
                        }
                    } else {
                        this.zeta.update(cx, |zeta, _cx| {
                            zeta.completion_shown(new_completion.completion.id)
                        });
                        this.current_completion = Some(new_completion);
                    }
                } else {
                    this.current_completion = None;
                }
<|editable_region_end|>
```
</output>
<outline>
```crates/zeta/src/zeta.rs
mod rate_completion_modal
const CURSOR_MARKER
const START_OF_FILE_MARKER
const EDITABLE_REGION_START_MARKER
const EDITABLE_REGION_END_MARKER
const BUFFER_CHANGE_GROUPING_INTERVAL
pub struct InlineCompletionId
impl From<InlineCompletionId> for gpui::ElementId
 fn from
impl std::fmt::Display for InlineCompletionId
 fn fmt
impl InlineCompletionId
 fn new
struct ZetaGlobal
impl Global for ZetaGlobal
pub struct InlineCompletion
 id
 path
 excerpt_range
 edits
 snapshot
 input_outline
 input_events
 input_excerpt
 output_excerpt
 request_sent_at
 response_received_at
impl InlineCompletion
 fn latency
 fn interpolate
impl std::fmt::Debug for InlineCompletion
 fn fmt
pub struct Zeta
 client
 events
 registered_buffers
 recent_completions
 rated_completions
 shown_completions
 llm_token
 _llm_token_subscription
impl Zeta
 pub fn global
 pub fn register
 pub fn clear_history
 fn new
 fn push_event
  const MAX_EVENT_COUNT
 pub fn register_buffer
 fn handle_buffer_event
 pub fn request_completion_impl
 pub fn fill_with_fake_completions
 pub fn fake_completion
 pub fn request_completion
 fn perform_predict_edits
 fn process_completion_response
 pub fn compute_edits
 pub fn is_completion_rated
 pub fn was_completion_shown
 pub fn completion_shown
 pub fn rate_completion
 pub fn recent_completions
 pub fn recent_completions_len
 fn report_changes_for_buffer
fn common_prefix
fn prompt_for_outline
fn prompt_for_excerpt
fn excerpt_range_for_position
 const CONTEXT_LINES
struct RegisteredBuffer
 snapshot
 _subscriptions
enum Event
 BufferChange
  old_snapshot
  new_snapshot
  timestamp
impl Event
 fn to_prompt
struct CurrentInlineCompletion
 buffer_id
 completion
impl CurrentInlineCompletion
 fn should_replace_completion
struct PendingCompletion
 id
 _task
pub struct ZetaInlineCompletionProvider
 zeta
 pending_completions
 next_pending_completion_id
 current_completion
impl ZetaInlineCompletionProvider
 pub const DEBOUNCE_TIMEOUT
 pub fn new
impl inline_completion::InlineCompletionProvider for ZetaInlineCompletionProvider
 fn name
 fn display_name
 fn show_completions_in_menu
 fn show_completions_in_normal_mode
 fn is_enabled
 fn is_refreshing
 fn refresh
 fn cycle
 fn accept
 fn discard
 fn suggest
mod tests
 fn test_inline_completion_basic_interpolation
 async fn test_inline_completion_end_of_buffer
 fn to_completion_edits
 fn from_completion_edits
 fn init_logger
```

</outline>

<labels>
local-edit,complete-pattern
</labels>
