<rating>Positive</rating>
<feedback></feedback>
<events>
User edited ".config/hammerspoon/config/uielements.lua":
```diff
@@ -265,7 +265,7 @@
     prints(InspectHtml(value))
 end
 
-local function 
+local function ensureClearedWeb
 
 hs.hotkey.bind({ "cmd", "alt", "ctrl" }, "S", function()
     -- [S]earch menu items

```
</events>
<input>
```.config/hammerspoon/config/uielements.lua
            local axDesc = WrapInQuotesIfNeeded(userdata["AXDescription"])
            -- FYI in this case, do not show hs.axuielement b/c AX* indicates that already so save the space
<|editable_region_start|>
            return string.format("%s %s %s %s", referenceName, axType, axTitle, axDesc)
        elseif userdataType == "hs.application" then
            local appName = userdata:name()
            local appBundleID = userdata:bundleID()
            -- in this case, app name alone isn't enough of hint so show the type 'hs.application'
            return string.format("hs.application(%s) - %s %s", referenceName, appName, appBundleID)
        end

        -- TODO handle other hammerspoon userdata types
        return referenceName .. hs.inspect(userdata) .. " - TODO add this hs type to inspectHTML"
    end

    if value == nil then
        return "nil"
    elseif type(value) == "table" then
        return _inspectTable(value)
    elseif type(value) == "string" then
        return value
    elseif type(value) == "number" or type(value) == "boolean" then
        return tostring(value)
    elseif type(value) == "userdata" then
        return _inspectUserData(value)
    else
        return hs.inspect(value)
    end
end

function DumpHtml(value)
    prints(InspectHtml(value))
end

local function ensureClearedWeb<|user_cursor_is_here|>

hs.hotkey.bind({ "cmd", "alt", "ctrl" }, "S", function()
    -- [S]earch menu items
    if printWebView then
        printHtmlBuffer = {}
    end
    ensureWebview()

    local app = hs.application.frontmostApplication()
    print("starting potentially slow element search of: " .. app:name())

    local menuItems = app:findMenuItem("Activity Monitor", true)
    DumpHtml(menuItems)

    -- BUT IMO is easier just to use elementSearch (which I bet is used under the hood here too on findMenuItem.. as does I bet getMenuItems use elementSearch, IIGC)
    -- DumpHtml(menuItems)

    -- PRN anything worth doing to enumerate the menus?
    -- for _, item in ipairs(menuItems) do
    --     -- local title = GetValueOrEmptyString(item)
    --     prints(hs.inspect(item), "<br>")
    -- end
end)


hs.hotkey.bind({ "cmd", "alt", "ctrl" }, "M", function()
    -- USEFUL to quick check for a menu item
    -- TODO try axuielement.elementSearch and see how it compares vs this... (should have more attribute info avail)
    --   - IIAC it might find more menus (i.e. context  menus?)
    -- TODO for each menu item => generate AppleScript or hammerspoon lua code to invoke this menu item?
    -- FYI could use this to replace app - Paletro
    if printWebView then
<|editable_region_end|>
        printHtmlBuffer = {}
```
</input>
<output>
```.config/hammerspoon/config/uielements.lua
            local axDesc = WrapInQuotesIfNeeded(userdata["AXDescription"])
            -- FYI in this case, do not show hs.axuielement b/c AX* indicates that already so save the space
<|editable_region_start|>
            return string.format("%s %s %s %s", referenceName, axType, axTitle, axDesc)
        elseif userdataType == "hs.application" then
            local appName = userdata:name()
            local appBundleID = userdata:bundleID()
            -- in this case, app name alone isn't enough of hint so show the type 'hs.application'
            return string.format("hs.application(%s) - %s %s", referenceName, appName, appBundleID)
        end

        -- TODO handle other hammerspoon userdata types
        return referenceName .. hs.inspect(userdata) .. " - TODO add this hs type to inspectHTML"
    end

    if value == nil then
        return "nil"
    elseif type(value) == "table" then
        return _inspectTable(value)
    elseif type(value) == "string" then
        return value
    elseif type(value) == "number" or type(value) == "boolean" then
        return tostring(value)
    elseif type(value) == "userdata" then
        return _inspectUserData(value)
    else
        return hs.inspect(value)
    end
end

function DumpHtml(value)
    prints(InspectHtml(value))
end

local function ensureClearedWebView()
    if printWebView then
        printHtmlBuffer = {}
    end
    ensureWebview()
end

hs.hotkey.bind({ "cmd", "alt", "ctrl" }, "S", function()
    -- [S]earch menu items
    ensureClearedWebView()

    local app = hs.application.frontmostApplication()
    print("starting potentially slow element search of: " .. app:name())

    local menuItems = app:findMenuItem("Activity Monitor", true)
    DumpHtml(menuItems)

    -- BUT IMO is easier just to use elementSearch (which I bet is used under the hood here too on findMenuItem.. as does I bet getMenuItems use elementSearch, IIGC)
    -- DumpHtml(menuItems)

    -- PRN anything worth doing to enumerate the menus?
    -- for _, item in ipairs(menuItems) do
    --     -- local title = GetValueOrEmptyString(item)
    --     prints(hs.inspect(item), "<br>")
    -- end
end)


hs.hotkey.bind({ "cmd", "alt", "ctrl" }, "M", function()
    -- USEFUL to quick check for a menu item
    -- TODO try axuielement.elementSearch and see how it compares vs this... (should have more attribute info avail)
    --   - IIAC it might find more menus (i.e. context  menus?)
    -- TODO for each menu item => generate AppleScript or hammerspoon lua code to invoke this menu item?
    -- FYI could use this to replace app - Paletro
    if printWebView then
<|editable_region_end|>
        printHtmlBuffer = {}
```
</output>
<outline>
```.config/hammerspoon/config/uielements.lua
function readEntireFile
function prints
function applescriptIdentifierFor
function ensureWebview
function InspectHtml
 function _inspectTable
 function _inspectUserData
function DumpHtml
function GetDumpPath
function DumpAXPath
```

</outline>

<labels>
non-local-edit,complete-pattern
</labels>
