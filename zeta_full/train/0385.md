<rating>Positive</rating>
<feedback></feedback>
<events>
User edited "crates/zeta/src/zeta.rs":
```diff
@@ -328,7 +328,7 @@
             let body = PredictEditsParams {
                 input_events: input_events.clone(),
                 input_excerpt: input_excerpt.clone(),
-                outline: input_outline.clone(),
+                outline: Some(input_outline.clone(),
             };
 
             let response = perform_predict_edits(client, llm_token, body).await?;

```
</events>
<input>
```crates/zeta/src/zeta.rs
        let llm_token = self.llm_token.clone();

<|editable_region_start|>
        cx.spawn(|this, mut cx| async move {
            let request_sent_at = Instant::now();

            let (input_events, input_excerpt, input_outline) = cx
                .background_executor()
                .spawn({
                    let snapshot = snapshot.clone();
                    let excerpt_range = excerpt_range.clone();
                    async move {
                        let mut input_events = String::new();
                        for event in events {
                            if !input_events.is_empty() {
                                input_events.push('\n');
                                input_events.push('\n');
                            }
                            input_events.push_str(&event.to_prompt());
                        }

                        let input_excerpt = prompt_for_excerpt(&snapshot, &excerpt_range, offset);
                        let input_outline = prompt_for_outline(&snapshot);

                        (input_events, input_excerpt, input_outline)
                    }
                })
                .await;

            log::debug!("Events:\n{}\nExcerpt:\n{}", input_events, input_excerpt);

            let body = PredictEditsParams {
                input_events: input_events.clone(),
                input_excerpt: input_excerpt.clone(),
                outline: Some(<|user_cursor_is_here|>input_outline.clone(),
            };

            let response = perform_predict_edits(client, llm_token, body).await?;

            let output_excerpt = response.output_excerpt;
            log::debug!("completion response: {}", output_excerpt);

            let inline_completion = Self::process_completion_response(
                output_excerpt,
                &snapshot,
                excerpt_range,
                path,
                input_outline,
                input_events,
                input_excerpt,
                request_sent_at,
                &cx,
            )
            .await?;

            this.update(&mut cx, |this, cx| {
                this.recent_completions
                    .push_front(inline_completion.clone());
                if this.recent_completions.len() > 50 {
                    let completion = this.recent_completions.pop_back().unwrap();
                    this.shown_completions.remove(&completion.id);
                    this.rated_completions.remove(&completion.id);
                }
<|editable_region_end|>
                cx.notify();
            })?;

            Ok(inline_completion)
        })
```
</input>
<output>
```crates/zeta/src/zeta.rs
        let llm_token = self.llm_token.clone();

<|editable_region_start|>
        cx.spawn(|this, mut cx| async move {
            let request_sent_at = Instant::now();

            let (input_events, input_excerpt, input_outline) = cx
                .background_executor()
                .spawn({
                    let snapshot = snapshot.clone();
                    let excerpt_range = excerpt_range.clone();
                    async move {
                        let mut input_events = String::new();
                        for event in events {
                            if !input_events.is_empty() {
                                input_events.push('\n');
                                input_events.push('\n');
                            }
                            input_events.push_str(&event.to_prompt());
                        }

                        let input_excerpt = prompt_for_excerpt(&snapshot, &excerpt_range, offset);
                        let input_outline = prompt_for_outline(&snapshot);

                        (input_events, input_excerpt, input_outline)
                    }
                })
                .await;

            log::debug!("Events:\n{}\nExcerpt:\n{}", input_events, input_excerpt);

            let body = PredictEditsParams {
                input_events: input_events.clone(),
                input_excerpt: input_excerpt.clone(),
                outline: Some(input_outline.clone()),
            };

            let response = perform_predict_edits(client, llm_token, body).await?;

            let output_excerpt = response.output_excerpt;
            log::debug!("completion response: {}", output_excerpt);

            let inline_completion = Self::process_completion_response(
                output_excerpt,
                &snapshot,
                excerpt_range,
                path,
                input_outline,
                input_events,
                input_excerpt,
                request_sent_at,
                &cx,
            )
            .await?;

            this.update(&mut cx, |this, cx| {
                this.recent_completions
                    .push_front(inline_completion.clone());
                if this.recent_completions.len() > 50 {
                    let completion = this.recent_completions.pop_back().unwrap();
                    this.shown_completions.remove(&completion.id);
                    this.rated_completions.remove(&completion.id);
                }
<|editable_region_end|>
                cx.notify();
            })?;

            Ok(inline_completion)
        })
```
</output>
<outline>
```crates/zeta/src/zeta.rs
mod rate_completion_modal
const CURSOR_MARKER
const START_OF_FILE_MARKER
const EDITABLE_REGION_START_MARKER
const EDITABLE_REGION_END_MARKER
const BUFFER_CHANGE_GROUPING_INTERVAL
pub struct InlineCompletionId
impl From<InlineCompletionId> for gpui::ElementId
 fn from
impl std::fmt::Display for InlineCompletionId
 fn fmt
impl InlineCompletionId
 fn new
struct ZetaGlobal
impl Global for ZetaGlobal
pub struct InlineCompletion
 id
 path
 excerpt_range
 edits
 snapshot
 input_outline
 input_events
 input_excerpt
 output_excerpt
 request_sent_at
 response_received_at
impl InlineCompletion
 fn latency
 fn interpolate
impl std::fmt::Debug for InlineCompletion
 fn fmt
pub struct Zeta
 client
 events
 registered_buffers
 recent_completions
 rated_completions
 shown_completions
 llm_token
 _llm_token_subscription
impl Zeta
 pub fn global
 pub fn register
 pub fn clear_history
 fn new
 fn push_event
  const MAX_EVENT_COUNT
 pub fn register_buffer
 fn handle_buffer_event
 pub fn request_completion_impl
 pub fn fill_with_fake_completions
 pub fn fake_completion
 pub fn request_completion
 fn perform_predict_edits
 fn process_completion_response
 pub fn compute_edits
 pub fn is_completion_rated
 pub fn was_completion_shown
 pub fn completion_shown
 pub fn rate_completion
 pub fn recent_completions
 pub fn recent_completions_len
 fn report_changes_for_buffer
fn common_prefix
fn prompt_for_outline
fn prompt_for_excerpt
fn excerpt_range_for_position
 const CONTEXT_LINES
struct RegisteredBuffer
 snapshot
 _subscriptions
enum Event
 BufferChange
  old_snapshot
  new_snapshot
  timestamp
impl Event
 fn to_prompt
struct CurrentInlineCompletion
 buffer_id
 completion
impl CurrentInlineCompletion
 fn should_replace_completion
struct PendingCompletion
 id
 _task
pub struct ZetaInlineCompletionProvider
 zeta
 pending_completions
 next_pending_completion_id
 current_completion
impl ZetaInlineCompletionProvider
 pub const DEBOUNCE_TIMEOUT
 pub fn new
impl inline_completion::InlineCompletionProvider for ZetaInlineCompletionProvider
 fn name
 fn display_name
 fn show_completions_in_menu
 fn show_completions_in_normal_mode
 fn is_enabled
 fn refresh
 fn cycle
 fn accept
 fn discard
 fn suggest
mod tests
 fn test_inline_completion_basic_interpolation
 async fn test_inline_completion_end_of_buffer
 fn to_completion_edits
 fn from_completion_edits
 fn init_logger
```

</outline>

<labels>
local-edit,infer-intent
</labels>
