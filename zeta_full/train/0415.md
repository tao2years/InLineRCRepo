<rating>Positive</rating>
<feedback></feedback>
<events>

User edited "crates/language_tools/src/syntax_tree_view.rs":
```diff
@@ -139,7 +139,7 @@
                 .range_to_buffer_ranges(selection_range)
                 .pop()?;
             let buffer = multi_buffer.buffer(buffer.remote_id()).unwrap().clone();
-            Some((excerpt, buffer, range))
+            Some((buffer, range, excerpt_id))
         })?;
 
         // If the cursor has moved into a different excerpt, retrieve a new syntax layer

```

User edited "crates/assistant2/src/inline_assistant.rs":
```diff
@@ -885,7 +885,7 @@
                     let ranges = snapshot.range_to_buffer_ranges(assist.range.clone());
                     ranges
                         .first()
-                        .and_then(|(excerpt, _)| excerpt.buffer().language())
+                        .and_then(|(buffer, _)| excerpt.buffer().language())
                         .map(|language| language.name())
                 });
                 report_assistant_event(

```

User edited "crates/assistant2/src/inline_assistant.rs":
```diff
@@ -885,7 +885,7 @@
                     let ranges = snapshot.range_to_buffer_ranges(assist.range.clone());
                     ranges
                         .first()
-                        .and_then(|(buffer, _)| excerpt.buffer().language())
+                        .and_then(|(buffer, _,)| excerpt.buffer().language())
                         .map(|language| language.name())
                 });
                 report_assistant_event(

```
</events>
<input>
```crates/assistant2/src/inline_assistant.rs
        if let Some(assist) = self.assists.remove(&assist_id) {
            if let hash_map::Entry::Occupied(mut entry) = self.assist_groups.entry(assist.group_id)
            {
                entry.get_mut().assist_ids.retain(|id| *id != assist_id);
                if entry.get().assist_ids.is_empty() {
                    entry.remove();
                }
            }

            if let hash_map::Entry::Occupied(mut entry) =
                self.assists_by_editor.entry(assist.editor.clone())
            {
                entry.get_mut().assist_ids.retain(|id| *id != assist_id);
                if entry.get().assist_ids.is_empty() {
                    entry.remove();
                    if let Some(editor) = assist.editor.upgrade() {
                        self.update_editor_highlights(&editor, cx);
                    }
                } else {
                    entry.get().highlight_updates.send(()).ok();
                }
            }

            let active_alternative = assist.codegen.read(cx).active_alternative().clone();
            let message_id = active_alternative.read(cx).message_id.clone();
<|editable_region_start|>

            if let Some(model) = LanguageModelRegistry::read_global(cx).active_model() {
                let language_name = assist.editor.upgrade().and_then(|editor| {
                    let multibuffer = editor.read(cx).buffer().read(cx);
                    let snapshot = multibuffer.snapshot(cx);
                    let ranges = snapshot.range_to_buffer_ranges(assist.range.clone());
                    ranges
                        .first()
                        .and_then(|(buffer, _,<|user_cursor_is_here|>)| excerpt.buffer().language())
                        .map(|language| language.name())
                });
                report_assistant_event(
                    AssistantEvent {
                        conversation_id: None,
                        kind: AssistantKind::Inline,
                        message_id,
                        phase: if undo {
                            AssistantPhase::Rejected
                        } else {
                            AssistantPhase::Accepted
                        },
                        model: model.telemetry_id(),
<|editable_region_end|>
                        model_provider: model.provider_id().to_string(),
                        response_latency: None,
                        error_message: None,
                        language_name: language_name.map(|name| name.to_proto()),
                    },
                    Some(self.telemetry.clone()),
                    cx.http_client(),
                    model.api_key(cx),
                    cx.background_executor(),
                );
            }

            if undo {
                assist.codegen.update(cx, |codegen, cx| codegen.undo(cx));
            } else {
                self.confirmed_assists.insert(assist_id, active_alternative);
            }
        }
    }
```
</input>
<output>
```crates/assistant2/src/inline_assistant.rs
        if let Some(assist) = self.assists.remove(&assist_id) {
            if let hash_map::Entry::Occupied(mut entry) = self.assist_groups.entry(assist.group_id)
            {
                entry.get_mut().assist_ids.retain(|id| *id != assist_id);
                if entry.get().assist_ids.is_empty() {
                    entry.remove();
                }
            }

            if let hash_map::Entry::Occupied(mut entry) =
                self.assists_by_editor.entry(assist.editor.clone())
            {
                entry.get_mut().assist_ids.retain(|id| *id != assist_id);
                if entry.get().assist_ids.is_empty() {
                    entry.remove();
                    if let Some(editor) = assist.editor.upgrade() {
                        self.update_editor_highlights(&editor, cx);
                    }
                } else {
                    entry.get().highlight_updates.send(()).ok();
                }
            }

            let active_alternative = assist.codegen.read(cx).active_alternative().clone();
            let message_id = active_alternative.read(cx).message_id.clone();
<|editable_region_start|>

            if let Some(model) = LanguageModelRegistry::read_global(cx).active_model() {
                let language_name = assist.editor.upgrade().and_then(|editor| {
                    let multibuffer = editor.read(cx).buffer().read(cx);
                    let snapshot = multibuffer.snapshot(cx);
                    let ranges = snapshot.range_to_buffer_ranges(assist.range.clone());
                    ranges
                        .first()
                        .and_then(|(buffer, _, excerpt_id)| buffer.language())
                        .map(|language| language.name())
                });
                report_assistant_event(
                    AssistantEvent {
                        conversation_id: None,
                        kind: AssistantKind::Inline,
                        message_id,
                        phase: if undo {
                            AssistantPhase::Rejected
                        } else {
                            AssistantPhase::Accepted
                        },
                        model: model.telemetry_id(),
<|editable_region_end|>
                        model_provider: model.provider_id().to_string(),
                        response_latency: None,
                        error_message: None,
                        language_name: language_name.map(|name| name.to_proto()),
                    },
                    Some(self.telemetry.clone()),
                    cx.http_client(),
                    model.api_key(cx),
                    cx.background_executor(),
                );
            }

            if undo {
                assist.codegen.update(cx, |codegen, cx| codegen.undo(cx));
            } else {
                self.confirmed_assists.insert(assist_id, active_alternative);
            }
        }
    }
```
</output>
<outline>
```crates/assistant2/src/inline_assistant.rs
pub fn init
const PROMPT_HISTORY_MAX_LEN
enum InlineAssistTarget
 Editor
 Terminal
pub struct InlineAssistant
 next_assist_id
 next_assist_group_id
 assists
 assists_by_editor
 assist_groups
 confirmed_assists
 prompt_history
 prompt_builder
 telemetry
 fs
impl Global for InlineAssistant
impl InlineAssistant
 pub fn new
 pub fn register_workspace
 fn handle_workspace_event
 fn register_workspace_item
 pub fn inline_assist
 pub fn assist
 pub fn suggest_assist
 fn insert_assist_blocks
 fn handle_prompt_editor_focus_in
 fn handle_prompt_editor_focus_out
 fn handle_prompt_editor_event
 fn handle_editor_newline
 fn handle_editor_cancel
 fn handle_editor_release
 fn handle_editor_change
 fn handle_editor_event
 pub fn finish_assist
 fn dismiss_assist
 fn focus_next_assist
 fn focus_assist
 pub fn scroll_to_assist
 fn unlink_assist_group
 pub fn start_assist
 pub fn stop_assist
 fn update_editor_highlights
  enum GutterPendingRange
  enum GutterTransformedRange
 fn update_editor_blocks
  enum DeletedLines
 fn resolve_inline_assist_target
struct EditorInlineAssists
 assist_ids
 scroll_lock
 highlight_updates
 _update_highlights
 _subscriptions
struct InlineAssistScrollLock
 assist_id
 distance_from_top
impl EditorInlineAssists
 fn new
struct InlineAssistGroup
 assist_ids
 linked
 active_assist_id
impl InlineAssistGroup
 fn new
fn build_assist_editor_renderer
struct InlineAssistGroupId
impl InlineAssistGroupId
 fn post_inc
pub struct InlineAssist
 group_id
 range
 editor
 decorations
 codegen
 _subscriptions
 workspace
impl InlineAssist
 fn new
  struct InlineAssistantError
 fn user_prompt
struct InlineAssistDecorations
 prompt_block_id
 prompt_editor
 removed_line_block_ids
 end_block_id
struct AssistantCodeActionProvider
 editor
 workspace
 thread_store
impl CodeActionProvider for AssistantCodeActionProvider
 fn code_actions
 fn apply_code_action
fn merge_ranges
```

</outline>

<labels>
local-edit,infer-intent
</labels>
