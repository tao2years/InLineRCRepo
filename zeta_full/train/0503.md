<rating>Negative</rating>
<feedback>Make this an eval. Either don't do anything, or suggest a new function. Definitely do not delete stuff around it.</feedback>
<events>
User edited "lib/src/reusable_node.h":
```diff
@@ -20,6 +20,8 @@
   self->last_external_token = NULL_SUBTREE;
 }
 
+
+
 static inline Subtree reusable_node_tree(ReusableNode *self) {
   return self->stack.size > 0
     ? self->stack.contents[self->stack.size - 1].tree

```

User edited "lib/src/unicode.h":
```diff
@@ -33,6 +33,8 @@
   return i;
 }
 
+
+
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,
   uint32_t length,

```

User edited "lib/src/unicode.h":
```diff
@@ -33,7 +33,7 @@
   return i;
 }
 
-
+st
 
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,

```

User edited "lib/src/unicode.h":
```diff
@@ -33,7 +33,7 @@
   return i;
 }
 
-st
+static 
 
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,

```

User edited "lib/src/unicode.h":
```diff
@@ -33,7 +33,7 @@
   return i;
 }
 
-static 
+static inline uint
 
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,

```

User edited "lib/src/unicode.h":
```diff
@@ -33,7 +33,7 @@
   return i;
 }
 
-static inline uint
+static inline uint32_t ts_
 
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,

```

User edited "lib/src/unicode.h":
```diff
@@ -33,7 +33,7 @@
   return i;
 }
 
-static inline uint32_t ts_
+static inline uint32_t ts_encode
 
 static inline uint32_t ts_decode_utf16(
   const uint8_t *string,

```

User edited "lib/src/lexer.c":
```diff
@@ -52,6 +52,8 @@
   self->chunk_start = 0;
 }
 
+
+
 // Call the lexer's input callback to obtain a new chunk of source code
 // for the current position.
 static void ts_lexer__get_chunk(Lexer *self) {

```

User edited "lib/src/lexer.c":
```diff
@@ -52,7 +52,7 @@
   self->chunk_start = 0;
 }
 
-
+static 
 
 // Call the lexer's input callback to obtain a new chunk of source code
 // for the current position.

```

User edited "lib/src/lexer.c":
```diff
@@ -52,7 +52,7 @@
   self->chunk_start = 0;
 }
 
-static 
+static void 
 
 // Call the lexer's input callback to obtain a new chunk of source code
 // for the current position.

```
</events>
<input>
```lib/src/lexer.c
  }

static const int32_t BYTE_ORDER_MARK = 0xFEFF;

static const TSRange DEFAULT_RANGE = {
  .start_point = {
    .row = 0,
    .column = 0,
  },
  .end_point = {
    .row = UINT32_MAX,
    .column = UINT32_MAX,
  },
  .start_byte = 0,
  .end_byte = UINT32_MAX
};

// Check if the lexer has reached EOF. This state is stored
// by setting the lexer's `current_included_range_index` such that
// it has consumed all of its available ranges.
static bool ts_lexer__eof(const TSLexer *_self) {
  Lexer *self = (Lexer *)_self;
  return self->current_included_range_index == self->included_range_count;
}

<|editable_region_start|>
// Clear the currently stored chunk of source code, because the lexer's
// position has changed.
static void ts_lexer__clear_chunk(Lexer *self) {
  self->chunk = NULL;
  self->chunk_size = 0;
  self->chunk_start = 0;
}

static void <|user_cursor_is_here|>

// Call the lexer's input callback to obtain a new chunk of source code
// for the current position.
static void ts_lexer__get_chunk(Lexer *self) {
  self->chunk_start = self->current_position.bytes;
  self->chunk = self->input.read(
    self->input.payload,
    self->current_position.bytes,
    self->current_position.extent,
    &self->chunk_size
  );
  if (!self->chunk_size) {
    self->current_included_range_index = self->included_range_count;
    self->chunk = NULL;
  }
}

// Decode the next unicode character in the current chunk of source code.
// This assumes that the lexer has already retrieved a chunk of source
// code that spans the current position.
static void ts_lexer__get_lookahead(Lexer *self) {
  uint32_t position_in_chunk = self->current_position.bytes - self->chunk_start;
  uint32_t size = self->chunk_size - position_in_chunk;

  if (size == 0) {
    self->lookahead_size = 1;
    self->data.lookahead = '\0';
    return;
  }

  const uint8_t *chunk = (const uint8_t *)self->chunk + position_in_chunk;
  UnicodeDecodeFunction decode = self->input.encoding == TSInputEncodingUTF8
<|editable_region_end|>
    ? ts_decode_utf8
```
</input>
<output>
```lib/src/lexer.c
  }

static const int32_t BYTE_ORDER_MARK = 0xFEFF;

static const TSRange DEFAULT_RANGE = {
  .start_point = {
    .row = 0,
    .column = 0,
  },
  .end_point = {
    .row = UINT32_MAX,
    .column = UINT32_MAX,
  },
  .start_byte = 0,
  .end_byte = UINT32_MAX
};

// Check if the lexer has reached EOF. This state is stored
// by setting the lexer's `current_included_range_index` such that
// it has consumed all of its available ranges.
static bool ts_lexer__eof(const TSLexer *_self) {
  Lexer *self = (Lexer *)_self;
  return self->current_included_range_index == self->included_range_count;
}

<|editable_region_start|>
// Clear the currently stored chunk of source code, because the lexer's
// position has changed.
static void ts_lexer__clear_chunk(Lexer *self) {
  self->chunk = NULL;
  self->chunk_size = 0;
  self->chunk_start = 0;
}

static void ts_lexer__reset_lookahead(Lexer *self) {
  self->lookahead_size = 0;
  self->data.lookahead = 0;
}

// Call the lexer's input callback to obtain a new chunk of source code
// for the current position.
static void ts_lexer__get_chunk(Lexer *self) {
  self->chunk_start = self->current_position.bytes;
  self->chunk = self->input.read(
    self->input.payload,
    self->current_position.bytes,
    self->current_position.extent,
    &self->chunk_size
  );
  if (!self->chunk_size) {
    self->current_included_range_index = self->included_range_count;
    self->chunk = NULL;
  }
}

// Decode the next unicode character in the current chunk of source code.
// This assumes that the lexer has already retrieved a chunk of source
// code that spans the current position.
static void ts_lexer__get_lookahead(Lexer *self) {
  uint32_t position_in_chunk = self->current_position.bytes - self->chunk_start;
  uint32_t size = self->chunk_size - position_in_chunk;

  if (size == 0) {
    self->lookahead_size = 1;
    self->data.lookahead = '\0';
    return;
  }

  const uint8_t *chunk = (const uint8_t *)self->chunk + position_in_chunk;
  UnicodeDecodeFunction decode = self->input.encoding == TSInputEncodingUTF8
<|editable_region_end|>
    ? ts_decode_utf8
```
</output>
<outline>
```lib/src/lexer.c
#define LOG( )
bool ts_lexer__eof( )
void ts_lexer__clear_chunk( )
void ts_lexer__get_chunk( )
void ts_lexer__get_lookahead( )
void ts_lexer_goto( )
void ts_lexer__do_advance( )
void ts_lexer__advance( )
void ts_lexer__mark_end( )
uint32_t ts_lexer__get_column( )
bool ts_lexer__is_at_included_range_start( )
void ts_lexer_init( )
void ts_lexer_delete( )
void ts_lexer_set_input( )
void ts_lexer_reset( )
void ts_lexer_start( )
void ts_lexer_finish( )
void ts_lexer_advance_to_end( )
void ts_lexer_mark_end( )
bool ts_lexer_set_included_ranges( )
TSRange *ts_lexer_included_ranges( )
```

</outline>

<labels>
local-edit,complete-implementation
</labels>
