<rating>Negative</rating>
<feedback>In general Zeta seems really bad at predicting comments. It seems to always want to remove them, or just complete the current word.

It seems reasonable here to expect it to know I want to type `// todo!(): Implement depth calculation` or similar.</feedback>
<events>
User edited "crates/git_ui/src/git_panel.rs":
```diff
@@ -250,6 +250,7 @@
                         .to_string_lossy()
                         .into_owned(),
                     path: entry.path.clone(),
+                    
                     depth: 0,
                 };
                 callback(entry.id, details, cx);

```

User edited "crates/git_ui/src/git_panel.rs":
```diff
@@ -250,7 +250,7 @@
                         .to_string_lossy()
                         .into_owned(),
                     path: entry.path.clone(),
-                    
+                    // todo
                     depth: 0,
                 };
                 callback(entry.id, details, cx);

```

User edited "crates/git_ui/src/git_panel.rs":
```diff
@@ -250,7 +250,7 @@
                         .to_string_lossy()
                         .into_owned(),
                     path: entry.path.clone(),
-                    // todo
+                    // todo!
                     depth: 0,
                 };
                 callback(entry.id, details, cx);

```
</events>
<input>
```crates/git_ui/src/git_panel.rs
            if ix + visible_worktree_entries.len() <= range.start {
                ix += visible_worktree_entries.len();
                continue;
            }

            let end_ix = range.end.min(ix + visible_worktree_entries.len());
            let entry_range = range.start.saturating_sub(ix)..end_ix - ix;
            for entry in visible_worktree_entries[entry_range].iter() {
                let details = EntryDetails {
                    filename: entry
                        .path
                        .file_name()
<|editable_region_start|>
                        .unwrap_or_default()
                        .to_string_lossy()
                        .into_owned(),
                    path: entry.path.clone(),
                    // todo!<|user_cursor_is_here|>
                    depth: 0,
                };
                callback(entry.id, details, cx);
            }
            ix = end_ix;
        }
    }
<|editable_region_end|>
}

impl GitPanel {
    pub fn panel_button(
        &self,
        id: impl Into<SharedString>,
        label: impl Into<SharedString>,
    ) -> Button {
        let id = id.into().clone();
        let label = label.into().clone();
```
</input>
<output>
```crates/git_ui/src/git_panel.rs
            if ix + visible_worktree_entries.len() <= range.start {
                ix += visible_worktree_entries.len();
                continue;
            }

            let end_ix = range.end.min(ix + visible_worktree_entries.len());
            let entry_range = range.start.saturating_sub(ix)..end_ix - ix;
            for entry in visible_worktree_entries[entry_range].iter() {
                let details = EntryDetails {
                    filename: entry
                        .path
                        .file_name()
<|editable_region_start|>
                        .unwrap_or_default()
                        .to_string_lossy()
                        .into_owned(),
                    path: entry.path.clone(),
                    // todo!("Implement depth calculation")
                    depth: 0,
                };
                callback(entry.id, details, cx);
            }
            ix = end_ix;
        }
    }
<|editable_region_end|>
}

impl GitPanel {
    pub fn panel_button(
        &self,
        id: impl Into<SharedString>,
        label: impl Into<SharedString>,
    ) -> Button {
        let id = id.into().clone();
        let label = label.into().clone();
```
</output>

<labels>
local-edit,complete-pattern
</labels>
