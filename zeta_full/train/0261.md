<rating>Positive</rating>
<feedback></feedback>
<events>
User edited "crates/editor/src/editor.rs":
```diff
@@ -6150,7 +6150,7 @@
         let buffer = &display_map.buffer_snapshot;
         let selections = self.selections.all::<Point>(cx);
 
-        if !whole_lines && selections[0].start != selections[0].end {}
+        if !whole_lines && selections.len() == 1 selections[0].start != selections[0].end {}
 
         let mut edits = Vec::new();
         let mut selections_iter = selections.iter().peekable();

```
</events>
<input>
```crates/editor/src/editor.rs
            let text = buffer.text_for_range(start..end).collect::<String>();
            edits.push((selection.end..selection.end, text));
        }

        self.transact(cx, |this, cx| {
            this.buffer.update(cx, |buffer, cx| {
                buffer.edit(edits, None, cx);
            });
            this.request_autoscroll(Autoscroll::fit(), cx);
        });
    }

<|editable_region_start|>
    pub fn duplicate(&mut self, upwards: bool, whole_lines: bool, cx: &mut ViewContext<Self>) {
        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));
        let buffer = &display_map.buffer_snapshot;
        let selections = self.selections.all::<Point>(cx);

        if !whole_lines && selections.len() == 1 <|user_cursor_is_here|>selections[0].start != selections[0].end {}

        let mut edits = Vec::new();
        let mut selections_iter = selections.iter().peekable();
        while let Some(selection) = selections_iter.next() {
            // Avoid duplicating the same lines twice.
            let mut rows = selection.spanned_rows(false, &display_map);

            while let Some(next_selection) = selections_iter.peek() {
<|editable_region_end|>
                let next_rows = next_selection.spanned_rows(false, &display_map);
                if next_rows.start < rows.end {
                    rows.end = next_rows.end;
                    selections_iter.next().unwrap();
                } else {
                    break;
                }
            }
```
</input>
<output>
```crates/editor/src/editor.rs
            let text = buffer.text_for_range(start..end).collect::<String>();
            edits.push((selection.end..selection.end, text));
        }

        self.transact(cx, |this, cx| {
            this.buffer.update(cx, |buffer, cx| {
                buffer.edit(edits, None, cx);
            });
            this.request_autoscroll(Autoscroll::fit(), cx);
        });
    }

<|editable_region_start|>
    pub fn duplicate(&mut self, upwards: bool, whole_lines: bool, cx: &mut ViewContext<Self>) {
        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));
        let buffer = &display_map.buffer_snapshot;
        let selections = self.selections.all::<Point>(cx);

        if !whole_lines && selections.len() == 1 && selections[0].start != selections[0].end {}

        let mut edits = Vec::new();
        let mut selections_iter = selections.iter().peekable();
        while let Some(selection) = selections_iter.next() {
            // Avoid duplicating the same lines twice.
            let mut rows = selection.spanned_rows(false, &display_map);

            while let Some(next_selection) = selections_iter.peek() {
<|editable_region_end|>
                let next_rows = next_selection.spanned_rows(false, &display_map);
                if next_rows.start < rows.end {
                    rows.end = next_rows.end;
                    selections_iter.next().unwrap();
                } else {
                    break;
                }
            }
```
</output>

<labels>
local-edit,infer-intent
</labels>
