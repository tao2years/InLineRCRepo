<events>
User edited file: "internal/service/order.go":

```diff
@@ -19,7 +19,7 @@
     tx, err := s.repository.BeginTx(ctx)
     if err != nil {
         s.monitoring.IncCounter("db_errors", 1)
-        return nil, status.Error(codes.Internal, "failed to begin transaction")
+        return nil, status.Errorf(codes.Internal, "failed to begin transaction: %v", err)
     }
     defer tx.Rollback()
```

User edited file: "internal/service/order.go":

```diff
@@ -41,8 +41,8 @@
                     item.ProductId,
                 )
             }
             s.monitoring.IncCounter("db_errors", 1)
-            return nil, status.Error(codes.Internal, "failed to process order")
+            return nil, status.Errorf(codes.Internal, "failed to process order: %v", err)
         }

         if product.Stock < item.Quantity {
```
</events>

<input>
```internal/service/order.go
type OrderService struct {
    repository  *Repository
    validator   *Validator
    publisher   messaging.Publisher
    monitoring  *Monitoring
<|editable_region_start|>

    pb.UnimplementedOrderServiceServer
}

func (s *OrderService) CreateOrder(
    ctx context.Context,
    req *pb.CreateOrderRequest,
) (*pb.CreateOrderResponse, error) {
    if err := s.validator.ValidateCreateOrder(req); err != nil {
        s.monitoring.IncCounter("validation_errors", 1)
        return nil, status.Errorf(codes.InvalidArgument, "invalid request: %v", err)
    }

    tx, err := s.repository.BeginTx(ctx)
    if err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to begin transaction: %v", err)
    }
    defer tx.Rollback()

    order := &domain.Order{
        UserID:      req.UserId,
        Items:       make([]domain.OrderItem, len(req.Items)),
        TotalAmount: decimal.NewFromInt(0),
        Status:      domain.OrderStatusPending,
        CreatedAt:   time.Now().UTC(),
    }

    for i, item := range req.Items {
        product, err := s.repository.GetProduct(ctx, item.ProductId)
        if err != nil {
            if errors.Is(err, domain.ErrNotFound) {
                return nil, status.Errorf(
                    codes.NotFound,
                    "product not found: %s",
                    item.ProductId,
                )
            }
            s.monitoring.IncCounter("db_errors", 1)
            return nil, status.Errorf(codes.Internal, "failed to process order: %v", err)<|user_cursor_is_here|>
        }

        if product.Stock < item.Quantity {
            return nil, status.Errorf(
                codes.FailedPrecondition,
                "insufficient stock for product %s: have %d, want %d",
                product.ID,
                product.Stock,
                item.Quantity,
            )
        }

        order.Items[i] = domain.OrderItem{
            ProductID: product.ID,
            Quantity:  item.Quantity,
            Price:     product.Price,
        }
        order.TotalAmount = order.TotalAmount.Add(
            product.Price.Mul(decimal.NewFromInt(int64(item.Quantity))),
        )
    }

    if err := s.repository.CreateOrder(ctx, tx, order); err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to create order")
    }

    if err := tx.Commit(ctx); err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to commit transaction")
    }

    event := &events.OrderCreated{
<|editable_region_end|>
        OrderID: order.ID,
        UserID:  order.UserID,
        Status:  string(order.Status),
    }

    if err := s.publisher.Publish(ctx, "orders.created", event); err != nil {
        s.monitoring.IncCounter("messaging_errors", 1)
        log.WithError(err).Error("failed to publish order created event")
    }
```
</input>

<output>
```internal/service/order.go
type OrderService struct {
    repository  *Repository
    validator   *Validator
    publisher   messaging.Publisher
    monitoring  *Monitoring
<|editable_region_start|>

    pb.UnimplementedOrderServiceServer
}

func (s *OrderService) CreateOrder(
    ctx context.Context,
    req *pb.CreateOrderRequest,
) (*pb.CreateOrderResponse, error) {
    if err := s.validator.ValidateCreateOrder(req); err != nil {
        s.monitoring.IncCounter("validation_errors", 1)
        return nil, status.Errorf(codes.InvalidArgument, "invalid request: %v", err)
    }

    tx, err := s.repository.BeginTx(ctx)
    if err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to begin transaction: %v", err)
    }
    defer tx.Rollback()

    order := &domain.Order{
        UserID:      req.UserId,
        Items:       make([]domain.OrderItem, len(req.Items)),
        TotalAmount: decimal.NewFromInt(0),
        Status:      domain.OrderStatusPending,
        CreatedAt:   time.Now().UTC(),
    }

    for i, item := range req.Items {
        product, err := s.repository.GetProduct(ctx, item.ProductId)
        if err != nil {
            if errors.Is(err, domain.ErrNotFound) {
                return nil, status.Errorf(
                    codes.NotFound,
                    "product not found: %s",
                    item.ProductId,
                )
            }
            s.monitoring.IncCounter("db_errors", 1)
            return nil, status.Errorf(codes.Internal, "failed to process order: %v", err)
        }

        if product.Stock < item.Quantity {
            return nil, status.Errorf(
                codes.FailedPrecondition,
                "insufficient stock for product %s: have %d, want %d",
                product.ID,
                product.Stock,
                item.Quantity,
            )
        }

        order.Items[i] = domain.OrderItem{
            ProductID: product.ID,
            Quantity:  item.Quantity,
            Price:     product.Price,
        }
        order.TotalAmount = order.TotalAmount.Add(
            product.Price.Mul(decimal.NewFromInt(int64(item.Quantity))),
        )
    }

    if err := s.repository.CreateOrder(ctx, tx, order); err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to create order: %v", err)
    }

    if err := tx.Commit(ctx); err != nil {
        s.monitoring.IncCounter("db_errors", 1)
        return nil, status.Errorf(codes.Internal, "failed to commit transaction: %v", err)
    }

    event := &events.OrderCreated{
<|editable_region_end|>
        OrderID: order.ID,
        UserID:  order.UserID,
        Status:  string(order.Status),
    }

    if err := s.publisher.Publish(ctx, "orders.created", event); err != nil {
        s.monitoring.IncCounter("messaging_errors", 1)
        log.WithError(err).Error("failed to publish order created event")
    }
```
</output>

<labels>
non-local-edit,complete-pattern
</labels>
