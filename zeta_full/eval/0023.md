<rating>Negative</rating>
<feedback>I would want to keep my TODOs that I've just finished writing</feedback>
<events>
User edited "crates/editor/src/editor.rs":
```diff
@@ -12473,8 +12473,7 @@
                         .entry(buffer)
                         .or_insert((Vec::new(), None))
                         .0
-                        // TODO kb wrong row used, has to be buffer offset
-                        .push(start_offset..start_offset)
+                        .push(buffer_offset..buffer_offset)
                 }
             }
             None => {

```

User edited "crates/editor/src/editor.rs":
```diff
@@ -12464,7 +12464,6 @@
             }
             Some(JumpData::MultiBufferRow(row)) => {
                 let point = MultiBufferPoint::new(row.0, 0);
-                dbg!(row);
                 if let Some((buffer, buffer_point, _)) =
                     self.buffer.read(cx).point_to_buffer_point(point, cx)
                 {

```

User edited "crates/editor/src/element.rs":
```diff
@@ -597,7 +597,6 @@
                 .snapshot
                 .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)
                 .row;
-            dbg!(multi_buffer_row,);
             if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {
                 if hit_box.contains(&event.position) {
                     editor.open_excerpts_common(

```

User edited ".git/COMMIT_EDITMSG":
```diff
@@ -1,4 +1,7 @@
 
+
+co-authored-by: Agus Zubiaga <agus@zed.dev>
+
 # Please enter the commit message for your changes. Lines starting
 # with '#' will be ignored, and an empty message aborts the commit.
 #

```

User edited ".git/COMMIT_EDITMSG":
```diff
@@ -1,4 +1,4 @@
-
+Fix navigation bugs
 
 co-authored-by: Agus Zubiaga <agus@zed.dev>
 

```

User edited "crates/editor/src/element.rs":
```diff
@@ -609,7 +609,7 @@
             }
         }
 
-        cx.stop_propagation();
+        
     }
 
     fn mouse_right_down(

```

User edited "crates/editor/src/element.rs":
```diff
@@ -608,8 +608,6 @@
                 }
             }
         }
-
-        
     }
 
     fn mouse_right_down(

```

User edited "crates/editor/src/element.rs":
```diff
@@ -589,6 +589,7 @@
                     cx,
                 );
             }
+            cx.stop_propagation();
         } else {
             let display_row = (((event.position - gutter_hitbox.bounds.origin).y
                 + position_map.scroll_pixel_position.y)

```

User edited "crates/editor/src/element.rs":
```diff
@@ -591,6 +591,7 @@
             }
             cx.stop_propagation();
         } else {
+            // TODO kb belongs to a methods
             let display_row = (((event.position - gutter_hitbox.bounds.origin).y
                 + position_map.scroll_pixel_position.y)
                 / position_map.line_height) as u32;

```

User edited "crates/editor/src/element.rs":
```diff
@@ -591,7 +591,7 @@
             }
             cx.stop_propagation();
         } else {
-            // TODO kb belongs to a methods
+            // TODO kb extract common code around this module into method/functi
             let display_row = (((event.position - gutter_hitbox.bounds.origin).y
                 + position_map.scroll_pixel_position.y)
                 / position_map.line_height) as u32;

```
</events>
<input>
```crates/editor/src/element.rs
                        goal_column: point_for_position.exact_unclipped.column(),
<|editable_region_start|>
                    },
                    cx,
                );
            } else if modifiers.shift
                && !modifiers.control
                && !modifiers.alt
                && !modifiers.secondary()
            {
                editor.select(
                    SelectPhase::Extend {
                        position,
                        click_count,
                    },
                    cx,
                );
            } else {
                let multi_cursor_setting = EditorSettings::get_global(cx).multi_cursor_modifier;
                let multi_cursor_modifier = match multi_cursor_setting {
                    MultiCursorModifier::Alt => modifiers.alt,
                    MultiCursorModifier::CmdOrCtrl => modifiers.secondary(),
                };
                editor.select(
                    SelectPhase::Begin {
                        position,
                        add: multi_cursor_modifier,
                        click_count,
                    },
                    cx,
                );
            }
            cx.stop_propagation();
        } else {
            // TODO kb extract common code around this module into method/functi<|user_cursor_is_here|>
            let display_row = (((event.position - gutter_hitbox.bounds.origin).y
                + position_map.scroll_pixel_position.y)
                / position_map.line_height) as u32;
            let multi_buffer_row = position_map
                .snapshot
                .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)
                .row;
            if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {
                if hit_box.contains(&event.position) {
                    editor.open_excerpts_common(
                        Some(JumpData::MultiBufferRow(MultiBufferRow(multi_buffer_row))),
                        modifiers.alt == true,
                        cx,
                    );
                    cx.stop_propagation();
                }
            }
        }
    }

    fn mouse_right_down(
        editor: &mut Editor,
        event: &MouseDownEvent,
        position_map: &PositionMap,
        text_hitbox: &Hitbox,
        cx: &mut ViewContext<Editor>,
    ) {
        if !text_hitbox.is_hovered(cx) {
            return;
        }
        let point_for_position =
            position_map.point_for_position(text_hitbox.bounds, event.position);
<|editable_region_end|>
        mouse_context_menu::deploy_context_menu(
```
</input>
<output>
```crates/editor/src/element.rs
                        goal_column: point_for_position.exact_unclipped.column(),
<|editable_region_start|>
                    },
                    cx,
                );
            } else if modifiers.shift
                && !modifiers.control
                && !modifiers.alt
                && !modifiers.secondary()
            {
                editor.select(
                    SelectPhase::Extend {
                        position,
                        click_count,
                    },
                    cx,
                );
            } else {
                let multi_cursor_setting = EditorSettings::get_global(cx).multi_cursor_modifier;
                let multi_cursor_modifier = match multi_cursor_setting {
                    MultiCursorModifier::Alt => modifiers.alt,
                    MultiCursorModifier::CmdOrCtrl => modifiers.secondary(),
                };
                editor.select(
                    SelectPhase::Begin {
                        position,
                        add: multi_cursor_modifier,
                        click_count,
                    },
                    cx,
                );
            }
            cx.stop_propagation();
        } else {
            // TODO kb extract common code around this module into method/function
            let display_row = (((event.position - gutter_hitbox.bounds.origin).y
                + position_map.scroll_pixel_position.y)
                / position_map.line_height) as u32;
            let multi_buffer_row = position_map
                .snapshot
                .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)
                .row;
            if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {
                if hit_box.contains(&event.position) {
                    editor.open_excerpts_common(
                        Some(JumpData::MultiBufferRow(MultiBufferRow(multi_buffer_row))),
                        modifiers.alt == true,
                        cx,
                    );
                    cx.stop_propagation();
                }
            }
        }
    }

    fn mouse_right_down(
        editor: &mut Editor,
        event: &MouseDownEvent,
        position_map: &PositionMap,
        text_hitbox: &Hitbox,
        cx: &mut ViewContext<Editor>,
    ) {
        if !text_hitbox.is_hovered(cx) {
            return;
        }
        let point_for_position =
            position_map.point_for_position(text_hitbox.bounds, event.position);
<|editable_region_end|>
        mouse_context_menu::deploy_context_menu(
```
</output>
<outline>
```crates/editor/src/element.rs
struct SelectionLayout
 head
 cursor_shape
 is_newest
 is_local
 range
 active_rows
 user_name
impl SelectionLayout
 fn new
pub struct EditorElement
 editor
 style
type DisplayRowDelta
impl EditorElement
 pub(crate) const SCROLLBAR_WIDTH
 pub fn new
 fn register_actions
 fn register_key_listeners
 fn modifiers_changed
 fn mouse_left_down
 fn mouse_right_down
 fn mouse_middle_down
 fn mouse_up
 fn mouse_dragged
 fn mouse_moved
 fn update_visible_cursor
 fn layout_selections
 fn collect_cursors
 fn layout_visible_cursors
 fn layout_scrollbars
 fn prepaint_crease_toggles
 fn prepaint_crease_trailers
 fn layout_gutter_git_hunks
 fn layout_inline_blame
  const INLINE_BLAME_PADDING_EM_WIDTHS
 fn layout_blame_entries
 fn layout_indent_guides
 fn calculate_indent_guide_bounds
 fn layout_run_indicators
 fn layout_code_actions_indicator
 fn get_participant_color
 fn calculate_relative_line_numbers
 fn layout_line_numbers
 fn layout_crease_toggles
 fn layout_crease_trailers
 fn layout_lines
 fn prepaint_lines
 fn render_block
 fn render_buffer_header
 fn render_expand_excerpt_button
 fn render_blocks
 fn layout_blocks
 fn layout_context_menu
 fn layout_context_menu_aside
 fn layout_inline_completion_popover
  const PADDING_X
  const PADDING_Y
 fn layout_mouse_context_menu
 fn layout_hover_popovers
  struct MeasuredHoverPopover
   element
   size
   horizontal_offset
  fn draw_occluder
 fn layout_signature_help
 fn paint_background
 fn paint_indent_guides
  const INDENT_AWARE_ALPHA
  const INDENT_AWARE_ACTIVE_ALPHA
  const INDENT_AWARE_BACKGROUND_ALPHA
  const INDENT_AWARE_BACKGROUND_ACTIVE_ALPHA
 fn paint_line_numbers
 fn paint_diff_hunks
 pub(super) fn diff_hunk_bounds
 pub(super) fn diff_hunk_strip_width
 fn paint_gutter_indicators
 fn paint_gutter_highlights
 fn paint_blamed_display_rows
 fn paint_text
 fn paint_highlights
 fn paint_lines
 fn paint_redactions
 fn paint_cursors
 fn paint_scrollbars
 fn collect_fast_scrollbar_markers
  const LIMIT
 fn refresh_slow_scrollbar_markers
 fn paint_highlighted_range
 fn paint_inline_blame
 fn paint_blocks
 fn paint_inline_completion_popover
 fn paint_mouse_context_menu
 fn paint_scroll_wheel_listener
 fn paint_mouse_listeners
 fn scrollbar_left
 fn column_pixels
 fn max_line_number_width
fn header_jump_data
fn all_edits_insertions_or_deletions
fn prepaint_gutter_button
fn render_inline_blame_entry
fn render_blame_entry
fn deploy_blame_entry_context_menu
pub(crate) struct LineWithInvisibles
 fragments
 invisibles
 len
 width
 font_size
enum LineFragment
 Text
 Element
  element
  size
  len
impl fmt::Debug for LineFragment
 fn fmt
impl LineWithInvisibles
 fn from_chunks
 fn prepaint
 fn draw
 fn draw_invisibles
 pub fn x_for_index
 pub fn index_for_x
 pub fn font_id_for_index
enum Invisible
 Tab
  line_start_offset
  line_end_offset
 Whitespace
  line_offset
impl EditorElement
 fn rem_size
impl Element for EditorElement
 type RequestLayoutState
 type PrepaintState
 fn id
 fn request_layout
 fn prepaint
 fn paint
pub(super) fn gutter_bounds
struct ScrollbarRangeData
 scrollbar_bounds
 scroll_range
 letter_size
impl ScrollbarRangeData
 pub fn new
impl IntoElement for EditorElement
 type Element
 fn into_element
pub struct EditorLayout
 position_map
 hitbox
 text_hitbox
 gutter_hitbox
 content_origin
 scrollbars_layout
 mode
 wrap_guides
 indent_guides
 visible_display_row_range
 active_rows
 highlighted_rows
 line_elements
 line_numbers
 display_hunks
 blamed_display_rows
 inline_blame
 blocks
 highlighted_ranges
 highlighted_gutter_ranges
 redacted_ranges
 cursors
 visible_cursors
 selections
 code_actions_indicator
 test_indicators
 crease_toggles
 crease_trailers
 inline_completion_popover
 mouse_context_menu
 tab_invisible
 space_invisible
impl EditorLayout
 fn line_end_overshoot
struct ColoredRange
 start
 end
 color
struct ScrollbarLayout
 hitbox
 visible_range
 visible
 text_unit_size
 thumb_size
 axis
impl ScrollbarLayout
 const BORDER_WIDTH
 const LINE_MARKER_HEIGHT
 const MIN_MARKER_HEIGHT
 fn thumb_bounds
 fn y_for_row
 fn marker_quads_for_ranges
  struct MinMax
   min
   max
struct CreaseTrailerLayout
 element
 bounds
struct PositionMap
 size
 line_height
 scroll_pixel_position
 scroll_max
 em_width
 em_advance
 line_layouts
 snapshot
pub struct PointForPosition
 pub previous_valid
 pub next_valid
 pub exact_unclipped
 pub column_overshoot_after_line_end
impl PointForPosition
 pub fn as_valid
impl PositionMap
 fn point_for_position
struct BlockLayout
 id
 row
 element
 available_space
 style
fn layout_line
pub struct IndentGuideLayout
 origin
 length
 single_indent_width
 depth
 active
 settings
pub struct CursorLayout
 origin
 block_width
 line_height
 color
 shape
 block_text
 cursor_name
pub struct CursorName
 string
 color
 is_top_row
impl CursorLayout
 pub fn new
 pub fn bounding_rect
 fn bounds
 pub fn layout
 pub fn paint
 pub fn shape
pub struct HighlightedRange
 pub start_y
 pub line_height
 pub lines
 pub color
 pub corner_radius
pub struct HighlightedRangeLine
 pub start_x
 pub end_x
impl HighlightedRange
 pub fn paint
 fn paint_lines
pub fn scale_vertical_mouse_autoscroll_delta
fn scale_horizontal_mouse_autoscroll_delta
pub fn register_action
fn compute_auto_height_layout
mod tests
 fn test_shape_line_numbers
 async fn test_vim_visual_selections
 fn test_layout_with_placeholder_text_and_blocks
 fn test_all_invisibles_drawing
  const TAB_SIZE
 fn test_invisibles_dont_appear_in_certain_editors
 fn test_wrapped_invisibles_drawing
 fn collect_invisibles_from_new_editor
```

</outline>

<assertions>
Ensure the code contains the comment `// TODO kb extract common code around this module into method/functi`
</assertions>

<labels>
local-edit,infer-refactor
</labels>
