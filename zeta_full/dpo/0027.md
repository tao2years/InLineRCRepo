<events>
User edited "src/extension.ts":
```diff
@@ -127,7 +127,7 @@
   return explicitlySupportedLanguages.includes(lang as SupportedLanguage);
 }
 
-// ideally with more time i'd use tree-sitter or something here so in languages that need it 
+// ideally with more time i'd use tree-sitter or something here so in languages that need it we
 function colorStringForLanguage(color: string, lang?: SupportedLanguage) {
   switch (lang) {
     case "rust":

```
</events>
<input>
```src/extension.ts
    matchedColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${rgbaMatch[4]})`;
  }

  if (matchedColor) {
    try {
      const color = chroma(matchedColor);
      return color.hex();
    } catch (error) {
      return "Color is invalid, or an unsupported color type";
<|editable_region_start|>
    <|user_cursor_is_here|>}
  }

  try {
    const color = chroma(line.trim());
    return color.hex();
  } catch (error) {
    return "Color is invalid, or an unsupported color type";
  }
}

/**
 * Get the active buffer's language
 * so we can dynamically generate color strings based on the language
 */
function activeBufferLanguage() {
  const editor = vscode.window.activeTextEditor;
  return editor?.document.languageId || null;
}

function languageIsSupported(lang: string): lang is SupportedLanguage {
  return explicitlySupportedLanguages.includes(lang as SupportedLanguage);
}

// ideally with more time i'd use tree-sitter or something here so in languages that need it we
function colorStringForLanguage(color: string, lang?: SupportedLanguage) {
  switch (lang) {
    case "rust":
      return `Rgb::new(${color})`;
    case "typescript":
      return color;
    case "css":
      return `#${color}`;
    case "json":
      return `"${color}"`;
    default:
      return color;
  }
}

// as there would probably be a lot of these, it would be nice to use
// something similar to handlebars templates to define color strings
// for various languages/formats, and keep them somewhere external
// like src/templates
function allColorsStringForLanguage(
  colors: { [folder: string]: { [key: string]: string } },
  lang: SupportedLanguage | "default",
): string {
  switch (lang) {
    case "rust":
      let rustCode = `
use palette::rgb::Rgb;
<|editable_region_end|>

trait Color {
    fn name(&self) -> &'static str;
    fn rgb(&self) -> Rgb;
    fn hex(&self) -> &'static str;
}
```
</input>
<output>
```src/extension.ts
    matchedColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${rgbaMatch[4]})`;
  }

  if (matchedColor) {
    try {
      const color = chroma(matchedColor);
      return color.hex();
    } catch (error) {
      return "Color is invalid, or an unsupported color type";
<|editable_region_start|>
    }
  }

  try {
    const color = chroma(line.trim());
    return color.hex();
  } catch (error) {
    return "Color is invalid, or an unsupported color type";
  }
}

/**
 * Get the active buffer's language
 * so we can dynamically generate color strings based on the language
 */
function activeBufferLanguage() {
  const editor = vscode.window.activeTextEditor;
  return editor?.document.languageId || null;
}

function languageIsSupported(lang: string): lang is SupportedLanguage {
  return explicitlySupportedLanguages.includes(lang as SupportedLanguage);
}

// ideally with more time i'd use tree-sitter or something here so in languages that need it we could account for syntax more easily
function colorStringForLanguage(color: string, lang?: SupportedLanguage) {
  switch (lang) {
    case "rust":
      return `Rgb::new(${color})`;
    case "typescript":
      return color;
    case "css":
      return `#${color}`;
    case "json":
      return `"${color}"`;
    default:
      return color;
  }
}

// as there would probably be a lot of these, it would be nice to use
// something similar to handlebars templates to define color strings
// for various languages/formats, and keep them somewhere external
// like src/templates
function allColorsStringForLanguage(
  colors: { [folder: string]: { [key: string]: string } },
  lang: SupportedLanguage | "default",
): string {
  switch (lang) {
    case "rust":
      let rustCode = `
use palette::rgb::Rgb;
<|editable_region_end|>

trait Color {
    fn name(&self) -> &'static str;
    fn rgb(&self) -> Rgb;
    fn hex(&self) -> &'static str;
}
```
</output>
<outline>
```src/extension.ts
const explicitlySupportedLanguages
type SupportedLanguage
const primaryColor
const gruvboxColors
const hexColorRegex
const rgbColorRegex
const rgbaColorRegex
function getInitialColorLibrary()
function createColorIcon( )
function tryParseColor( )
function activeBufferLanguage()
function languageIsSupported( )
function colorStringForLanguage( )
function allColorsStringForLanguage( )
class ColorItem
 constructor( )
class ColorTreeDataProvider
 private _onDidChangeTreeData
 readonly onDidChangeTreeData
 constructor( )
 refresh()
 getTreeItem( )
 tryGetTreeItem( )
 getChildren( )
class FolderItem
 constructor( )
async function insertAllColors( )
 context.globalState.get colorLibrary
function activate( )
 context.globalState.get colorLibrary
 context.globalState.update colorLibrary
 context.globalState.get colorLibrary
 context.globalState.update colorLibrary
function deactivate()
async function saveColor( )
 context.globalState.get colorLibrary
 context.globalState.update colorLibrary
async function insertChosenColor( )
async function chooseColor( )
 context.globalState.get colorLibrary
async function clearAllColors( )
 context.globalState.update colorLibrary
async function exportColorsToJson( )
 context.globalState.get colorLibrary
```

</outline>
<rejected>
```src/extension.ts
    matchedColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${rgbaMatch[4]})`;
  }

  if (matchedColor) {
    try {
      const color = chroma(matchedColor);
      return color.hex();
    } catch (error) {
      return "Color is invalid, or an unsupported color type";
<|editable_region_start|>
    <|editable_region_end|>

trait Color {
    fn name(&self) -> &'static str;
    fn rgb(&self) -> Rgb;
    fn hex(&self) -> &'static str;
}
```
</rejected>

<labels>
non-local-edit,complete-pattern
</labels>
