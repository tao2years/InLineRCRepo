<events>
User edited "crates/editor/src/git/project_diff.rs":
```diff
@@ -856,7 +856,7 @@
                     for (_, buffer, hunk_ranges) in excerpts_to_add {
                         let buffer_snapshot = buffer.read(cx).snapshot();
                         let max_point = buffer_snapshot.max_point();
-                        let new_excerpts = multi_buffer.insert_excerpts(
+                        let new_excerpts = multi_buffer.push_excerpts(
                             buffer,
                             hunk_ranges.into_iter().map(|range| {
                                 let mut extended_point_range = range.to_point(&buffer_snapshot);

```
</events>
<input>
```crates/diagnostics/src/diagnostics.rs
                            Ordering::Equal => {
                                to_keep = old_groups.next();
                                new_groups.next();
                            }
                            Ordering::Greater => to_insert = new_groups.next(),
                        }
                    }
                }

                if let Some((language_server_id, group)) = to_insert {
                    let mut group_state = DiagnosticGroupState {
<|editable_region_start|>
                        language_server_id,
                        primary_diagnostic: group.entries[group.primary_ix].clone(),
                        primary_excerpt_ix: 0,
                        excerpts: Default::default(),
                        blocks: Default::default(),
                        block_count: 0,
                    };
                    let mut pending_range: Option<(Range<Point>, Range<Point>, usize)> = None;
                    let mut is_first_excerpt_for_group = true;
                    for (ix, entry) in group.entries.iter().map(Some).chain([None]).enumerate() {
                        let resolved_entry = entry.map(|e| e.resolve::<Point>(&snapshot));
                        let expanded_range = resolved_entry.as_ref().map(|entry| {
                            context_range_for_entry(entry, self.context, &snapshot, cx)
                        });
                        if let Some((range, context_range, start_ix)) = &mut pending_range {
                            if let Some(expanded_range) = expanded_range.clone() {
                                // If the entries are overlapping or next to each-other, merge them into one excerpt.
                                if context_range.end.row + 1 >= expanded_range.start.row {
                                    context_range.end = context_range.end.max(expanded_range.end);
                                    continue;
                                }
                            }
<|user_cursor_is_here|>
                            let excerpt_id = excerpts
                                .push_excerpts(
                                    buffer.clone(),
                                    [ExcerptRange {
                                        context: context_range.clone(),
                                        primary: Some(range.clone()),
                                    }],
                                    cx,
                                )
                                .pop()
                                .unwrap();

                            prev_excerpt_id = excerpt_id;
                            first_excerpt_id.get_or_insert(prev_excerpt_id);
                            group_state.excerpts.push(excerpt_id);
                            let header_position = (excerpt_id, language::Anchor::MIN);

                            if is_first_excerpt_for_group {
                                is_first_excerpt_for_group = false;
                                let mut primary =
                                    group.entries[group.primary_ix].diagnostic.clone();
                                primary.message =
                                    primary.message.split('\n').next().unwrap().to_string();
                                group_state.block_count += 1;
                                blocks_to_add.push(BlockProperties {
                                    placement: BlockPlacement::Above(header_position),
                                    height: 2,
                                    style: BlockStyle::Sticky,
                                    render: diagnostic_header_renderer(primary),
                                    priority: 0,
                                });
<|editable_region_end|>
                            }
```
</input>
<output>
```crates/diagnostics/src/diagnostics.rs
                            Ordering::Equal => {
                                to_keep = old_groups.next();
                                new_groups.next();
                            }
                            Ordering::Greater => to_insert = new_groups.next(),
                        }
                    }
                }

                if let Some((language_server_id, group)) = to_insert {
                    let mut group_state = DiagnosticGroupState {
<|editable_region_start|>
                        language_server_id,
                        primary_diagnostic: group.entries[group.primary_ix].clone(),
                        primary_excerpt_ix: 0,
                        excerpts: Default::default(),
                        blocks: Default::default(),
                        block_count: 0,
                    };
                    let mut pending_range: Option<(Range<Point>, Range<Point>, usize)> = None;
                    let mut is_first_excerpt_for_group = true;
                    for (ix, entry) in group.entries.iter().map(Some).chain([None]).enumerate() {
                        let resolved_entry = entry.map(|e| e.resolve::<Point>(&snapshot));
                        let expanded_range = resolved_entry.as_ref().map(|entry| {
                            context_range_for_entry(entry, self.context, &snapshot, cx)
                        });
                        if let Some((range, context_range, start_ix)) = &mut pending_range {
                            if let Some(expanded_range) = expanded_range.clone() {
                                // If the entries are overlapping or next to each-other, merge them into one excerpt.
                                if context_range.end.row + 1 >= expanded_range.start.row {
                                    context_range.end = context_range.end.max(expanded_range.end);
                                    continue;
                                }
                            }

                            let excerpt_id = excerpts
                                .push_excerpts(
                                    buffer.clone(),
                                    [ExcerptRange {
                                        context: context_range.clone(),
                                        primary: Some(range.clone()),
                                    }],
                                    cx,
                                )
                                .pop()
                                .unwrap();

                            prev_excerpt_id = excerpt_id;
                            first_excerpt_id.get_or_insert(prev_excerpt_id);
                            group_state.excerpts.push(excerpt_id);
                            let header_position = (excerpt_id, language::Anchor::MIN);

                            if is_first_excerpt_for_group {
                                is_first_excerpt_for_group = false;
                                let mut primary =
                                    group.entries[group.primary_ix].diagnostic.clone();
                                primary.message =
                                    primary.message.split('\n').next().unwrap().to_string();
                                group_state.block_count += 1;
                                blocks_to_add.push(BlockProperties {
                                    placement: BlockPlacement::Above(header_position),
                                    height: 2,
                                    style: BlockStyle::Sticky,
                                    render: diagnostic_header_renderer(primary),
                                    priority: 0,
                                });
<|editable_region_end|>
                            }
```
</output>
<outline>
```crates/diagnostics/src/diagnostics.rs
pub mod items
mod project_diagnostics_settings
mod toolbar_controls
mod diagnostics_tests
struct IncludeWarnings
impl Global for IncludeWarnings
pub fn init
struct ProjectDiagnosticsEditor
 project
 workspace
 focus_handle
 editor
 summary
 excerpts
 path_states
 paths_to_update
 include_warnings
 context
 update_excerpts_task
 _subscription
struct PathState
 path
 diagnostic_groups
struct DiagnosticGroupState
 language_server_id
 primary_diagnostic
 primary_excerpt_ix
 excerpts
 blocks
 block_count
impl EventEmitter<EditorEvent> for ProjectDiagnosticsEditor
const DIAGNOSTICS_UPDATE_DEBOUNCE
impl Render for ProjectDiagnosticsEditor
 fn render
impl ProjectDiagnosticsEditor
 fn register
 fn new_with_context
 fn update_stale_excerpts
 fn new
 fn deploy
 fn toggle_warnings
 fn focus_in
 fn focus_out
 fn update_all_excerpts
 fn update_excerpts
 fn check_invariants
impl Focusable for ProjectDiagnosticsEditor
 fn focus_handle
impl Item for ProjectDiagnosticsEditor
 type Event
 fn to_item_events
 fn deactivated
 fn navigate
 fn tab_tooltip_text
 fn tab_content
 fn telemetry_event_text
 fn for_each_project_item
 fn is_singleton
 fn set_nav_history
 fn clone_on_split
 fn is_dirty
 fn has_deleted_file
 fn has_conflict
 fn can_save
 fn save
 fn save_as
 fn reload
 fn act_as_type
 fn as_searchable
 fn breadcrumb_location
 fn breadcrumbs
 fn added_to_workspace
const DIAGNOSTIC_HEADER
fn diagnostic_header_renderer
fn compare_diagnostics
const DIAGNOSTIC_EXPANSION_ROW_LIMIT
fn context_range_for_entry
fn heuristic_syntactic_expand
fn is_line_blank_or_indented_less
```

</outline>
<rejected>
```crates/diagnostics/src/diagnostics.rs
                            Ordering::Equal => {
                                to_keep = old_groups.next();
                                new_groups.next();
                            }
                            Ordering::Greater => to_insert = new_groups.next(),
                        }
                    }
                }

                if let Some((language_server_id, group)) = to_insert {
                    let mut group_state = DiagnosticGroupState {
<|editable_region_start|>
                        language_server_id,
                        primary_diagnostic: group.entries[group.primary_ix].clone(),
                        primary_excerpt_ix: 0,
                        excerpts: Default::default(),
                        blocks: Default::default(),
                        block_count: 0,
                    };
                    let mut pending_range: Option<(Range<Point>, Range<Point>, usize)> = None;
                    let mut is_first_excerpt_for_group = true;
                    for (ix, entry) in group.entries.iter().map(Some).chain([None]).enumerate() {
                        let resolved_entry = entry.map(|e| e.resolve::<Point>(&snapshot));
                        let expanded_range = resolved_entry.as_ref().map(|entry| {
                            context_range_for_entry(entry, self.context, &snapshot, cx)
                        });
                        if let Some((range, context_range, start_ix)) = &mut pending_range {
                            if let Some(expanded_range) = expanded_range.clone() {
                                // If the entries are overlapping or next to each-other, merge them into one excerpt.
                                if context_range.end.row + 1 >= expanded_range.start.row {
                                    context_range.end = context_range.end.max(expanded_range.end);
                                    continue;
                                }
                            }
<|editable_region_end|>
                            }
```
</rejected>

<labels>
local-edit,infer-intent
</labels>
