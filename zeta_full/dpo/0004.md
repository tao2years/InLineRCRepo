<events>
User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -647,7 +647,7 @@
                     format!(
                     "{}:{}",
                         expected_placeholder.line, expected_placeholder.character
-                    )
+            )
                 );
             });
 

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -645,9 +645,7 @@
                 assert_eq!(
                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),
                     format!(
-                    "{}:{}",
-                        expected_placeholder.line, expected_placeholder.character
-            )
+                    "{}:{}",expected_placeholder.line, expected_placeholder.character)
                 );
             });
 

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -645,7 +645,7 @@
                 assert_eq!(
                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),
                     format!(
-                    "{}:{}",expected_placeholder.line, expected_placeholder.character)
+                    "{}:{}", expected_placeholder.line, expected_placeholder.character)
                 );
             });
 

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -644,8 +644,7 @@
             go_to_line_view.update(cx, |go_to_line_view| {
                 assert_eq!(
                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),
-                    format!(
-                    "{}:{}", expected_placeholder.line, expected_placeholder.character)
+                    format!("{}:{}", expected_placeholder.line, expected_placeholder.character)
                 );
             });
 

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -641,14 +641,16 @@
     ) {
         let go_to_line_view = open_go_to_line_view(workspace, cx);
 
-            go_to_line_view.update(cx, |go_to_line_view| {
-                assert_eq!(
-                    go_to_line_view.line_editor.read(cx).placeholder_text(cx),
-                    format!("{}:{}", expected_placeholder.line, expected_placeholder.character)
-                );
-            });
+        go_to_line_view.update(cx, |go_to_line_view| {
+            assert_eq!(
+                go_to_line_view.line_editor.read(cx).placeholder_text(cx),
+                format!(
+                    "{}:{}",
+                    expected_placeholder.line, expected_placeholder.character
+                )
+            );
+        });
 
-        );
         cx.simulate_input(&format!("{}:{}", new_point.line, new_point.character));
         cx.dispatch_action(menu::Confirm);
     }

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -640,7 +640,6 @@
         cx: &mut VisualTestContext,
     ) {
         let go_to_line_view = open_go_to_line_view(workspace, cx);
-
         go_to_line_view.update(cx, |go_to_line_view| {
             assert_eq!(
                 go_to_line_view.line_editor.read(cx).placeholder_text(cx),

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -649,7 +649,6 @@
                 )
             );
         });
-
         cx.simulate_input(&format!("{}:{}", new_point.line, new_point.character));
         cx.dispatch_action(menu::Confirm);
     }

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -640,7 +640,7 @@
         cx: &mut VisualTestContext,
     ) {
         let go_to_line_view = open_go_to_line_view(workspace, cx);
-        go_to_line_view.update(cx, |go_to_line_view| {
+        go_to_line_view.update(cx, |go_to_line_view, cx| {
             assert_eq!(
                 go_to_line_view.line_editor.read(cx).placeholder_text(cx),
                 format!(

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -642,7 +642,11 @@
         let go_to_line_view = open_go_to_line_view(workspace, cx);
         go_to_line_view.update(cx, |go_to_line_view, cx| {
             assert_eq!(
-                go_to_line_view.line_editor.read(cx).placeholder_text(cx),
+                go_to_line_view
+                    .line_editor
+                    .read(cx)
+                    .placeholder_text(cx)
+                    .unwrap(),
                 format!(
                     "{}:{}",
                     expected_placeholder.line, expected_placeholder.character

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -646,7 +646,7 @@
                     .line_editor
                     .read(cx)
                     .placeholder_text(cx)
-                    .unwrap(),
+                    .expect("No placeholder text"),
                 format!(
                     "{}:{}",
                     expected_placeholder.line, expected_placeholder.character

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -67,6 +67,11 @@
         cx: &mut ViewContext<Self>,
     ) -> Self {
         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
+            let last_position = s.head();
+            let line_start = Point::new(last_position.row, 0);
+            let chars_to_last_position = multi_buffer_snapshot
+                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
+                .chars as u32;
             let cursor = editor.selections.last::<Point>(cx).head();
             let snapshot = active_buffer.read(cx).snapshot();
 

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -67,7 +67,7 @@
         cx: &mut ViewContext<Self>,
     ) -> Self {
         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
-            let last_position = s.head();
+            let last_position = editor.selections.last::<Point>(cx).head();
             let line_start = Point::new(last_position.row, 0);
             let chars_to_last_position = multi_buffer_snapshot
                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -72,7 +72,6 @@
             let chars_to_last_position = multi_buffer_snapshot
                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
                 .chars as u32;
-            let cursor = editor.selections.last::<Point>(cx).head();
             let snapshot = active_buffer.read(cx).snapshot();
 
             let last_line = editor

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -67,12 +67,13 @@
         cx: &mut ViewContext<Self>,
     ) -> Self {
         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
+            let snapshot = active_buffer.read(cx).snapshot();
+
             let last_position = editor.selections.last::<Point>(cx).head();
             let line_start = Point::new(last_position.row, 0);
-            let chars_to_last_position = multi_buffer_snapshot
+            let chars_to_last_position = snapshot
                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
                 .chars as u32;
-            let snapshot = active_buffer.read(cx).snapshot();
 
             let last_line = editor
                 .buffer()

```

User edited "crates/go_to_line/src/go_to_line.rs":
```diff
@@ -68,7 +68,7 @@
     ) -> Self {
         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
             let snapshot = active_buffer.read(cx).snapshot();
-
+            // TODO kb extra
             let last_position = editor.selections.last::<Point>(cx).head();
             let line_start = Point::new(last_position.row, 0);
             let chars_to_last_position = snapshot

```
</events>
<input>
```crates/go_to_line/src/go_to_line.rs
impl EventEmitter<DismissEvent> for GoToLine {}

enum GoToLineRowHighlights {}

impl GoToLine {
    fn register(editor: &mut Editor, cx: &mut ViewContext<Editor>) {
        let handle = cx.view().downgrade();
        editor
            .register_action(move |_: &editor::actions::ToggleGoToLine, cx| {
                let Some(editor_handle) = handle.upgrade() else {
<|editable_region_start|>
                    return;
                };
                let Some(workspace) = editor_handle.read(cx).workspace() else {
                    return;
                };
                let editor = editor_handle.read(cx);
                let Some((_, buffer, _)) = editor.active_excerpt(cx) else {
                    return;
                };
                workspace.update(cx, |workspace, cx| {
                    workspace.toggle_modal(cx, move |cx| GoToLine::new(editor_handle, buffer, cx));
                })
            })
            .detach();
    }

    pub fn new(
        active_editor: View<Editor>,
        active_buffer: Model<Buffer>,
        cx: &mut ViewContext<Self>,
    ) -> Self {
        let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
            let snapshot = active_buffer.read(cx).snapshot();
            // TODO kb extra<|user_cursor_is_here|>
            let last_position = editor.selections.last::<Point>(cx).head();
            let line_start = Point::new(last_position.row, 0);
            let chars_to_last_position = snapshot
                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
                .chars as u32;

            let last_line = editor
                .buffer()
                .read(cx)
                .excerpts_for_buffer(&active_buffer, cx)
                .into_iter()
                .map(move |(_, range)| text::ToPoint::to_point(&range.context.end, &snapshot).row)
                .max()
                .unwrap_or(0);

            (cursor, last_line, editor.scroll_position(cx))
        });

<|editable_region_end|>
        let line = cursor.row + 1;
        let column = cursor.column + 1;

        let line_editor = cx.new_view(|cx| {
            let mut editor = Editor::single_line(cx);
            // TODO kb wrong column number here
            editor.set_placeholder_text(format!("{line}{FILE_ROW_COLUMN_DELIMITER}{column}"), cx);
            editor
        });
        let line_editor_change = cx.subscribe(&line_editor, Self::on_line_editor_event);

        let current_text = format!(
            "Current Line: {} of {} (column {})",
            line,
            last_line + 1,
```
</input>
<output>
```crates/go_to_line/src/go_to_line.rs
impl EventEmitter<DismissEvent> for GoToLine {}

enum GoToLineRowHighlights {}

impl GoToLine {
    fn register(editor: &mut Editor, cx: &mut ViewContext<Editor>) {
        let handle = cx.view().downgrade();
        editor
            .register_action(move |_: &editor::actions::ToggleGoToLine, cx| {
                let Some(editor_handle) = handle.upgrade() else {
<|editable_region_start|>
                    return;
                };
                let Some(workspace) = editor_handle.read(cx).workspace() else {
                    return;
                };
                let editor = editor_handle.read(cx);
                let Some((_, buffer, _)) = editor.active_excerpt(cx) else {
                    return;
                };
                workspace.update(cx, |workspace, cx| {
                    workspace.toggle_modal(cx, move |cx| GoToLine::new(editor_handle, buffer, cx));
                })
            })
            .detach();
    }

    pub fn new(
        active_editor: View<Editor>,
        active_buffer: Model<Buffer>,
        cx: &mut ViewContext<Self>,
    ) -> Self {
        let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
            let snapshot = active_buffer.read(cx).snapshot();
            // TODO kb extract
            let last_position = editor.selections.last::<Point>(cx).head();
            let line_start = Point::new(last_position.row, 0);
            let chars_to_last_position = snapshot
                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
                .chars as u32;

            let last_line = editor
                .buffer()
                .read(cx)
                .excerpts_for_buffer(&active_buffer, cx)
                .into_iter()
                .map(move |(_, range)| text::ToPoint::to_point(&range.context.end, &snapshot).row)
                .max()
                .unwrap_or(0);

            (cursor, last_line, editor.scroll_position(cx))
        });

<|editable_region_end|>
        let line = cursor.row + 1;
        let column = cursor.column + 1;

        let line_editor = cx.new_view(|cx| {
            let mut editor = Editor::single_line(cx);
            // TODO kb wrong column number here
            editor.set_placeholder_text(format!("{line}{FILE_ROW_COLUMN_DELIMITER}{column}"), cx);
            editor
        });
        let line_editor_change = cx.subscribe(&line_editor, Self::on_line_editor_event);

        let current_text = format!(
            "Current Line: {} of {} (column {})",
            line,
            last_line + 1,
```
</output>
<outline>
```crates/go_to_line/src/go_to_line.rs
pub mod cursor_position
pub fn init
pub struct GoToLine
 line_editor
 active_editor
 current_text
 prev_scroll_position
 _subscriptions
impl ModalView for GoToLine
impl FocusableView for GoToLine
 fn focus_handle
impl EventEmitter<DismissEvent> for GoToLine
enum GoToLineRowHighlights
impl GoToLine
 fn register
 pub fn new
 fn release
 fn on_line_editor_event
 fn highlight_current_line
 fn anchor_from_query
  const MAX_BYTES_IN_UTF_8
 fn line_and_char_from_query
 fn cancel
 fn confirm
impl Render for GoToLine
 fn render
mod tests
 async fn test_go_to_line_view_row_highlights
 async fn test_unicode_characters_selection
 async fn test_unicode_line_numbers
 async fn test_go_into_unicode
 fn current_position
 fn user_caret_position
 fn go_to_point
 fn open_go_to_line_view
 fn highlighted_display_rows
 fn assert_single_caret_at_row
 fn init_test
```

</outline>
<rejected>
```crates/go_to_line/src/go_to_line.rs
impl EventEmitter<DismissEvent> for GoToLine {}

enum GoToLineRowHighlights {}

impl GoToLine {
    fn register(editor: &mut Editor, cx: &mut ViewContext<Editor>) {
        let handle = cx.view().downgrade();
        editor
            .register_action(move |_: &editor::actions::ToggleGoToLine, cx| {
                let Some(editor_handle) = handle.upgrade() else {
<|editable_region_start|>
                    return;
                };
                let Some(workspace) = editor_handle.read(cx).workspace() else {
                    return;
                };
                let editor = editor_handle.read(cx);
                let Some((_, buffer, _)) = editor.active_excerpt(cx) else {
                    return;
                };
                workspace.update(cx, |workspace, cx| {
                    workspace.toggle_modal(cx, move |cx| GoToLine::new(editor_handle, buffer, cx));
                })
            })
            .detach();
    }

    pub fn new(
        active_editor: View<Editor>,
        active_buffer: Model<Buffer>,
        cx: &mut ViewContext<Self>,
    ) -> Self {
        let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {
            let snapshot = active_buffer.read(cx).snapshot();
            let last_position = editor.selections.last::<Point>(cx).head();
            let line_start = Point::new(last_position.row, 0);
            let chars_to_last_position = snapshot
                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)
                .chars as u32;

            let last_line = editor
                .buffer()
                .read(cx)
                .excerpts_for_buffer(&active_buffer, cx)
                .into_iter()
                .map(move |(_, range)| text::ToPoint::to_point(&range.context.end, &snapshot).row)
                .max()
                .unwrap_or(0);

            (cursor, last_line, editor.scroll_position(cx))
        });

<|editable_region_end|>
        let line = cursor.row + 1;
        let column = cursor.column + 1;

        let line_editor = cx.new_view(|cx| {
            let mut editor = Editor::single_line(cx);
            // TODO kb wrong column number here
            editor.set_placeholder_text(format!("{line}{FILE_ROW_COLUMN_DELIMITER}{column}"), cx);
            editor
        });
        let line_editor_change = cx.subscribe(&line_editor, Self::on_line_editor_event);

        let current_text = format!(
            "Current Line: {} of {} (column {})",
            line,
            last_line + 1,
```
</rejected>

<labels>
local-edit,unknown
</labels>
