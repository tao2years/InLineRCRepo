<events>

</events>
<input>
```zed/crates/language/src/language_registry.rs
        let tx = fake_entry.tx.clone();
        cx.background_executor()
            .spawn(async move {
                if fake_server
                    .try_receive_notification::<lsp::notification::Initialized>()
                    .await
                    .is_some()
                {
                    tx.unbounded_send(fake_server.clone()).ok();
                }
            })
            .detach();

        Some(server)
<|editable_region_start|>
    }

    pub fn language_server_binary_statuses(
        &self,
    ) -> mpsc::UnboundedReceiver<(LanguageServerName, LanguageServerBinaryStatus)> {
        self.lsp_binary_status_tx.subscribe()
    }

    pub async fn delete_server_container(&self, name: LanguageServerName) {
        log::info!("deleting server container");
        let Some(dir) = self.language_server_download_dir(&name) else {
            return;
        };

        smol::fs::remove_dir_all(dir)
            .await
            .context("server container removal")
            .log_err();
    }
}<|user_cursor_is_here|>

impl LanguageRegistryState {
    fn next_language_server_id(&mut self) -> LanguageServerId {
        LanguageServerId(post_inc(&mut self.next_language_server_id))
    }

    fn add(&mut self, language: Arc<Language>) {
        if let Some(theme) = self.theme.as_ref() {
            language.set_theme(theme.syntax());
        }
        self.language_settings.languages.insert(
            language.name(),
            LanguageSettingsContent {
                tab_size: language.config.tab_size,
                hard_tabs: language.config.hard_tabs,
                soft_wrap: language.config.soft_wrap,
                auto_indent_on_paste: language.config.auto_indent_on_paste,
                ..Default::default()
<|editable_region_end|>
            }
            .clone(),
        );
        self.languages.push(language);
        self.version += 1;
        *self.subscription.0.borrow_mut() = ();
    }

    fn reload(&mut self) {
        self.languages.clear();
        self.version += 1;
        self.reload_count += 1;
        for language in &mut self.available_languages {
            language.loaded = false;
        }
```
</input>
<output>
```zed/crates/language/src/language_registry.rs
        let tx = fake_entry.tx.clone();
        cx.background_executor()
            .spawn(async move {
                if fake_server
                    .try_receive_notification::<lsp::notification::Initialized>()
                    .await
                    .is_some()
                {
                    tx.unbounded_send(fake_server.clone()).ok();
                }
            })
            .detach();

        Some(server)
<|editable_region_start|>
    }

    pub fn language_server_binary_statuses(
        &self,
    ) -> mpsc::UnboundedReceiver<(LanguageServerName, LanguageServerBinaryStatus)> {
        self.lsp_binary_status_tx.subscribe()
    }

    pub async fn delete_server_container(&self, name: LanguageServerName) {
        log::info!("deleting server container");
        let Some(dir) = self.language_server_download_dir(&name) else {
            return;
        };

        smol::fs::remove_dir_all(dir)
            .await
            .context("server container removal")
            .log_err();
    }
}

impl LanguageRegistryState {
    fn next_language_server_id(&mut self) -> LanguageServerId {
        LanguageServerId(post_inc(&mut self.next_language_server_id))
    }

    fn add(&mut self, language: Arc<Language>) {
        if let Some(theme) = self.theme.as_ref() {
            language.set_theme(theme.syntax());
        }
        self.language_settings.languages.insert(
            language.name(),
            LanguageSettingsContent {
                tab_size: language.config.tab_size,
                hard_tabs: language.config.hard_tabs,
                soft_wrap: language.config.soft_wrap,
                auto_indent_on_paste: language.config.auto_indent_on_paste,
                ..Default::default()
<|editable_region_end|>
            }
            .clone(),
        );
        self.languages.push(language);
        self.version += 1;
        *self.subscription.0.borrow_mut() = ();
    }

    fn reload(&mut self) {
        self.languages.clear();
        self.version += 1;
        self.reload_count += 1;
        for language in &mut self.available_languages {
            language.loaded = false;
        }
```
</output>
<outline>
```crates/language/src/language_registry.rs
pub struct LanguageName
impl LanguageName
 pub fn new
 pub fn from_proto
 pub fn to_proto
 pub fn lsp_id
impl From<LanguageName> for SharedString
 fn from
impl AsRef<str> for LanguageName
 fn as_ref
impl Borrow<str> for LanguageName
 fn borrow
impl std::fmt::Display for LanguageName
 fn fmt
impl From<&'a str> for LanguageName
 fn from
impl From<LanguageName> for String
 fn from
pub struct LanguageRegistry
 state
 language_server_download_dir
 executor
 lsp_binary_status_tx
struct LanguageRegistryState
 next_language_server_id
 languages
 language_settings
 available_languages
 grammars
 lsp_adapters
 available_lsp_adapters
 loading_languages
 subscription
 theme
 version
 reload_count
 fake_server_entries
pub struct FakeLanguageServerEntry
 pub capabilities
 pub initializer
 pub tx
 pub _server
pub enum LanguageServerBinaryStatus
 None
 CheckingForUpdate
 Downloading
 Failed
  error
pub struct AvailableLanguage
 id
 name
 grammar
 matcher
 hidden
 load
 loaded
impl AvailableLanguage
 pub fn name
 pub fn matcher
 pub fn hidden
enum AvailableGrammar
 Native
 Loaded
 Loading
 Unloaded
 LoadFailed
pub struct LanguageNotFound
impl std::fmt::Display for LanguageNotFound
 fn fmt
pub const QUERY_FILENAME_PREFIXES
pub struct LanguageQueries
 pub highlights
 pub brackets
 pub indents
 pub outline
 pub embedding
 pub injections
 pub overrides
 pub redactions
 pub runnables
 pub text_objects
struct LspBinaryStatusSender
 txs
pub struct LoadedLanguage
 pub config
 pub queries
 pub context_provider
 pub toolchain_provider
impl LanguageRegistry
 pub fn new
 pub fn test
 pub fn reload
 pub fn reorder_language_servers
 pub fn remove_languages
 pub fn remove_lsp_adapter
 pub fn register_test_language
 pub fn register_available_lsp_adapter
 pub fn load_available_lsp_adapter
 pub fn register_lsp_adapter
 pub fn get_or_register_lsp_adapter
 pub fn register_fake_lsp
 pub fn register_fake_lsp_adapter
 pub fn register_fake_language_server
 pub fn register_language
 pub fn register_native_grammars
 pub fn register_wasm_grammars
 pub fn language_settings
 pub fn language_names
 pub fn grammar_names
 pub fn add
 pub fn subscribe
 pub fn version
 pub fn reload_count
 pub fn set_theme
 pub fn set_language_server_download_dir
 pub fn language_for_name
 pub fn language_for_name_or_extension
 pub fn available_language_for_name
 pub fn language_for_file
 pub fn language_for_file_path
 fn language_for_file_internal
 fn find_matching_language
 pub fn load_language
 fn get_or_load_language
 fn get_or_load_grammar
 pub fn to_vec
 pub fn lsp_adapters
 pub fn update_lsp_status
 pub fn next_language_server_id
 pub fn language_server_download_dir
 pub fn create_fake_language_server
 pub fn language_server_binary_statuses
 pub async fn delete_server_container
impl LanguageRegistryState
 fn next_language_server_id
 fn add
 fn reload
 fn reorder_language_servers
 fn remove_languages
 fn mark_language_loaded
impl LspBinaryStatusSender
 fn subscribe
 fn send
```

</outline>
<rejected>
```zed/crates/language/src/language_registry.rs
        let tx = fake_entry.tx.clone();
        cx.background_executor()
            .spawn(async move {
                if fake_server
                    .try_receive_notification::<lsp::notification::Initialized>()
                    .await
                    .is_some()
                {
                    tx.unbounded_send(fake_server.clone()).ok();
                }
            })
            .detach();

        Some(server)
<|editable_region_start|>
    }

    pub fn language_server_binary_statuses(
        &self,
    ) -> mpsc::UnboundedReceiver<(LanguageServerName, LanguageServerBinaryStatus)> {
        self.lsp_binary_status_tx.subscribe()
    }

    pub async fn delete_server_container(&self, name: LanguageServerName) {
        log::info!("deleting server container");
        let Some(dir) = self.language_server_download_dir(&name) else {
            return;
        };

        smol::fs::remove_dir_all(dir)
            .await
            .context("server container removal")
            .log_err();
    }

    pub async fn delete_server_container(&self, name: LanguageServerName) {
        log::info!("deleting server container");
        let Some(dir) = self.language_server_download_dir(&name) else {
            return;
        };

        smol::fs::remove_dir_all(dir)
            .await
            .context("server container removal")
            .log_err();
    }
}<|editable_region_end|>
            }
            .clone(),
        );
        self.languages.push(language);
        self.version += 1;
        *self.subscription.0.borrow_mut() = ();
    }

    fn reload(&mut self) {
        self.languages.clear();
        self.version += 1;
        self.reload_count += 1;
        for language in &mut self.available_languages {
            language.loaded = false;
        }
```
</rejected>

<labels>
no-op,unknown
</labels>
