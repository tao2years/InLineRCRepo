<events>

</events>
<input>
```zed/crates/text/src/text.rs
impl FromIterator<char> for LineIndent {
    fn from_iter<T: IntoIterator<Item = char>>(chars: T) -> Self {
        let mut tabs = 0;
        let mut spaces = 0;
        let mut line_blank = true;
        for c in chars {
            if c == '\t' {
                tabs += 1;
            } else if c == ' ' {
                spaces += 1;
            } else {
                if c != '\n' {
                    line_blank = false;
                }
                break;
            }
        }
        Self {
            tabs,
            spaces,
            line_blank,
<|editable_region_start|>
        }
    }
}

impl Buffer {
    pub fn new(replica_id: u16, remote_id: BufferId, mut base_text: String) -> Buffer {
        let line_ending = LineEnding::detect(&base_text);
        LineEnding::normalize(&mut base_text);
        Self::new_normalized(replica_id, remote_id, line_ending, Rope::from(base_text))
    }

    pub fn <|user_cursor_is_here|>new_normalized(
        replica_id: u16,
        remote_id: BufferId,
        line_ending: LineEnding,
        normalized: Rope,
    ) -> Buffer {
        let history = History::new(normalized);
        let mut fragments = SumTree::new(&None);
        let mut insertions = SumTree::default();

        let mut lamport_clock = clock::Lamport::new(replica_id);
<|editable_region_end|>
        let mut version = clock::Global::new();

        let visible_text = history.base_text.clone();
        if !visible_text.is_empty() {
            let insertion_timestamp = clock::Lamport {
                replica_id: 0,
                value: 1,
            };
            lamport_clock.observe(insertion_timestamp);
            version.observe(insertion_timestamp);
            let fragment_id = Locator::between(&Locator::min(), &Locator::max());
            let fragment = Fragment {
                id: fragment_id,
                timestamp: insertion_timestamp,
                insertion_offset: 0,
                len: visible_text.len(),
                visible: true,
                deletions: Default::default(),
                max_undos: Default::default(),
            };
            insertions.push(InsertionFragment::new(&fragment), &());
            fragments.push(fragment, &None);
        }
```
</input>
<output>
```zed/crates/text/src/text.rs
impl FromIterator<char> for LineIndent {
    fn from_iter<T: IntoIterator<Item = char>>(chars: T) -> Self {
        let mut tabs = 0;
        let mut spaces = 0;
        let mut line_blank = true;
        for c in chars {
            if c == '\t' {
                tabs += 1;
            } else if c == ' ' {
                spaces += 1;
            } else {
                if c != '\n' {
                    line_blank = false;
                }
                break;
            }
        }
        Self {
            tabs,
            spaces,
            line_blank,
<|editable_region_start|>
        }
    }
}

impl Buffer {
    pub fn new(replica_id: u16, remote_id: BufferId, mut base_text: String) -> Buffer {
        let line_ending = LineEnding::detect(&base_text);
        LineEnding::normalize(&mut base_text);
        Self::new_normalized(replica_id, remote_id, line_ending, Rope::from(base_text))
    }

    pub fn new_normalized(
        replica_id: u16,
        remote_id: BufferId,
        line_ending: LineEnding,
        normalized: Rope,
    ) -> Buffer {
        let history = History::new(normalized);
        let mut fragments = SumTree::new(&None);
        let mut insertions = SumTree::default();

        let mut lamport_clock = clock::Lamport::new(replica_id);
<|editable_region_end|>
        let mut version = clock::Global::new();

        let visible_text = history.base_text.clone();
        if !visible_text.is_empty() {
            let insertion_timestamp = clock::Lamport {
                replica_id: 0,
                value: 1,
            };
            lamport_clock.observe(insertion_timestamp);
            version.observe(insertion_timestamp);
            let fragment_id = Locator::between(&Locator::min(), &Locator::max());
            let fragment = Fragment {
                id: fragment_id,
                timestamp: insertion_timestamp,
                insertion_offset: 0,
                len: visible_text.len(),
                visible: true,
                deletions: Default::default(),
                max_undos: Default::default(),
            };
            insertions.push(InsertionFragment::new(&fragment), &());
            fragments.push(fragment, &None);
        }
```
</output>
<outline>
```crates/text/src/text.rs
mod anchor
pub mod locator
pub mod network
pub mod operation_queue
mod patch
mod selection
pub mod subscription
mod tests
mod undo_map
static LINE_SEPARATORS_REGEX
pub type TransactionId
pub struct Buffer
 snapshot
 history
 deferred_ops
 deferred_replicas
 pub lamport_clock
 subscriptions
 edit_id_resolvers
 wait_for_version_txs
pub struct BufferId
impl Display for BufferId
 fn fmt
impl From<NonZeroU64> for BufferId
 fn from
impl BufferId
 pub fn new
 pub fn next
 pub fn to_proto
impl From<BufferId> for u64
 fn from
pub struct BufferSnapshot
 replica_id
 remote_id
 visible_text
 deleted_text
 line_ending
 undo_map
 fragments
 insertions
 pub version
pub struct HistoryEntry
 transaction
 first_edit_at
 last_edit_at
 suppress_grouping
pub struct Transaction
 pub id
 pub edit_ids
 pub start
impl HistoryEntry
 pub fn transaction_id
struct History
 base_text
 operations
 insertion_slices
 undo_stack
 redo_stack
 transaction_depth
 group_interval
struct InsertionSlice
 insertion_id
 range
impl History
 pub fn new
 fn push
 fn start_transaction
 fn end_transaction
 fn group
 fn group_until
 fn group_trailing
 fn finalize_last_transaction
 fn push_transaction
 fn push_undo
 fn pop_undo
 fn remove_from_undo
 fn remove_from_undo_until
 fn forget
 fn transaction
 fn transaction_mut
 fn merge_transactions
 fn pop_redo
 fn remove_from_redo
struct Edits
 visible_cursor
 deleted_cursor
 fragments_cursor
 undos
 since
 old_end
 new_end
 range
 buffer_id
pub struct Edit
 pub old
 pub new
impl Edit<D>
 pub fn old_len
 pub fn new_len
 pub fn is_empty
impl Edit<(D1, D2)>
 pub fn flatten
pub struct Fragment
 pub id
 pub timestamp
 pub insertion_offset
 pub len
 pub visible
 pub deletions
 pub max_undos
pub struct FragmentSummary
 text
 max_id
 max_version
 min_insertion_version
 max_insertion_version
struct FragmentTextSummary
 visible
 deleted
impl sum_tree::Dimension<'a, FragmentSummary> for FragmentTextSummary
 fn zero
 fn add_summary
struct InsertionFragment
 timestamp
 split_offset
 fragment_id
struct InsertionFragmentKey
 timestamp
 split_offset
pub enum Operation
 Edit
 Undo
pub struct EditOperation
 pub timestamp
 pub version
 pub ranges
 pub new_text
pub struct UndoOperation
 pub timestamp
 pub version
 pub counts
pub struct LineIndent
 pub tabs
 pub spaces
 pub line_blank
impl LineIndent
 pub fn from_chunks
 pub fn spaces
 pub fn tabs
 pub fn is_line_empty
 pub fn is_line_blank
 pub fn raw_len
 pub fn len
impl From<&str> for LineIndent
 fn from
impl FromIterator<char> for LineIndent
 fn from_iter
impl Buffer
 pub fn new
 pub fn new_normalized
 pub fn version
 pub fn snapshot
 pub fn branch
 pub fn replica_id
 pub fn remote_id
 pub fn deferred_ops_len
 pub fn transaction_group_interval
 pub fn edit
 fn apply_local_edit
 pub fn set_line_ending
 pub fn apply_ops
 fn apply_op
 fn apply_remote_edit
 fn fragment_ids_for_edits
 fn apply_undo
 fn flush_deferred_ops
 fn can_apply_op
 pub fn has_deferred_ops
 pub fn peek_undo_stack
 pub fn peek_redo_stack
 pub fn start_transaction
 pub fn start_transaction_at
 pub fn end_transaction
 pub fn end_transaction_at
 pub fn finalize_last_transaction
 pub fn group_until_transaction
 pub fn base_text
 pub fn operations
 pub fn undo
 pub fn undo_transaction
 pub fn undo_to_transaction
 pub fn forget_transaction
 pub fn merge_transactions
 pub fn redo
 pub fn redo_to_transaction
 fn undo_or_redo
 pub fn undo_operations
 pub fn push_transaction
 pub fn edited_ranges_for_transaction_id
 pub fn edited_ranges_for_transaction
 pub fn subscribe
 pub fn wait_for_edits
 pub fn wait_for_anchors
 pub fn wait_for_version
 pub fn give_up_waiting
 fn resolve_edit
impl Buffer
 pub fn edit_via_marked_text
 pub fn edits_for_marked_text
 pub fn check_invariants
 pub fn set_group_interval
 pub fn random_byte_range
 pub fn get_random_edits
 pub fn randomly_edit
 pub fn randomly_undo_redo
impl Deref for Buffer
 type Target
 fn deref
impl BufferSnapshot
 pub fn as_rope
 pub fn rope_for_version
 pub fn remote_id
 pub fn replica_id
 pub fn row_count
 pub fn len
 pub fn is_empty
 pub fn chars
 pub fn chars_for_range
 pub fn reversed_chars_for_range
 pub fn contains_str_at
 pub fn common_prefix_at
 pub fn text
 pub fn line_ending
 pub fn deleted_text
 pub fn fragments
 pub fn text_summary
 pub fn max_point
 pub fn max_point_utf16
 pub fn point_to_offset
 pub fn point_utf16_to_offset
 pub fn unclipped_point_utf16_to_offset
 pub fn unclipped_point_utf16_to_point
 pub fn offset_utf16_to_offset
 pub fn offset_to_offset_utf16
 pub fn offset_to_point
 pub fn offset_to_point_utf16
 pub fn point_to_point_utf16
 pub fn version
 pub fn chars_at
 pub fn reversed_chars_at
 pub fn reversed_chunks_in_range
 pub fn bytes_in_range
 pub fn reversed_bytes_in_range
 pub fn text_for_range
 pub fn line_len
 pub fn line_indents_in_row_range
 pub fn reversed_line_indents_in_row_range
 pub fn line_indent_for_row
 pub fn is_line_blank
 pub fn text_summary_for_range
 pub fn summaries_for_anchors
 pub fn summaries_for_anchors_with_payload
 fn summary_for_anchor
 pub fn offset_for_anchor
 fn fragment_id_for_anchor
 pub fn anchor_before
 pub fn anchor_after
 pub fn anchor_at
 fn anchor_at_offset
 pub fn can_resolve
 pub fn clip_offset
 pub fn clip_point
 pub fn clip_offset_utf16
 pub fn clip_point_utf16
 pub fn edits_since
 pub fn anchored_edits_since
 pub fn edits_since_in_range
 pub fn anchored_edits_since_in_range
 pub fn has_edits_since_in_range
 pub fn has_edits_since
 pub fn range_to_version
 pub fn offsets_to_version
struct RopeBuilder
 old_visible_cursor
 old_deleted_cursor
 new_visible
 new_deleted
impl RopeBuilder<'a>
 fn new
 fn append
 fn push_fragment
 fn push
 fn push_str
 fn finish
impl Iterator for Edits<'a, D, F>
 type Item
 fn next
impl Fragment
 fn insertion_slice
 fn is_visible
 fn was_visible
impl sum_tree::Item for Fragment
 type Summary
 fn summary
impl sum_tree::Summary for FragmentSummary
 type Context
 fn zero
 fn add_summary
impl Default for FragmentSummary
 fn default
impl sum_tree::Item for InsertionFragment
 type Summary
 fn summary
impl sum_tree::KeyedItem for InsertionFragment
 type Key
 fn key
impl InsertionFragment
 fn new
 fn insert_new
impl sum_tree::Summary for InsertionFragmentKey
 type Context
 fn zero
 fn add_summary
pub struct FullOffset
impl ops::AddAssign<usize> for FullOffset
 fn add_assign
impl ops::Add<usize> for FullOffset
 type Output
 fn add
impl ops::Sub for FullOffset
 type Output
 fn sub
impl sum_tree::Dimension<'a, FragmentSummary> for usize
 fn zero
 fn add_summary
impl sum_tree::Dimension<'a, FragmentSummary> for FullOffset
 fn zero
 fn add_summary
impl sum_tree::Dimension<'a, FragmentSummary> for Option<&'a Locator>
 fn zero
 fn add_summary
impl sum_tree::SeekTarget<'a, FragmentSummary, FragmentTextSummary> for usize
 fn cmp
enum VersionedFullOffset
 Offset
 Invalid
impl VersionedFullOffset
 fn full_offset
impl Default for VersionedFullOffset
 fn default
impl sum_tree::Dimension<'a, FragmentSummary> for VersionedFullOffset
 fn zero
 fn add_summary
impl sum_tree::SeekTarget<'a, FragmentSummary, Self> for VersionedFullOffset
 fn cmp
impl Operation
 fn replica_id
 pub fn timestamp
 pub fn as_edit
 pub fn is_edit
impl operation_queue::Operation for Operation
 fn lamport_timestamp
pub trait ToOffset
 fn to_offset
impl ToOffset for Point
 fn to_offset
impl ToOffset for usize
 fn to_offset
impl ToOffset for Anchor
 fn to_offset
impl ToOffset for &'a T
 fn to_offset
impl ToOffset for PointUtf16
 fn to_offset
impl ToOffset for Unclipped<PointUtf16>
 fn to_offset
pub trait ToPoint
 fn to_point
impl ToPoint for Anchor
 fn to_point
impl ToPoint for usize
 fn to_point
impl ToPoint for Point
 fn to_point
impl ToPoint for Unclipped<PointUtf16>
 fn to_point
pub trait ToPointUtf16
 fn to_point_utf16
impl ToPointUtf16 for Anchor
 fn to_point_utf16
impl ToPointUtf16 for usize
 fn to_point_utf16
impl ToPointUtf16 for PointUtf16
 fn to_point_utf16
impl ToPointUtf16 for Point
 fn to_point_utf16
pub trait ToOffsetUtf16
 fn to_offset_utf16
impl ToOffsetUtf16 for Anchor
 fn to_offset_utf16
impl ToOffsetUtf16 for usize
 fn to_offset_utf16
impl ToOffsetUtf16 for OffsetUtf16
 fn to_offset_utf16
pub trait FromAnchor
 fn from_anchor
impl FromAnchor for Anchor
 fn from_anchor
impl FromAnchor for Point
 fn from_anchor
impl FromAnchor for PointUtf16
 fn from_anchor
impl FromAnchor for usize
 fn from_anchor
pub enum LineEnding
 Unix
 Windows
impl Default for LineEnding
 fn default
impl LineEnding
 pub fn as_str
 pub fn detect
 pub fn normalize
 pub fn normalize_arc
 pub fn normalize_cow
```

</outline>
<rejected>
```zed/crates/text/src/text.rs
impl FromIterator<char> for LineIndent {
    fn from_iter<T: IntoIterator<Item = char>>(chars: T) -> Self {
        let mut tabs = 0;
        let mut spaces = 0;
        let mut line_blank = true;
        for c in chars {
            if c == '\t' {
                tabs += 1;
            } else if c == ' ' {
                spaces += 1;
            } else {
                if c != '\n' {
                    line_blank = false;
                }
                break;
            }
        }
        Self {
            tabs,
            spaces,
            line_blank,
<|editable_region_start|>
        }
    }

    pub fn new_normalized(
        replica_id: u16,
        remote_id: BufferId,
        line_ending: LineEnding,
        normalized: Rope,
    ) -> Buffer {
        let history = History::new(normalized);
        let mut fragments = SumTree::new(&None);
        let mut insertions = SumTree::default();

        let mut lamport_clock = clock::Lamport::new(replica_id);
<|editable_region_end|>
        let mut version = clock::Global::new();

        let visible_text = history.base_text.clone();
        if !visible_text.is_empty() {
            let insertion_timestamp = clock::Lamport {
                replica_id: 0,
                value: 1,
            };
            lamport_clock.observe(insertion_timestamp);
            version.observe(insertion_timestamp);
            let fragment_id = Locator::between(&Locator::min(), &Locator::max());
            let fragment = Fragment {
                id: fragment_id,
                timestamp: insertion_timestamp,
                insertion_offset: 0,
                len: visible_text.len(),
                visible: true,
                deletions: Default::default(),
                max_undos: Default::default(),
            };
            insertions.push(InsertionFragment::new(&fragment), &());
            fragments.push(fragment, &None);
        }
```
</rejected>

<labels>
no-op,unknown
</labels>
