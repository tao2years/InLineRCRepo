<events>
User edited "crates/zed/src/zed.rs":
```diff
@@ -245,6 +245,7 @@
 
     cx.observe_flag::<feature_flags::ZedPro, _>({
         move |is_enabled, cx| {
+            C
             CommandPaletteFilter::update_global(cx, |filter, _cx| {
                 if is_enabled {
                     filter.show_action_types(zed_pro_actions.iter());

```
</events>
<input>
```zed/crates/zed/src/zed.rs
        auto_update_ui::notify_of_any_new_update(window, cx);

        let handle = cx.entity().downgrade();
        window.on_window_should_close(cx, move |window, cx| {
<|editable_region_start|>
            handle
                .update(cx, |workspace, cx| {
                    // We'll handle closing asynchronously
                    workspace.close_window(&Default::default(), window, cx);
                    false
                })
                .unwrap_or(true)
        });

        initialize_panels(prompt_builder.clone(), window, cx);
        register_actions(app_state.clone(), workspace, window, cx);

        workspace.focus_handle(cx).focus(window);
    })
    .detach();

    feature_gate_zed_pro_actions(cx);
}

fn feature_gate_zed_pro_actions(cx: &mut App) {
    let zed_pro_actions = [TypeId::of::<OpenAccountSettings>()];

    CommandPaletteFilter::update_global(cx, |filter, _cx| {
        filter.hide_action_types(&zed_pro_actions);
    });

    cx.observe_flag::<feature_flags::ZedPro, _>({
        move |is_enabled, cx| {
            C
            CommandPaletteFilter::update_global(cx, |filter, _cx| {
                if is_enabled {
                    filter.show_action_types(zed_pro_actions.iter());
                } else {
                    filter.hide_action_types(&zed_pro_actions);
                }
            });
        }
    })
    <|user_cursor_is_here|>.detach();
}

#[cfg(any(target_os = "linux", target_os = "freebsd"))]
fn initialize_file_watcher(window: &mut Window, cx: &mut Context<Workspace>) {
    if let Err(e) = fs::fs_watcher::global(|_| {}) {
        let message = format!(
            db::indoc! {r#"
            inotify_init returned {}

            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux
            "#},
            e
        );
        let prompt = window.prompt(
            PromptLevel::Critical,
            "Could not start inotify",
            Some(&message),
            &["Troubleshoot and Quit"],
            cx,
        );
<|editable_region_end|>
        cx.spawn(|_, cx| async move {
            if prompt.await == Ok(0) {
                cx.update(|cx| {
```
</input>
<output>
```zed/crates/zed/src/zed.rs
        auto_update_ui::notify_of_any_new_update(window, cx);

        let handle = cx.entity().downgrade();
        window.on_window_should_close(cx, move |window, cx| {
<|editable_region_start|>
            handle
                .update(cx, |workspace, cx| {
                    // We'll handle closing asynchronously
                    workspace.close_window(&Default::default(), window, cx);
                    false
                })
                .unwrap_or(true)
        });

        initialize_panels(prompt_builder.clone(), window, cx);
        register_actions(app_state.clone(), workspace, window, cx);

        workspace.focus_handle(cx).focus(window);
    })
    .detach();

    feature_gate_zed_pro_actions(cx);
}

fn feature_gate_zed_pro_actions(cx: &mut App) {
    let zed_pro_actions = [TypeId::of::<OpenAccountSettings>()];

    CommandPaletteFilter::update_global(cx, |filter, _cx| {
        filter.hide_action_types(&zed_pro_actions);
    });

    cx.observe_flag::<feature_flags::ZedPro, _>({
        move |is_enabled, cx| {
            CommandPalette
            CommandPaletteFilter::update_global(cx, |filter, _cx| {
                if is_enabled {
                    filter.show_action_types(zed_pro_actions.iter());
                } else {
                    filter.hide_action_types(&zed_pro_actions);
                }
            });
        }
    })
    .detach();
}

#[cfg(any(target_os = "linux", target_os = "freebsd"))]
fn initialize_file_watcher(window: &mut Window, cx: &mut Context<Workspace>) {
    if let Err(e) = fs::fs_watcher::global(|_| {}) {
        let message = format!(
            db::indoc! {r#"
            inotify_init returned {}

            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux
            "#},
            e
        );
        let prompt = window.prompt(
            PromptLevel::Critical,
            "Could not start inotify",
            Some(&message),
            &["Troubleshoot and Quit"],
            cx,
        );
<|editable_region_end|>
        cx.spawn(|_, cx| async move {
            if prompt.await == Ok(0) {
                cx.update(|cx| {
```
</output>
<outline>
```crates/zed/src/zed.rs
mod app_menus
pub mod inline_completion_registry
pub(crate) mod linux_prompts
pub(crate) mod mac_only_instance
mod open_listener
mod quick_action_bar
pub(crate) mod windows_only_instance
pub fn init
pub fn build_window_options
pub fn initialize_workspace
fn feature_gate_zed_pro_actions
fn initialize_file_watcher
fn initialize_file_watcher
fn show_software_emulation_warning_if_needed
fn initialize_panels
fn register_actions
 struct RegisterZedScheme
fn initialize_pane
fn about
fn test_panic
fn install_cli
 const LINUX_PROMPT_DETAIL
 struct InstalledZedCli
fn quit
fn open_log_file
 const MAX_LINES
 struct OpenLogError
pub fn handle_keymap_file_changes
 struct KeymapParseErrorNotification
fn show_keymap_file_json_error
fn show_keymap_file_load_error
fn reload_keymaps
pub fn load_default_keymap
pub fn handle_settings_changed
 struct SettingsParseErrorNotification
pub fn open_new_ssh_project_from_project
fn open_project_settings_file
fn open_project_tasks_file
fn open_local_file
 struct NoOpenFolders
fn open_telemetry_log_file
 async fn fetch_log_string
 const MAX_TELEMETRY_LOG_LEN
fn open_bundled_file
fn open_settings_file
async fn register_zed_scheme
mod tests
 async fn test_open_non_existing_file
 async fn test_open_paths_action
 async fn test_open_add_new
 async fn test_open_file_in_many_spaces
 async fn test_window_edit_state_restoring_disabled
 async fn test_window_edit_state_restoring_enabled
 async fn test_new_empty_workspace
 async fn test_open_entry
 async fn test_open_paths
  fn assert_project_panel_selection
 async fn test_opening_excluded_paths
 async fn test_save_conflicting_item
 async fn test_open_and_save_new_file
 async fn test_setting_language_when_saving_as_single_file_worktree
 async fn test_pane_actions
 async fn test_navigation
  fn active_location
 async fn test_reopening_closed_items
  fn active_path
 fn init_keymap_test
 async fn test_base_keymap
 async fn test_disabled_keymap_binding
 async fn test_generate_keymap_json_schema_for_registered_actions
 async fn test_actions_build_with_empty_input
 fn test_bundled_settings_and_themes
 async fn test_bundled_languages
 pub(crate) fn init_test
 fn init_test_with_state
 fn rust_lang
 fn markdown_language
 fn assert_key_bindings_for
```

</outline>
<rejected>
```zed/crates/zed/src/zed.rs
        auto_update_ui::notify_of_any_new_update(window, cx);

        let handle = cx.entity().downgrade();
        window.on_window_should_close(cx, move |window, cx| {
<|editable_region_start|>
            handle
                .update(cx, |workspace, cx| {
                    // We'll handle closing asynchronously
                    workspace.close_window(&Default::default(), window, cx);
                    false
                })
                .unwrap_or(true)
        });

        initialize_panels(prompt_builder.clone(), window, cx);
        register_actions(app_state.clone(), workspace, window, cx);

        workspace.focus_handle(cx).focus(window);
    })
    .detach();

    feature_gate_zed_pro_actions(cx);
}

fn feature_gate_zed_pro_actions(cx: &mut App) {
    let zed_pro_actions = [TypeId::of::<OpenAccountSettings>()];

    CommandPaletteFilter::update_global(cx, |filter, _cx| {
        filter.hide_action_types(&zed_pro_actions);
    });

    cx.observe_flag::<feature_flags::ZedPro, _>({
        move |is_enabled, cx| {
            CommandPaletteFilter::update_global(cx, |filter, _cx| {
                if is_enabled {
                    filter.show_action_types(zed_pro_actions.iter());
                } else {
                    filter.hide_action_types(&zed_pro_actions);
                }
            });
        }
    })
    .detach();
}

#[cfg(any(target_os = "linux", target_os = "freebsd"))]
fn initialize_file_watcher(window: &mut Window, cx: &mut Context<Workspace>) {
    if let Err(e) = fs::fs_watcher::global(|_| {}) {
        let message = format!(
            db::indoc! {r#"
            inotify_init returned {}

            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux
            "#},
            e
        );
        let prompt = window.prompt(
            PromptLevel::Critical,
            "Could not start inotify",
            Some(&message),
            &["Troubleshoot and Quit"],
            cx,
        );
<|editable_region_end|>
        cx.spawn(|_, cx| async move {
            if prompt.await == Ok(0) {
                cx.update(|cx| {
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
