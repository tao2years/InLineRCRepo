<rating>Negative</rating>
<feedback>Bad completion, the only thing it can suggest is adding `duration_to_millis` above clock_null.</feedback>
<events>
User edited "lib/src/clock.h":
```diff
@@ -21,7 +21,9 @@
   return micros * (uint64_t)frequency.QuadPart / 1000000;
 }
 
-static inline TSDuration duratin_from_millis
+static inline TSDuration duration_from_millis(uint64_t millis) {
+  return duration_from_micros(millis * 1000);
+}
 
 static inline uint64_t duration_to_micros(TSDuration self) {
   LARGE_INTEGER frequency;

```

User edited "lib/src/clock.h":
```diff
@@ -31,6 +31,8 @@
   return self * 1000000 / (uint64_t)frequency.QuadPart;
 }
 
+
+
 static inline TSClock clock_null(void) {
   return 0;
 }

```
</events>
<input>
```lib/src/clock.h
#ifdef _WIN32

// Windows:
<|editable_region_start|>
// * Represent a time as a performance counter value.
// * Represent a duration as a number of performance counter ticks.

#include <windows.h>
typedef uint64_t TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return micros * (uint64_t)frequency.QuadPart / 1000000;
}

static inline TSDuration duration_from_millis(uint64_t millis) {
  return duration_from_micros(millis * 1000);
}

static inline uint64_t duration_to_micros(TSDuration self) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return self * 1000000 / (uint64_t)frequency.QuadPart;
}



static inline TSClock clock_null(void) {
  return 0;
}<|user_cursor_is_here|>

static inline TSClock clock_now(void) {
  LARGE_INTEGER result;
  QueryPerformanceCounter(&result);
  return (uint64_t)result.QuadPart;
}

static inline TSClock clock_after(TSClock base, TSDuration duration) {
  return base + duration;
}

static inline bool clock_is_null(TSClock self) {
  return !self;
}

<|editable_region_end|>
static inline bool clock_is_gt(TSClock self, TSClock other) {
  return self > other;
}

#elif defined(CLOCK_MONOTONIC) && !defined(__APPLE__)

// POSIX with monotonic clock support (Linux)
// * Represent a time as a monotonic (seconds, nanoseconds) pair.
// * Represent a duration as a number of microseconds.
//
// On these platforms, parse timeouts will correspond accurately to
// real time, regardless of what other processes are running.

#include <time.h>
typedef struct timespec TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  return micros;
}

static inline uint64_t duration_to_micros(TSDuration self) {
  return self;
```
</input>
<output>
```lib/src/clock.h
#ifdef _WIN32

// Windows:
<|editable_region_start|>
// * Represent a time as a performance counter value.
// * Represent a duration as a number of performance counter ticks.

#include <windows.h>
typedef uint64_t TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return micros * (uint64_t)frequency.QuadPart / 1000000;
}

static inline TSDuration duration_from_millis(uint64_t millis) {
  return duration_from_micros(millis * 1000);
}

static inline uint64_t duration_to_micros(TSDuration self) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return self * 1000000 / (uint64_t)frequency.QuadPart;
}

static inline uint64_t duration_to_millis(TSDuration self) {
  return duration_to_micros(self) / 1000;
}

static inline TSClock clock_null(void) {
  return 0;
}

static inline TSClock clock_now(void) {
  LARGE_INTEGER result;
  QueryPerformanceCounter(&result);
  return (uint64_t)result.QuadPart;
}

static inline TSClock clock_after(TSClock base, TSDuration duration) {
  return base + duration;
}

static inline bool clock_is_null(TSClock self) {
  return !self;
}

<|editable_region_end|>
static inline bool clock_is_gt(TSClock self, TSClock other) {
  return self > other;
}

#elif defined(CLOCK_MONOTONIC) && !defined(__APPLE__)

// POSIX with monotonic clock support (Linux)
// * Represent a time as a monotonic (seconds, nanoseconds) pair.
// * Represent a duration as a number of microseconds.
//
// On these platforms, parse timeouts will correspond accurately to
// real time, regardless of what other processes are running.

#include <time.h>
typedef struct timespec TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  return micros;
}

static inline uint64_t duration_to_micros(TSDuration self) {
  return self;
```
</output>
<outline>
```lib/src/clock.h
#define TREE_SITTER_CLOCK_H_
typedef TSDuration
typedef TSClock
TSDuration duration_from_micros( )
TSDuration duration_from_millis( )
uint64_t duration_to_micros( )
TSClock clock_null( )
TSClock clock_now( )
TSClock clock_after( )
bool clock_is_null( )
bool clock_is_gt( )
typedef TSClock
 struct timespec
TSDuration duration_from_micros( )
uint64_t duration_to_micros( )
TSClock clock_now( )
TSClock clock_null( )
TSClock clock_after( )
bool clock_is_null( )
bool clock_is_gt( )
typedef TSClock
TSDuration duration_from_micros( )
uint64_t duration_to_micros( )
TSClock clock_null( )
TSClock clock_now( )
TSClock clock_after( )
bool clock_is_null( )
bool clock_is_gt( )
```

</outline>

<labels>
non-local-edit,complete-pattern
</labels>

<rejected>
```lib/src/clock.h
#ifdef _WIN32

// Windows:
<|editable_region_start|>
// * Represent a time as a performance counter value.
// * Represent a duration as a number of performance counter ticks.

#include <windows.h>
typedef uint64_t TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return micros * (uint64_t)frequency.QuadPart / 1000000;
}

static inline TSDuration duration_from_millis(uint64_t millis) {
  return duration_from_micros(millis * 1000);
}

static inline uint64_t duration_to_micros(TSDuration self) {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return self * 1000000 / (uint64_t)frequency.QuadPart;
}

static inline TSDuration duration_from_seconds(uint64_t seconds) {
  return duration_from_micros(seconds * 1000000);
}

static inline uint64_t duration_to_seconds(TSDuration self) {
  return duration_to_micros(self) / 1000000;
}



static inline TSClock clock_null(void) {
  return 0;
}<|editable_region_end|>
static inline bool clock_is_gt(TSClock self, TSClock other) {
  return self > other;
}

#elif defined(CLOCK_MONOTONIC) && !defined(__APPLE__)

// POSIX with monotonic clock support (Linux)
// * Represent a time as a monotonic (seconds, nanoseconds) pair.
// * Represent a duration as a number of microseconds.
//
// On these platforms, parse timeouts will correspond accurately to
// real time, regardless of what other processes are running.

#include <time.h>
typedef struct timespec TSClock;

static inline TSDuration duration_from_micros(uint64_t micros) {
  return micros;
}

static inline uint64_t duration_to_micros(TSDuration self) {
  return self;
```
</rejected>
