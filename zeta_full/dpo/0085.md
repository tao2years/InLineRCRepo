<events>
User edited "crates/editor/src/movement.rs":
```diff
@@ -471,7 +471,6 @@
     for ch in map.buffer_snapshot.chars_at(offset) {
         if let Some(prev_ch) = prev_ch {
             if is_boundary(prev_ch, ch) {
-                dbg!()
                 if return_point_before_boundary {
                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                 } else {

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -470,7 +470,7 @@
 
     for ch in map.buffer_snapshot.chars_at(offset) {
         if let Some(prev_ch) = prev_ch {
-            if is_boundary(prev_ch, ch) {
+            if dbg!(is_boundary(prev_ch, ch) {
                 if return_point_before_boundary {
                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                 } else {

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -470,7 +470,7 @@
 
     for ch in map.buffer_snapshot.chars_at(offset) {
         if let Some(prev_ch) = prev_ch {
-            if dbg!(is_boundary(prev_ch, ch) {
+            if dbg!(is_boundary(prev_ch, ch)) {
                 if return_point_before_boundary {
                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                 } else {

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -482,9 +482,6 @@
         offset += ch.len_utf8();
         prev_ch = Some(ch);
 
-        if find_range == FindRange::SingleLine && ch == '\n' {
-            break;
-        }
     }
     map.clip_point(offset.to_display_point(map), Bias::Right)
 }

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -469,6 +469,9 @@
     let mut prev_ch = None;
 
     for ch in map.buffer_snapshot.chars_at(offset) {
+        if find_range == FindRange::SingleLine && ch == '\n' {
+                    break;
+                }
         if let Some(prev_ch) = prev_ch {
             if dbg!(is_boundary(prev_ch, ch)) {
                 if return_point_before_boundary {

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -471,7 +471,7 @@
     for ch in map.buffer_snapshot.chars_at(offset) {
         if find_range == FindRange::SingleLine && ch == '\n' {
                     break;
-                }
+        }
         if let Some(prev_ch) = prev_ch {
             if dbg!(is_boundary(prev_ch, ch)) {
                 if return_point_before_boundary {

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -470,7 +470,8 @@
 
     for ch in map.buffer_snapshot.chars_at(offset) {
         if find_range == FindRange::SingleLine && ch == '\n' {
-                    break;
+            if
+            break;
         }
         if let Some(prev_ch) = prev_ch {
             if dbg!(is_boundary(prev_ch, ch)) {

```
</events>
<input>
```zed-git/crates/editor/src/movement.rs
pub fn find_preceding_boundary_display_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
<|editable_region_start|>
    find_range: FindRange,
    is_boundary: impl FnMut(char, char) -> bool,
) -> DisplayPoint {
    let result = find_preceding_boundary_point(
        &map.buffer_snapshot,
        from.to_point(map),
        find_range,
        is_boundary,
    );
    map.clip_point(result.to_display_point(map), Bias::Left)
}

/// Scans for a boundary following the given start point until a boundary is found, indicated by the
/// given predicate returning true. The predicate is called with the character to the left and right
/// of the candidate boundary location, and will be called with `\n` characters indicating the start
/// or end of a line. The function supports optionally returning the point just before the boundary
/// is found via return_point_before_boundary.
pub fn find_boundary_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
    find_range: FindRange,
    mut is_boundary: impl FnMut(char, char) -> bool,
    return_point_before_boundary: bool,
) -> DisplayPoint {
    let mut offset = from.to_offset(map, Bias::Right);
    let mut prev_offset = offset;
    let mut prev_ch = None;

    for ch in map.buffer_snapshot.chars_at(offset) {
        if find_range == FindRange::SingleLine && ch == '\n' {
            if<|user_cursor_is_here|>
            break;
        }
        if let Some(prev_ch) = prev_ch {
            if dbg!(is_boundary(prev_ch, ch)) {
                if return_point_before_boundary {
                    return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                } else {
                    break;
                }
            }
        }
        prev_offset = offset;
        offset += ch.len_utf8();
        prev_ch = Some(ch);

    }
    map.clip_point(offset.to_display_point(map), Bias::Right)
}

pub fn find_preceding_boundary_trail(
    map: &DisplaySnapshot,
    head: DisplayPoint,
    mut is_boundary: impl FnMut(char, char) -> bool,
) -> (Option<DisplayPoint>, DisplayPoint) {
    let mut offset = head.to_offset(map, Bias::Left);
    let mut trail_offset = None;
<|editable_region_end|>

    let mut prev_ch = map.buffer_snapshot.chars_at(offset).next();
    let mut forward = map.buffer_snapshot.reversed_chars_at(offset).peekable();

    // Skip newlines
    while let Some(&ch) = forward.peek() {
        if ch == '\n' {
```
</input>
<output>
```zed-git/crates/editor/src/movement.rs
pub fn find_preceding_boundary_display_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
<|editable_region_start|>
    find_range: FindRange,
    is_boundary: impl FnMut(char, char) -> bool,
) -> DisplayPoint {
    let result = find_preceding_boundary_point(
        &map.buffer_snapshot,
        from.to_point(map),
        find_range,
        is_boundary,
    );
    map.clip_point(result.to_display_point(map), Bias::Left)
}

/// Scans for a boundary following the given start point until a boundary is found, indicated by the
/// given predicate returning true. The predicate is called with the character to the left and right
/// of the candidate boundary location, and will be called with `\n` characters indicating the start
/// or end of a line. The function supports optionally returning the point just before the boundary
/// is found via return_point_before_boundary.
pub fn find_boundary_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
    find_range: FindRange,
    mut is_boundary: impl FnMut(char, char) -> bool,
    return_point_before_boundary: bool,
) -> DisplayPoint {
    let mut offset = from.to_offset(map, Bias::Right);
    let mut prev_offset = offset;
    let mut prev_ch = None;

    for ch in map.buffer_snapshot.chars_at(offset) {
        if find_range == FindRange::SingleLine && ch == '\n' {
            if dbg!(is_boundary(prev_ch, ch)) {
            }
            break;
        }
        if let Some(prev_ch) = prev_ch {
            if dbg!(is_boundary(prev_ch, ch)) {
                if return_point_before_boundary {
                    return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                } else {
                    break;
                }
            }
        }
        prev_offset = offset;
        offset += ch.len_utf8();
        prev_ch = Some(ch);

    }
    map.clip_point(offset.to_display_point(map), Bias::Right)
}

pub fn find_preceding_boundary_trail(
    map: &DisplaySnapshot,
    head: DisplayPoint,
    mut is_boundary: impl FnMut(char, char) -> bool,
) -> (Option<DisplayPoint>, DisplayPoint) {
    let mut offset = head.to_offset(map, Bias::Left);
    let mut trail_offset = None;
<|editable_region_end|>

    let mut prev_ch = map.buffer_snapshot.chars_at(offset).next();
    let mut forward = map.buffer_snapshot.reversed_chars_at(offset).peekable();

    // Skip newlines
    while let Some(&ch) = forward.peek() {
        if ch == '\n' {
```
</output>
<outline>
```crates/editor/src/movement.rs
pub enum FindRange
 SingleLine
 MultiLine
pub struct TextLayoutDetails
 pub(crate) text_system
 pub(crate) editor_style
 pub(crate) rem_size
 pub scroll_anchor
 pub visible_rows
 pub vertical_scroll_margin
pub fn left
pub fn saturating_left
pub fn right
pub fn saturating_right
pub fn up
pub fn down
pub(crate) fn up_by_rows
pub(crate) fn down_by_rows
pub fn line_beginning
pub fn indented_line_beginning
pub fn line_end
pub fn previous_word_start
pub fn previous_word_start_or_newline
pub fn previous_subword_start
pub fn next_word_end
pub fn next_word_end_or_newline
pub fn next_subword_end
pub fn start_of_paragraph
pub fn end_of_paragraph
pub fn find_preceding_boundary_point
pub fn find_preceding_boundary_display_point
pub fn find_boundary_point
pub fn find_preceding_boundary_trail
pub fn find_boundary_trail
pub fn find_boundary
pub fn find_boundary_exclusive
pub fn chars_after
pub fn chars_before
pub(crate) fn is_inside_word
pub(crate) fn surrounding_word
pub fn split_display_range_by_lines
mod tests
 fn test_previous_word_start
  fn assert
 fn test_previous_subword_start
  fn assert
 fn test_find_preceding_boundary
  fn assert
 fn test_find_preceding_boundary_with_inlays
 fn test_next_word_end
  fn assert
 fn test_next_subword_end
  fn assert
 fn test_find_boundary
  fn assert
 fn test_surrounding_word
  fn assert
 async fn test_move_up_and_down_with_excerpts
 fn init_test
```

</outline>
<rejected>
```zed-git/crates/editor/src/movement.rs
pub fn find_preceding_boundary_display_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
<|editable_region_start|>
    find_range: FindRange,
    is_boundary: impl FnMut(char, char) -> bool,
) -> DisplayPoint {
    let result = find_preceding_boundary_point(
        &map.buffer_snapshot,
        from.to_point(map),
        find_range,
        is_boundary,
    );
    map.clip_point(result.to_display_point(map), Bias::Left)
}

/// Scans for a boundary following the given start point until a boundary is found, indicated by the
/// given predicate returning true. The predicate is called with the character to the left and right
/// of the candidate boundary location, and will be called with `\n` characters indicating the start
/// or end of a line. The function supports optionally returning the point just before the boundary
/// is found via return_point_before_boundary.
pub fn find_boundary_point(
    map: &DisplaySnapshot,
    from: DisplayPoint,
    find_range: FindRange,
    mut is_boundary: impl FnMut(char, char) -> bool,
    return_point_before_boundary: bool,
) -> DisplayPoint {
    let mut offset = from.to_offset(map, Bias::Right);
    let mut prev_offset = offset;
    let mut prev_ch = None;

    for ch in map.buffer_snapshot.chars_at(offset) {
        if find_range == FindRange::SingleLine && ch == '\n' {
            break;
        }
        if let Some(prev_ch) = prev_ch {
            if is_boundary(prev_ch, ch) {
                if return_point_before_boundary {
                    return map.clip_point(prev_offset.to_display_point(map), Bias::Right);
                } else {
                    break;
                }
            }
        }
        prev_offset = offset;
        offset += ch.len_utf8();
        prev_ch = Some(ch);

    }
    map.clip_point(offset.to_display_point(map), Bias::Right)
}

pub fn find_preceding_boundary_trail(
    map: &DisplaySnapshot,
    head: DisplayPoint,
    mut is_boundary: impl FnMut(char, char) -> bool,
) -> (Option<DisplayPoint>, DisplayPoint) {
    let mut offset = head.to_offset(map, Bias::Left);
    let mut trail_offset = None;
<|editable_region_end|>

    let mut prev_ch = map.buffer_snapshot.chars_at(offset).next();
    let mut forward = map.buffer_snapshot.reversed_chars_at(offset).peekable();

    // Skip newlines
    while let Some(&ch) = forward.peek() {
        if ch == '\n' {
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
