<events>
User edited "crates/language/src/language.rs":
```diff
@@ -1462,7 +1462,7 @@
         self.config
             .code_fence_block_name
             .clone()
-            .unwrap_or_else(|| self.config.name.0.to_lowercase().into())
+            .unwrap_or_else(|| self.config.name.as_ref().to_lowercase().into())
     }
 
     pub fn context_provider(&self) -> Option<Arc<dyn ContextProvider>> {

```

User edited "crates/language/src/language_registry.rs":
```diff
@@ -669,7 +669,7 @@
                 .iter()
                 .any(|suffix| path_suffixes.contains(&Some(suffix.as_str())));
             let custom_suffixes = user_file_types
-                .and_then(|types| types.get(&language_name.0))
+                .and_then(|types| types.get(language_name.as_ref()))
                 .unwrap_or(&empty);
             let path_matches_custom_suffix = path_suffixes
                 .iter()

```

User edited "crates/project/src/project.rs":
```diff
@@ -2579,7 +2579,7 @@
         language_name: LanguageName,
     ) -> Option<SharedString> {
         languages
-            .language_for_name(&language_name.0)
+            .language_for_name(&language_name)
             .await
             .ok()?
             .toolchain_lister()

```

User edited "crates/project/src/project.rs":
```diff
@@ -2579,7 +2579,7 @@
         language_name: LanguageName,
     ) -> Option<SharedString> {
         languages
-            .language_for_name(&language_name)
+            .language_for_name(language_name.as_ref())
             .await
             .ok()?
             .toolchain_lister()

```

User edited "crates/project/src/task_inventory.rs":
```diff
@@ -53,7 +53,7 @@
         abs_path: PathBuf,
     },
     /// Languages-specific tasks coming from extensions.
-    Language { name: Arc<str> },
+    Language { name: SharedString },
 }
 
 impl TaskSourceKind {

```

User edited "crates/project/src/task_inventory.rs":
```diff
@@ -91,7 +91,7 @@
         cx: &App,
     ) -> Vec<(TaskSourceKind, TaskTemplate)> {
         let task_source_kind = language.as_ref().map(|language| TaskSourceKind::Language {
-            name: language.name().0,
+            name: language.name().into(),
         });
         let global_tasks = self.global_templates_from_settings();
         let language_tasks = language

```

User edited "crates/project/src/task_inventory.rs":
```diff
@@ -124,7 +124,7 @@
             .as_ref()
             .and_then(|location| location.buffer.read(cx).language_at(location.range.start));
         let task_source_kind = language.as_ref().map(|language| TaskSourceKind::Language {
-            name: language.name().0,
+            name: language.name().into(),
         });
         let file = location
             .as_ref()

```

User edited "crates/project/src/task_inventory.rs":
```diff
@@ -10,7 +10,7 @@
 
 use anyhow::{Context as _, Result};
 use collections::{HashMap, HashSet, VecDeque};
-use gpui::{App, AppContext as _, Entity, Task};
+use gpui::{App, AppContext as _, Entity, SharedString, Task};
 use itertools::Itertools;
 use language::{ContextProvider, File, Language, LanguageToolchainStore, Location};
 use settings::{parse_json_with_comments, SettingsLocation};

```

User edited "crates/project/src/toolchain_store.rs":
```diff
@@ -316,7 +316,7 @@
 
             cx.background_executor()
                 .spawn(async move {
-                    let language = registry.language_for_name(&language_name.).await.ok()?;
+                    let language = registry.language_for_name(&language_name.as_ref()).await.ok()?;
                     let toolchains = language.toolchain_lister()?;
                     Some(toolchains.list(root.to_path_buf(), project_env).await)
                 })

```

User edited "crates/project/src/toolchain_store.rs":
```diff
@@ -316,7 +316,10 @@
 
             cx.background_executor()
                 .spawn(async move {
-                    let language = registry.language_for_name(&language_name.as_ref()).await.ok()?;
+                    let language = registry
+                        .language_for_name(language_name.as_ref())
+                        .await
+                        .ok()?;
                     let toolchains = language.toolchain_lister()?;
                     Some(toolchains.list(root.to_path_buf(), project_env).await)
                 })

```

User edited "crates/workspace/src/persistence.rs":
```diff
@@ -1088,7 +1088,7 @@
                 .context("Preparing insertion")?;
 
             let toolchain: Vec<(String, String, String)> =
-                select((workspace_id, language_name.0.to_owned(), worktree_id.to_usize()))?;
+                select((workspace_id, language_name.as_ref().to_string(), worktree_id.to_usize()))?;
 
             Ok(toolchain.into_iter().next().and_then(|(name, path, raw_json)| Some(Toolchain {
                 name: name.into(),

```

User edited "crates/language_selector/src/language_selector.rs":
```diff
@@ -154,7 +154,7 @@
             let language_name = LanguageName::new(mat.string.as_str());
             match self
                 .language_registry
-                .available_language_for_name(&language_name.)
+                .available_language_for_name(&language_name.as_ref())
             {
                 Some(available_language) => {
                     let icon = self.language_icon(available_language.matcher(), cx);

```

User edited "crates/language_selector/src/language_selector.rs":
```diff
@@ -154,7 +154,7 @@
             let language_name = LanguageName::new(mat.string.as_str());
             match self
                 .language_registry
-                .available_language_for_name(&language_name.as_ref())
+                .available_language_for_name(language_name.as_ref())
             {
                 Some(available_language) => {
                     let icon = self.language_icon(available_language.matcher(), cx);

```
</events>
<input>
```crates/language_tools/src/syntax_tree_view.rs
                                    view.select_layer(layer_ix, window, cx);
                                }),
                            );
                        }
                        menu
                    })
                    .into()
                }),
        )
    }

    fn select_layer(
        &mut self,
        layer_ix: usize,
<|editable_region_start|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Option<()> {
        let tree_view = self.tree_view.as_ref()?;
        tree_view.update(cx, |view, cx| {
            let editor_state = view.editor.as_mut()?;
            let buffer_state = editor_state.active_buffer.as_mut()?;
            let snapshot = buffer_state.buffer.read(cx).snapshot();
            let layer = snapshot.syntax_layers().nth(layer_ix)?;
            buffer_state.active_layer = Some(layer.to_owned());
            view.selected_descendant_ix = None;
            cx.notify();
            view.focus_handle.focus(window);
            Some(())
        })
    }

    fn render_header(active_layer: &OwnedSyntaxLayer) -> ButtonLike {
        ButtonLike::new("syntax tree header")
            .child(Label::new(active_layer.language.name().))
            .child(Label::new(format_node_range(active_layer.node())))
    }
}<|user_cursor_is_here|>

fn format_node_range(node: Node) -> String {
    let start = node.start_position();
<|editable_region_end|>
    let end = node.end_position();
    format!(
        "[{}:{} - {}:{}]",
        start.row + 1,
        start.column + 1,
        end.row + 1,
        end.column + 1,
    )
}

impl Render for SyntaxTreeToolbarItemView {
    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        self.render_menu(cx)
            .unwrap_or_else(|| PopoverMenu::new("Empty Syntax Tree"))
    }
}

impl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView {}

impl ToolbarItemView for SyntaxTreeToolbarItemView {
    fn set_active_pane_item(
        &mut self,
        active_pane_item: Option<&dyn ItemHandle>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> ToolbarItemLocation {
        if let Some(item) = active_pane_item {
```
</input>
<output>
```crates/language_tools/src/syntax_tree_view.rs
                                    view.select_layer(layer_ix, window, cx);
                                }),
                            );
                        }
                        menu
                    })
                    .into()
                }),
        )
    }

    fn select_layer(
        &mut self,
        layer_ix: usize,
<|editable_region_start|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Option<()> {
        let tree_view = self.tree_view.as_ref()?;
        tree_view.update(cx, |view, cx| {
            let editor_state = view.editor.as_mut()?;
            let buffer_state = editor_state.active_buffer.as_mut()?;
            let snapshot = buffer_state.buffer.read(cx).snapshot();
            let layer = snapshot.syntax_layers().nth(layer_ix)?;
            buffer_state.active_layer = Some(layer.to_owned());
            view.selected_descendant_ix = None;
            cx.notify();
            view.focus_handle.focus(window);
            Some(())
        })
    }

    fn render_header(active_layer: &OwnedSyntaxLayer) -> ButtonLike {
        ButtonLike::new("syntax tree header")
            .child(Label::new(active_layer.language.name().as_ref()))
            .child(Label::new(format_node_range(active_layer.node())))
    }
}

fn format_node_range(node: Node) -> String {
    let start = node.start_position();
<|editable_region_end|>
    let end = node.end_position();
    format!(
        "[{}:{} - {}:{}]",
        start.row + 1,
        start.column + 1,
        end.row + 1,
        end.column + 1,
    )
}

impl Render for SyntaxTreeToolbarItemView {
    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        self.render_menu(cx)
            .unwrap_or_else(|| PopoverMenu::new("Empty Syntax Tree"))
    }
}

impl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView {}

impl ToolbarItemView for SyntaxTreeToolbarItemView {
    fn set_active_pane_item(
        &mut self,
        active_pane_item: Option<&dyn ItemHandle>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> ToolbarItemLocation {
        if let Some(item) = active_pane_item {
```
</output>
<outline>
```crates/language_tools/src/syntax_tree_view.rs
pub fn init
pub struct SyntaxTreeView
 workspace_handle
 editor
 list_scroll_handle
 selected_descendant_ix
 hovered_descendant_ix
 focus_handle
pub struct SyntaxTreeToolbarItemView
 tree_view
 subscription
struct EditorState
 editor
 active_buffer
 _subscription
struct BufferState
 buffer
 excerpt_id
 active_layer
impl SyntaxTreeView
 pub fn new
 fn workspace_updated
 fn set_editor
 fn editor_updated
 fn update_editor_with_range_for_descendant_ix
 fn render_node
impl Render for SyntaxTreeView
 fn render
impl EventEmitter<()> for SyntaxTreeView
impl Focusable for SyntaxTreeView
 fn focus_handle
impl Item for SyntaxTreeView
 type Event
 fn to_item_events
 fn tab_content_text
 fn telemetry_event_text
 fn clone_on_split
impl Default for SyntaxTreeToolbarItemView
 fn default
impl SyntaxTreeToolbarItemView
 pub fn new
 fn render_menu
 fn select_layer
 fn render_header
fn format_node_range
impl Render for SyntaxTreeToolbarItemView
 fn render
impl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView
impl ToolbarItemView for SyntaxTreeToolbarItemView
 fn set_active_pane_item
```

</outline>
<rejected>
```crates/language_tools/src/syntax_tree_view.rs
                                    view.select_layer(layer_ix, window, cx);
                                }),
                            );
                        }
                        menu
                    })
                    .into()
                }),
        )
    }

    fn select_layer(
        &mut self,
        layer_ix: usize,
<|editable_region_start|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Option<()> {
        let tree_view = self.tree_view.as_ref()?;
        tree_view.update(cx, |view, cx| {
            let editor_state = view.editor.as_mut()?;
            let buffer_state = editor_state.active_buffer.as_mut()?;
            let snapshot = buffer_state.buffer.read(cx).snapshot();
            let layer = snapshot.syntax_layers().nth(layer_ix)?;
            buffer_state.active_layer = Some(layer.to_owned());
            view.selected_descendant_ix = None;
            cx.notify();
            view.focus_handle.focus(window);
            Some(())
        })
    }

    fn render_header(active_layer: &OwnedSyntaxLayer) -> ButtonLike {
        ButtonLike::new("syntax tree header")
            .child(Label::new(active_layer.language.name().as_ref()))
            .child(Label::new(format_node_range(active_layer.node())))
    }
}<|editable_region_end|>
    let end = node.end_position();
    format!(
        "[{}:{} - {}:{}]",
        start.row + 1,
        start.column + 1,
        end.row + 1,
        end.column + 1,
    )
}

impl Render for SyntaxTreeToolbarItemView {
    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        self.render_menu(cx)
            .unwrap_or_else(|| PopoverMenu::new("Empty Syntax Tree"))
    }
}

impl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView {}

impl ToolbarItemView for SyntaxTreeToolbarItemView {
    fn set_active_pane_item(
        &mut self,
        active_pane_item: Option<&dyn ItemHandle>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> ToolbarItemLocation {
        if let Some(item) = active_pane_item {
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
