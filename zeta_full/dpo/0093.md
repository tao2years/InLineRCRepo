<events>
User edited "crates/zeta/src/input_excerpt.rs":
```diff
@@ -23,7 +23,7 @@
 
     while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {
         let parent_tokens = tokens_for_bytes(parent.byte_range().len());
-        if 
+        if parent.byte
         if parent_tokens <= editable_region_token_limit {
             scope_range = Point::new(
                 parent.start_position().row as u32,

```
</events>
<input>
```zed/crates/zeta/src/input_excerpt.rs
<|start_of_file|>
use crate::{
    tokens_for_bytes, CURSOR_MARKER, EDITABLE_REGION_END_MARKER, EDITABLE_REGION_START_MARKER,
    START_OF_FILE_MARKER,
};
use language::{BufferSnapshot, Point};
use std::{fmt::Write, ops::Range};

pub struct InputExcerpt {
    pub editable_range: Range<Point>,
<|editable_region_start|>
    pub prompt: String,
    pub speculated_output: String,
}

pub fn excerpt_for_cursor_position(
    position: Point,
    path: &str,
    snapshot: &BufferSnapshot,
    editable_region_token_limit: usize,
    context_token_limit: usize,
) -> InputExcerpt {
    let mut scope_range = position..position;
    let mut remaining_edit_tokens = editable_region_token_limit;

    while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {
        let parent_tokens = tokens_for_bytes(parent.byte_range().len());
        if parent.byte<|user_cursor_is_here|>
        if parent_tokens <= editable_region_token_limit {
            scope_range = Point::new(
                parent.start_position().row as u32,
                parent.start_position().column as u32,
            )
                ..Point::new(
                    parent.end_position().row as u32,
                    parent.end_position().column as u32,
                );
            remaining_edit_tokens = editable_region_token_limit - parent_tokens;
        } else {
            break;
<|editable_region_end|>
        }
    }

    let editable_range = expand_range(snapshot, scope_range, remaining_edit_tokens);
    let context_range = expand_range(snapshot, editable_range.clone(), context_token_limit);

    let mut prompt = String::new();
    let mut speculated_output = String::new();

    writeln!(&mut prompt, "```{path}").unwrap();
    if context_range.start == Point::zero() {
        writeln!(&mut prompt, "{START_OF_FILE_MARKER}").unwrap();
    }

    for chunk in snapshot.chunks(context_range.start..editable_range.start, false) {
        prompt.push_str(chunk.text);
    }

    push_editable_range(position, snapshot, editable_range.clone(), &mut prompt);
    push_editable_range(
        position,
        snapshot,
        editable_range.clone(),
        &mut speculated_output,
    );

    for chunk in snapshot.chunks(editable_range.end..context_range.end, false) {
        prompt.push_str(chunk.text);
```
</input>
<output>
```zed/crates/zeta/src/input_excerpt.rs
<|start_of_file|>
use crate::{
    tokens_for_bytes, CURSOR_MARKER, EDITABLE_REGION_END_MARKER, EDITABLE_REGION_START_MARKER,
    START_OF_FILE_MARKER,
};
use language::{BufferSnapshot, Point};
use std::{fmt::Write, ops::Range};

pub struct InputExcerpt {
    pub editable_range: Range<Point>,
<|editable_region_start|>
    pub prompt: String,
    pub speculated_output: String,
}

pub fn excerpt_for_cursor_position(
    position: Point,
    path: &str,
    snapshot: &BufferSnapshot,
    editable_region_token_limit: usize,
    context_token_limit: usize,
) -> InputExcerpt {
    let mut scope_range = position..position;
    let mut remaining_edit_tokens = editable_region_token_limit;

    while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {
        let parent_tokens = tokens_for_bytes(parent.byte_range().len());
        if parent.byte_range() == scope_range {
            
        } else if parent_tokens <= editable_region_token_limit {
            scope_range = Point::new(
                parent.start_position().row as u32,
                parent.start_position().column as u32,
            )
                ..Point::new(
                    parent.end_position().row as u32,
                    parent.end_position().column as u32,
                );
            remaining_edit_tokens = editable_region_token_limit - parent_tokens;
        } else {
            break;
<|editable_region_end|>
        }
    }

    let editable_range = expand_range(snapshot, scope_range, remaining_edit_tokens);
    let context_range = expand_range(snapshot, editable_range.clone(), context_token_limit);

    let mut prompt = String::new();
    let mut speculated_output = String::new();

    writeln!(&mut prompt, "```{path}").unwrap();
    if context_range.start == Point::zero() {
        writeln!(&mut prompt, "{START_OF_FILE_MARKER}").unwrap();
    }

    for chunk in snapshot.chunks(context_range.start..editable_range.start, false) {
        prompt.push_str(chunk.text);
    }

    push_editable_range(position, snapshot, editable_range.clone(), &mut prompt);
    push_editable_range(
        position,
        snapshot,
        editable_range.clone(),
        &mut speculated_output,
    );

    for chunk in snapshot.chunks(editable_range.end..context_range.end, false) {
        prompt.push_str(chunk.text);
```
</output>
<outline>
```crates/zeta/src/input_excerpt.rs
pub struct InputExcerpt
 pub editable_range
 pub prompt
 pub speculated_output
pub fn excerpt_for_cursor_position
fn push_editable_range
fn expand_range
mod tests
 fn test_excerpt_for_cursor_position
 fn rust_lang
```

</outline>
<rejected>
```zed/crates/zeta/src/input_excerpt.rs
<|start_of_file|>
use crate::{
    tokens_for_bytes, CURSOR_MARKER, EDITABLE_REGION_END_MARKER, EDITABLE_REGION_START_MARKER,
    START_OF_FILE_MARKER,
};
use language::{BufferSnapshot, Point};
use std::{fmt::Write, ops::Range};

pub struct InputExcerpt {
    pub editable_range: Range<Point>,
<|editable_region_start|>
    pub prompt: String,
    pub speculated_output: String,
}

pub fn excerpt_for_cursor_position(
    position: Point,
    path: &str,
    snapshot: &BufferSnapshot,
    editable_region_token_limit: usize,
    context_token_limit: usize,
) -> InputExcerpt {
    let mut scope_range = position..position;
    let mut remaining_edit_tokens = editable_region_token_limit;

    while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {
        let parent_tokens = tokens_for_bytes(parent.byte_range().len());
        if parent_tokens <= editable_region_token_limit {
            scope_range = Point::new(
                parent.start_position().row as u32,
                parent.start_position().column as u32,
            )
                ..Point::new(
                    parent.end_position().row as u32,
                    parent.end_position().column as u32,
                );
            remaining_edit_tokens = editable_region_token_limit - parent_tokens;
        } else {
            break;
<|editable_region_end|>
        }
    }

    let editable_range = expand_range(snapshot, scope_range, remaining_edit_tokens);
    let context_range = expand_range(snapshot, editable_range.clone(), context_token_limit);

    let mut prompt = String::new();
    let mut speculated_output = String::new();

    writeln!(&mut prompt, "```{path}").unwrap();
    if context_range.start == Point::zero() {
        writeln!(&mut prompt, "{START_OF_FILE_MARKER}").unwrap();
    }

    for chunk in snapshot.chunks(context_range.start..editable_range.start, false) {
        prompt.push_str(chunk.text);
    }

    push_editable_range(position, snapshot, editable_range.clone(), &mut prompt);
    push_editable_range(
        position,
        snapshot,
        editable_range.clone(),
        &mut speculated_output,
    );

    for chunk in snapshot.chunks(editable_range.end..context_range.end, false) {
        prompt.push_str(chunk.text);
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
