<events>
User edited "packages/server/src/nft/index.ts":
```diff
@@ -152,35 +152,6 @@
       }
     }),
 
-  check_wallet_in_snapshot_id: baseProcedure
-    .input(
-      z.object({
-        snapshot_id: z.number(),
-      })
-    )
-    .query(async ({ input }) => {
-      const twitter_authed = await verify_twitter();
-      if (!twitter_authed) throw new Error("No Twitter account");
-
-      try {
-        const result = await db.sql<
-          s.nft_snapshot_user.SQL,
-          { total_nft_count: number }[]
-        >`
-              SELECT COALESCE(SUM(nsu.nft_count), 0) as total_nft_count
-              FROM linked_wallets lw
-              JOIN nft_snapshot_user nsu
-                ON nsu.user_address = lw.wallet_base58
-              WHERE lw.user_id = ${db.param(twitter_authed.user_id)}
-                AND nsu.nft_snapshot_id = ${db.param(input.snapshot_id)}
-            `.run(pool);
-
-        return result[0]?.total_nft_count ?? 0;
-      } catch (e) {
-        console.error(e);
-        return 0;
-      }
-    }),
 
   get_snapshots: baseProcedure
     .input(

```
</events>
<input>
```packages/server/src/nft/index.ts
      z.object({
        dao_mint: z.string(),
        snapshot_id: z.number(),
      })
    )
    .mutation(async ({ input }) => {
      const existing = await db
        .select("nft_snapshot", {
          dao_mint: input.dao_mint,
          id: input.snapshot_id,
        })
        .run(pool);

      if (!existing.length) {
        throw new Error("Snapshot not found for this DAO");
      }

      try {
        const updated = await db.sql`
          UPDATE nft_snapshot
          SET revoked = true
          WHERE id = ${db.param(input.snapshot_id)}
        `.run(pool);

        return updated;
      } catch (error) {
<|editable_region_start|>
        console.error("Error revoking snapshot:", error);
        throw new Error(
          error instanceof Error ? error.message : "Failed to revoke snapshot"
        );
      }
    }),

<|user_cursor_is_here|>
  get_snapshots: baseProcedure
    .input(
      z.object({
        dao_mint: z.string(),
      })
    )
    .query(async ({ input }) => {
      try {
        const snapshots = await db.sql<
          s.nft_snapshot.SQL,
          (SelectableForTable<"nft_snapshot"> & {
            wallets_count: number;
          })[]
<|editable_region_end|>
        >`
        SELECT
          s.*,
          COUNT(DISTINCT u.user_address) as wallets_count
        FROM nft_snapshot s
        LEFT JOIN nft_snapshot_user u ON s.id = u.nft_snapshot_id
        WHERE s.dao_mint = ${db.param(input.dao_mint)}
        AND s.revoked = false
        GROUP BY s.id
      `.run(pool);

        return snapshots;
      } catch (e) {
        console.error(e);
        return [];
      }
    }),

  link_new_wallet: baseProcedure
    .input(
```
</input>
<output>
```packages/server/src/nft/index.ts
      z.object({
        dao_mint: z.string(),
        snapshot_id: z.number(),
      })
    )
    .mutation(async ({ input }) => {
      const existing = await db
        .select("nft_snapshot", {
          dao_mint: input.dao_mint,
          id: input.snapshot_id,
        })
        .run(pool);

      if (!existing.length) {
        throw new Error("Snapshot not found for this DAO");
      }

      try {
        const updated = await db.sql`
          UPDATE nft_snapshot
          SET revoked = true
          WHERE id = ${db.param(input.snapshot_id)}
        `.run(pool);

        return updated;
      } catch (error) {
<|editable_region_start|>
        console.error("Error revoking snapshot:", error);
        throw new Error(
          error instanceof Error ? error.message : "Failed to revoke snapshot"
        );
      }
    }),

  get_snapshots: baseProcedure
    .input(
      z.object({
        dao_mint: z.string(),
      })
    )
    .query(async ({ input }) => {
      try {
        const snapshots = await db.sql<
          s.nft_snapshot.SQL,
          (SelectableForTable<"nft_snapshot"> & {
            wallets_count: number;
          })[]
<|editable_region_end|>
        >`
        SELECT
          s.*,
          COUNT(DISTINCT u.user_address) as wallets_count
        FROM nft_snapshot s
        LEFT JOIN nft_snapshot_user u ON s.id = u.nft_snapshot_id
        WHERE s.dao_mint = ${db.param(input.dao_mint)}
        AND s.revoked = false
        GROUP BY s.id
      `.run(pool);

        return snapshots;
      } catch (e) {
        console.error(e);
        return [];
      }
    }),

  link_new_wallet: baseProcedure
    .input(
```
</output>
<outline>
```packages/server/src/nft/index.ts
const nft_router
```

</outline>
<rejected>
```packages/server/src/nft/index.ts
      z.object({
        dao_mint: z.string(),
        snapshot_id: z.number(),
      })
    )
    .mutation(async ({ input }) => {
      const existing = await db
        .select("nft_snapshot", {
          dao_mint: input.dao_mint,
          id: input.snapshot_id,
        })
        .run(pool);

      if (!existing.length) {
        throw new Error("Snapshot not found for this DAO");
      }

      try {
        const updated = await db.sql`
          UPDATE nft_snapshot
          SET revoked = true
          WHERE id = ${db.param(input.snapshot_id)}
        `.run(pool);

        return updated;
      } catch (error) {
<|editable_region_start|>
        console.error("Error revoking snapshot:", error);
        throw new Error(
          error instanceof Error ? error.message : "Failed to revoke snapshot"
        );
      }
    }),

  check_wallet_in_snapshot_id: baseProcedure
    .input(
      z.object({
        snapshot_id: z.number(),
      })
    )
    .query(async ({ input }) => {
      const twitter_authed = await verify_twitter();
      if (!twitter_authed) throw new Error("No Twitter account");

      try {
        const result = await db.sql<
          s.nft_snapshot_user.SQL,
          { total_nft_count: number }[]
        >`
              SELECT COALESCE(SUM(nsu.nft_count), 0) as total_nft_count
              FROM linked_wallets lw
              JOIN nft_snapshot_user nsu
                ON nsu.user_address = lw.wallet_base58
              WHERE lw.user_id = ${db.param(twitter_authed.user_id)}
                AND nsu.nft_snapshot_id = ${db.param(input.snapshot_id)}
            `.run(pool);

        return result[0]?.total_nft_count ?? 0;
      } catch (e) {
        console.error(e);
        return 0;
      }
    }),

  get_snapshots: baseProcedure
    .input(
      z.object({
        dao_mint: z.string(),
      })
    )
    .query(async ({ input }) => {
      try {
        const snapshots = await db.sql<
          s.nft_snapshot.SQL,
          (SelectableForTable<"nft_snapshot"> & {
            wallets_count: number;
          })[]
<|editable_region_end|>
        >`
        SELECT
          s.*,
          COUNT(DISTINCT u.user_address) as wallets_count
        FROM nft_snapshot s
        LEFT JOIN nft_snapshot_user u ON s.id = u.nft_snapshot_id
        WHERE s.dao_mint = ${db.param(input.dao_mint)}
        AND s.revoked = false
        GROUP BY s.id
      `.run(pool);

        return snapshots;
      } catch (e) {
        console.error(e);
        return [];
      }
    }),

  link_new_wallet: baseProcedure
    .input(
```
</rejected>

<labels>
no-op,infer-intent
</labels>
