<events>
User edited "regex-automata/src/util/captures.rs":
```diff
@@ -772,7 +772,7 @@
         replacement: &str,
         dst: &mut String,
     ) {
-        self.interpolae
+        self.interpola
         interpolate::string(
             replacement,
             |index, dst| {

```
</events>
<input>
```regex-automata/src/util/captures.rs
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
<|editable_region_start|>
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
    /// let mut cache = re.create_cache();
    /// let mut caps = re.create_captures();
    ///
    /// let replacement = "year=$year, month=$month, day=$day";
    ///
    /// // This matches the first pattern.
    /// let hay = "On 14-03-2010, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// // And this matches the second pattern.
    /// let hay = "On 2010-03-14, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn interpolate_string_into(
        &self,
        haystack: &str,
        replacement: &str,
        dst: &mut String,
    ) {
        self.interpola<|user_cursor_is_here|>
        interpolate::string(
            replacement,
            |index, dst| {
                let span = match self.get_group(index) {
                    None => return,
                    Some(span) => span,
                };
                dst.push_str(&haystack[span]);
            },
<|editable_region_end|>
            |name| self.group_info().to_index(self.pattern()?, name),
            dst,
        );
    }

    /// Interpolates the capture references in `replacement` with the
    /// corresponding substrings in `haystack` matched by each reference. The
    /// interpolated byte string is returned.
    ///
    /// See the [`interpolate` module](interpolate) for documentation on the
    /// format of the replacement string.
    ///
    /// # Example
    ///
    /// This example shows how to use interpolation, and also shows how it
    /// can work with multi-pattern regexes.
    ///
    /// ```
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
```
</input>
<output>
```regex-automata/src/util/captures.rs
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
<|editable_region_start|>
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
    /// let mut cache = re.create_cache();
    /// let mut caps = re.create_captures();
    ///
    /// let replacement = "year=$year, month=$month, day=$day";
    ///
    /// // This matches the first pattern.
    /// let hay = "On 14-03-2010, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// // And this matches the second pattern.
    /// let hay = "On 2010-03-14, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn interpolate_string_into(
        &self,
        haystack: &str,
        replacement: &str,
        dst: &mut String,
    ) {
        interpolate::string(
            replacement,
            |index, dst| {
                let span = match self.get_group(index) {
                    None => return,
                    Some(span) => span,
                };
                dst.push_str(&haystack[span]);
            },
<|editable_region_end|>
            |name| self.group_info().to_index(self.pattern()?, name),
            dst,
        );
    }

    /// Interpolates the capture references in `replacement` with the
    /// corresponding substrings in `haystack` matched by each reference. The
    /// interpolated byte string is returned.
    ///
    /// See the [`interpolate` module](interpolate) for documentation on the
    /// format of the replacement string.
    ///
    /// # Example
    ///
    /// This example shows how to use interpolation, and also shows how it
    /// can work with multi-pattern regexes.
    ///
    /// ```
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
```
</output>
<rejected>
```regex-automata/src/util/captures.rs
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
<|editable_region_start|>
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
    /// let mut cache = re.create_cache();
    /// let mut caps = re.create_captures();
    ///
    /// let replacement = "year=$year, month=$month, day=$day";
    ///
    /// // This matches the first pattern.
    /// let hay = "On 14-03-2010, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// // And this matches the second pattern.
    /// let hay = "On 2010-03-14, I became a Tenneessee lamb.";
    /// re.captures(&mut cache, hay, &mut caps);
    /// let mut dst = String::new();
    /// caps.interpolate_string_into(hay, replacement, &mut dst);
    /// assert_eq!("year=2010, month=03, day=14", dst);
    ///
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn interpolate_string_into(
        &self,
        haystack: &str,
        replacement: &str,
        dst: &mut String,
    ) {
        self.interpolate_string_into(haystack, replacement, dst);
    }

    /// Interpolates the capture references in `replacement` with the
    /// corresponding substrings in `haystack` matched by each reference. The
    /// interpolated byte string is returned.
    ///
    /// See the [`interpolate` module](interpolate) for documentation on the
    /// format of the replacement string.
    ///
    /// # Example
    ///
    /// This example shows how to use interpolation, and also shows how it
    /// can work with multi-pattern regexes.
    ///
    /// ```
    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};
    ///
    /// let re = PikeVM::new_many(&[
    ///     r"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})",
    ///     r"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})",
    /// ])?;
```
</rejected>
<outline>
```regex-automata/src/util/captures.rs
pub struct Captures
 group_info
 pid
 slots
impl Captures
 pub fn all
 pub fn matches
 pub fn empty
 pub fn is_match
 pub fn pattern
 pub fn get_match
 pub fn get_group
 pub fn get_group_by_name
 pub fn iter
 pub fn group_len
 pub fn group_info
 pub fn interpolate_string
 pub fn interpolate_string_into
 pub fn interpolate_bytes
 pub fn interpolate_bytes_into
 pub fn extract
 pub fn extract_bytes
impl Captures
 pub fn clear
 pub fn set_pattern
 pub fn slots
 pub fn slots_mut
impl core::fmt::Debug for Captures
 fn fmt
struct CapturesDebugMap
 pid
 caps
impl core::fmt::Debug for CapturesDebugMap<'a>
 fn fmt
  struct Key
  impl core::fmt::Debug for Key<'a>
   fn fmt
pub struct CapturesPatternIter
 caps
 names
impl Iterator for CapturesPatternIter<'a>
 type Item
 fn next
 fn size_hint
 fn count
impl ExactSizeIterator for CapturesPatternIter<'a>
impl core::iter::FusedIterator for CapturesPatternIter<'a>
pub struct GroupInfo
impl GroupInfo
 pub fn new
 pub fn empty
 pub fn to_index
 pub fn to_name
 pub fn pattern_names
 pub fn all_names
 pub fn slots
 pub fn slot
 pub fn pattern_len
 pub fn group_len
 pub fn all_group_len
 pub fn slot_len
 pub fn implicit_slot_len
 pub fn explicit_slot_len
 pub fn memory_usage
type CaptureNameMap
type CaptureNameMap
struct GroupInfoInner
 slot_ranges
 name_to_index
 index_to_name
 memory_extra
impl GroupInfoInner
 fn add_first_group
 fn add_explicit_group
 fn fixup_slot_ranges
 fn pattern_len
 fn group_len
 fn small_slot_len
pub struct GroupInfoError
 kind
enum GroupInfoErrorKind
 TooManyPatterns
  err
 TooManyGroups
  pattern
  minimum
 MissingGroups
  pattern
 FirstMustBeUnnamed
  pattern
 Duplicate
  pattern
  name
impl GroupInfoError
 fn too_many_patterns
 fn too_many_groups
 fn missing_groups
 fn first_must_be_unnamed
 fn duplicate
impl std::error::Error for GroupInfoError
 fn source
impl core::fmt::Display for GroupInfoError
 fn fmt
pub struct GroupInfoPatternNames
 it
impl GroupInfoPatternNames<'static>
 fn empty
impl Iterator for GroupInfoPatternNames<'a>
 type Item
 fn next
 fn size_hint
 fn count
impl ExactSizeIterator for GroupInfoPatternNames<'a>
impl core::iter::FusedIterator for GroupInfoPatternNames<'a>
pub struct GroupInfoAllNames
 group_info
 pids
 current_pid
 names
impl Iterator for GroupInfoAllNames<'a>
 type Item
 fn next
```

</outline>

<labels>
local-edit,infer-intent
</labels>
