<events>
User edited "crates/go_to_line/src/cursor_position.rs":
```diff
@@ -31,7 +31,7 @@
 /// A position in the editor, where user's caret is located at.
 /// Lines are never zero as there is always at least one line in the editor.
 /// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,
-/// 
+/// where "1" will mean "before the firt c"
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub struct UserCaretPosition {
     pub line: NonZeroU32,

```
</events>
<input>
```crates/go_to_line/src/cursor_position.rs
use editor::Editor;
use gpui::{AppContext, FocusHandle, FocusableView, Subscription, Task, View, WeakView};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use settings::{Settings, SettingsSources};
use std::{fmt::Write, num::NonZeroU32, time::Duration};
use text::{Point, Selection};
use ui::{
    div, Button, ButtonCommon, Clickable, FluentBuilder, IntoElement, LabelSize, ParentElement,
<|editable_region_start|>
    Render, Tooltip, ViewContext,
};
use util::paths::FILE_ROW_COLUMN_DELIMITER;
use workspace::{item::ItemHandle, StatusItemView, Workspace};

#[derive(Copy, Clone, Debug, Default, PartialOrd, PartialEq)]
pub(crate) struct SelectionStats {
    pub lines: usize,
    pub characters: usize,
    pub selections: usize,
}

pub struct CursorPosition {
    position: Option<UserCaretPosition>,
    selected_count: SelectionStats,
    context: Option<FocusHandle>,
    workspace: WeakView<Workspace>,
    update_position: Task<()>,
    _observe_active_editor: Option<Subscription>,
}

/// A position in the editor, where user's caret is located at.
/// Lines are never zero as there is always at least one line in the editor.
/// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,
/// where "1" will mean "before the firt c<|user_cursor_is_here|>"
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct UserCaretPosition {
    pub line: NonZeroU32,
    pub character: u32,
}

impl CursorPosition {
    pub fn new(workspace: &Workspace) -> Self {
        Self {
            position: None,
            context: None,
            selected_count: Default::default(),
<|editable_region_end|>
            workspace: workspace.weak_handle(),
            update_position: Task::ready(()),
            _observe_active_editor: None,
        }
    }

    fn update_position(
        &mut self,
        editor: View<Editor>,
        debounce: Option<Duration>,
        cx: &mut ViewContext<Self>,
    ) {
        let editor = editor.downgrade();
        self.update_position = cx.spawn(|cursor_position, mut cx| async move {
            let is_singleton = editor
                .update(&mut cx, |editor, cx| {
                    editor.buffer().read(cx).is_singleton()
                })
                .ok()
                .unwrap_or(true);
```
</input>
<output>
```crates/go_to_line/src/cursor_position.rs
use editor::Editor;
use gpui::{AppContext, FocusHandle, FocusableView, Subscription, Task, View, WeakView};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use settings::{Settings, SettingsSources};
use std::{fmt::Write, num::NonZeroU32, time::Duration};
use text::{Point, Selection};
use ui::{
    div, Button, ButtonCommon, Clickable, FluentBuilder, IntoElement, LabelSize, ParentElement,
<|editable_region_start|>
    Render, Tooltip, ViewContext,
};
use util::paths::FILE_ROW_COLUMN_DELIMITER;
use workspace::{item::ItemHandle, StatusItemView, Workspace};

#[derive(Copy, Clone, Debug, Default, PartialOrd, PartialEq)]
pub(crate) struct SelectionStats {
    pub lines: usize,
    pub characters: usize,
    pub selections: usize,
}

pub struct CursorPosition {
    position: Option<UserCaretPosition>,
    selected_count: SelectionStats,
    context: Option<FocusHandle>,
    workspace: WeakView<Workspace>,
    update_position: Task<()>,
    _observe_active_editor: Option<Subscription>,
}

/// A position in the editor, where user's caret is located at.
/// Lines are never zero as there is always at least one line in the editor.
/// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,
/// where "1" will mean "before the first character"
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct UserCaretPosition {
    pub line: NonZeroU32,
    pub character: u32,
}

impl CursorPosition {
    pub fn new(workspace: &Workspace) -> Self {
        Self {
            position: None,
            context: None,
            selected_count: Default::default(),
<|editable_region_end|>
            workspace: workspace.weak_handle(),
            update_position: Task::ready(()),
            _observe_active_editor: None,
        }
    }

    fn update_position(
        &mut self,
        editor: View<Editor>,
        debounce: Option<Duration>,
        cx: &mut ViewContext<Self>,
    ) {
        let editor = editor.downgrade();
        self.update_position = cx.spawn(|cursor_position, mut cx| async move {
            let is_singleton = editor
                .update(&mut cx, |editor, cx| {
                    editor.buffer().read(cx).is_singleton()
                })
                .ok()
                .unwrap_or(true);
```
</output>
<outline>
```crates/go_to_line/src/cursor_position.rs
pub(crate) struct SelectionStats
 pub lines
 pub characters
 pub selections
pub struct CursorPosition
 position
 selected_count
 context
 workspace
 update_position
 _observe_active_editor
pub struct UserCaretPosition
 pub line
 pub character
impl CursorPosition
 pub fn new
 fn update_position
 fn write_position
 pub(crate) fn selection_stats
 pub(crate) fn position
impl Render for CursorPosition
 fn render
const UPDATE_DEBOUNCE
impl StatusItemView for CursorPosition
 fn set_active_pane_item
pub(crate) enum LineIndicatorFormat
 Short
 Long
pub(crate) struct LineIndicatorFormatContent
impl Settings for LineIndicatorFormat
 const KEY
 type FileContent
 fn load
```

</outline>
<rejected>
```crates/go_to_line/src/cursor_position.rs
use editor::Editor;
use gpui::{AppContext, FocusHandle, FocusableView, Subscription, Task, View, WeakView};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use settings::{Settings, SettingsSources};
use std::{fmt::Write, num::NonZeroU32, time::Duration};
use text::{Point, Selection};
use ui::{
    div, Button, ButtonCommon, Clickable, FluentBuilder, IntoElement, LabelSize, ParentElement,
<|editable_region_start|>
    Render, Tooltip, ViewContext,
};
use util::paths::FILE_ROW_COLUMN_DELIMITER;
use workspace::{item::ItemHandle, StatusItemView, Workspace};

#[derive(Copy, Clone, Debug, Default, PartialOrd, PartialEq)]
pub(crate) struct SelectionStats {
    pub lines: usize,
    pub characters: usize,
    pub selections: usize,
}

pub struct CursorPosition {
    position: Option<UserCaretPosition>,
    selected_count: SelectionStats,
    context: Option<FocusHandle>,
    workspace: WeakView<Workspace>,
    update_position: Task<()>,
    _observe_active_editor: Option<Subscription>,
}

/// A position in the editor, where user's caret is located at.
/// Lines are never zero as there is always at least one line in the editor.
/// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,
/// where "1" will mean "before the first character"
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct UserCaretPosition {
    pub line: NonZeroU32,
    pub character: u32,
}

impl CursorPosition {
    pub fn new(workspace: &Workspace) -> Self {
        Self {
            position: None,
            selected_count: Default::default(),
<|editable_region_end|>
            workspace: workspace.weak_handle(),
            update_position: Task::ready(()),
            _observe_active_editor: None,
        }
    }

    fn update_position(
        &mut self,
        editor: View<Editor>,
        debounce: Option<Duration>,
        cx: &mut ViewContext<Self>,
    ) {
        let editor = editor.downgrade();
        self.update_position = cx.spawn(|cursor_position, mut cx| async move {
            let is_singleton = editor
                .update(&mut cx, |editor, cx| {
                    editor.buffer().read(cx).is_singleton()
                })
                .ok()
                .unwrap_or(true);
```
</rejected>

<labels>
local-edit,infer-intent
</labels>
