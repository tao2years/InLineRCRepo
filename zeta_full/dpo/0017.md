<events>
User edited "crates/editor/src/editor.rs":
```diff
@@ -1414,7 +1414,7 @@
                 cx.observe_window_activation(window, |editor, window, cx| {
                     let active = window.is_window_active();
                     editor.blink_manager.update(cx, |blink_manager, cx| {
-                        if active {
+                        if true {
                             blink_manager.enable(cx);
                         } else {
                             blink_manager.disable(cx);

```
</events>
<input>
```crates/title_bar/src/title_bar.rs
                                menu.navigate_menus_in_direction(action, window, cx)
                            });
                        }
                    });
                }
            },
        );
    })
    .detach();
}

pub struct TitleBar {
    platform_style: PlatformStyle,
    content: Stateful<Div>,
    children: SmallVec<[AnyElement; 2]>,
    repository_selector: Entity<RepositorySelector>,
    project: Entity<Project>,
    user_store: Entity<UserStore>,
    client: Arc<Client>,
    workspace: WeakEntity<Workspace>,
    should_move: bool,
    application_menu: Option<Entity<ApplicationMenu>>,
    _subscriptions: Vec<Subscription>,
    git_ui_enabled: Arc<AtomicBool>,
}

impl Render for TitleBar {
<|editable_region_start|>
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let close_action = Box::new(workspace::CloseWindow);
        let height = Self::height(window);
        let supported_controls = window.window_controls();
        let decorations = window.window_decorations();
        let titlebar_color = if cfg!(any(target_os = "linux", target_os = "freebsd")) {
            if window.is_window_active() && !self.should_move {
                cx.theme().colors().title_bar_background
            } else {
                cx.theme().colors().title_bar_inactive_background
            }
        } else {
            cx.theme().colors().title_bar_background
        };

        h_flex()
            .id("titlebar")
            .w_full()
            .h(height)
            .map(|this| {
                if window.is_fullscreen() {
                    this.pl_2()
                } else if self.platform_style == PlatformStyle::Mac {
                    this.pl(px(platform_mac::TRAFFIC_LIGHT_PADDING))
    <|user_cursor_is_here|>            } else {
                    this.pl_2()
                }
            })
            .map(|el| match decorations {
                Decorations::Server => el,
                Decorations::Client { tiling, .. } => el
                    .when(!(tiling.top || tiling.right), |el| {
<|editable_region_end|>
                        el.rounded_tr(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    .when(!(tiling.top || tiling.left), |el| {
                        el.rounded_tl(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    // this border is to avoid a transparent gap in the rounded corners
                    .mt(px(-1.))
                    .border(px(1.))
```
</input>
<output>
```crates/title_bar/src/title_bar.rs
                                menu.navigate_menus_in_direction(action, window, cx)
                            });
                        }
                    });
                }
            },
        );
    })
    .detach();
}

pub struct TitleBar {
    platform_style: PlatformStyle,
    content: Stateful<Div>,
    children: SmallVec<[AnyElement; 2]>,
    repository_selector: Entity<RepositorySelector>,
    project: Entity<Project>,
    user_store: Entity<UserStore>,
    client: Arc<Client>,
    workspace: WeakEntity<Workspace>,
    should_move: bool,
    application_menu: Option<Entity<ApplicationMenu>>,
    _subscriptions: Vec<Subscription>,
    git_ui_enabled: Arc<AtomicBool>,
}

impl Render for TitleBar {
<|editable_region_start|>
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let close_action = Box::new(workspace::CloseWindow);
        let height = Self::height(window);
        let supported_controls = window.window_controls();
        let decorations = window.window_decorations();
        let titlebar_color = if cfg!(any(target_os = "linux", target_os = "freebsd")) {
            if window.is_window_active() && !self.should_move {
                cx.theme().colors().title_bar_background
            } else {
                cx.theme().colors().title_bar_inactive_background
            }
        } else {
            cx.theme().colors().title_bar_background
        };

        h_flex()
            .id("titlebar")
            .w_full()
            .h(height)
            .map(|this| {
                if window.is_fullscreen() {
                    this.pl_2()
                } else if self.platform_style == PlatformStyle::Mac {
                    this.pl(px(platform_mac::TRAFFIC_LIGHT_PADDING))
                } else {
                    this.pl_2()
                }
            })
            .map(|el| match decorations {
                Decorations::Server => el,
                Decorations::Client { tiling, .. } => el
                    .when(!(tiling.top || tiling.right), |el| {
<|editable_region_end|>
                        el.rounded_tr(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    .when(!(tiling.top || tiling.left), |el| {
                        el.rounded_tl(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    // this border is to avoid a transparent gap in the rounded corners
                    .mt(px(-1.))
                    .border(px(1.))
```
</output>
<outline>
```crates/title_bar/src/title_bar.rs
```

</outline>
<rejected>
```crates/title_bar/src/title_bar.rs
                                menu.navigate_menus_in_direction(action, window, cx)
                            });
                        }
                    });
                }
            },
        );
    })
    .detach();
}

pub struct TitleBar {
    platform_style: PlatformStyle,
    content: Stateful<Div>,
    children: SmallVec<[AnyElement; 2]>,
    repository_selector: Entity<RepositorySelector>,
    project: Entity<Project>,
    user_store: Entity<UserStore>,
    client: Arc<Client>,
    workspace: WeakEntity<Workspace>,
    should_move: bool,
    application_menu: Option<Entity<ApplicationMenu>>,
    _subscriptions: Vec<Subscription>,
    git_ui_enabled: Arc<AtomicBool>,
}

impl Render for TitleBar {
<|editable_region_start|>
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let close_action = Box::new(workspace::CloseWindow);
        let height = Self::height(window);
        let supported_controls = window.window_controls();
        let decorations = window.window_decorations();
        let titlebar_color = if cfg!(any(target_os = "linux", target_os = "freebsd")) {
            if window.is_window_active() && !self.should_move {
                cx.theme().colors().title_bar_background
            } else {
                cx.theme().colors().title_bar_inactive_background
            }
        } else {
            cx.theme().colors().title_bar_background
        };

        h_flex()
            .id("titlebar")
            .w_full()
            .h(height)
            .map(|this| {
                if window.is_fullscreen() {
                    this.pl_2()
                } else if self.platform_style == PlatformStyle::Mac {
                    this.pl(px(platform_mac::TRAFFIC_LIGHT_PADDING))
    <|editable_region_end|>
                        el.rounded_tr(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    .when(!(tiling.top || tiling.right), |el| {
                        el.rounded_tl(theme::CLIENT_SIDE_DECORATION_ROUNDING)
                    })
                    // this border is to avoid a transparent gap in the rounded corners
                    .mt(px(-1.))
                    .border(px(1.))
```
</rejected>

<labels>
no-op,infer-intent
</labels>
