<events>
User edited "crates/editor/src/element.rs":
```diff
@@ -3172,7 +3172,7 @@
     // `layout_gutter_menu` will render code actions menu if it is on the gutter.
     // 
     #[allow(clippy::too_many_arguments)]
-        fn layout_context_menu(
+        fn layout_gut(
             &self,
             line_height: Pixels,
             text_hitbox: &Hitbox,

```
</events>
<input>
```zed/crates/editor/src/element.rs
            let mut max_row = next_buffer_row - FILE_HEADER_HEIGHT * 2;

            if next_excerpt_controls_present {
                max_row -= MULTI_BUFFER_EXCERPT_HEADER_HEIGHT;
            }

            let offset = scroll_position - max_row as f32;

            if offset > 0.0 {
                origin.y -= Pixels(offset) * line_height;
            }
        }

        let size = size(
            AvailableSpace::Definite(hitbox.size.width),
            AvailableSpace::MinContent,
<|editable_region_start|>
        );

        header.prepaint_as_root(origin, size, window, cx);

        header
    }
    <|user_cursor_is_here|>
    // Design:
    // 
    // `layout_cursor_popovers` will layout new edit predictions thing, completions menu, and
    // signature help, in that order. If there isn't space for signature help, it will be hidden.
    // completions menu is the only variable size part for now.
    // 
    // `layout_gutter_menu` will render code actions menu if it is on the gutter.
    // 
    #[allow(clippy::too_many_arguments)]
        fn layout_gut(
            &self,
            line_height: Pixels,
            text_hitbox: &Hitbox,
            content_origin: gpui::Point<Pixels>,
            start_row: DisplayRow,
            scroll_pixel_position: gpui::Point<Pixels>,
            line_layouts: &[LineWithInvisibles],
            newest_selection_head: DisplayPoint,
            gutter_overshoot: Pixels,
            window: &mut Window,
            cx: &mut App,
        ) {
            let Some(context_menu_origin) = self
                .editor
                .read(cx)
                .context_menu_origin(newest_selection_head)
            else {
                return;
            };
    
<|editable_region_end|>
    #[allow(clippy::too_many_arguments)]
    fn layout_context_menu(
        &self,
        line_height: Pixels,
        text_hitbox: &Hitbox,
        content_origin: gpui::Point<Pixels>,
        start_row: DisplayRow,
        scroll_pixel_position: gpui::Point<Pixels>,
        line_layouts: &[LineWithInvisibles],
        newest_selection_head: DisplayPoint,
        gutter_overshoot: Pixels,
        window: &mut Window,
        cx: &mut App,
```
</input>
<output>
```zed/crates/editor/src/element.rs
            let mut max_row = next_buffer_row - FILE_HEADER_HEIGHT * 2;

            if next_excerpt_controls_present {
                max_row -= MULTI_BUFFER_EXCERPT_HEADER_HEIGHT;
            }

            let offset = scroll_position - max_row as f32;

            if offset > 0.0 {
                origin.y -= Pixels(offset) * line_height;
            }
        }

        let size = size(
            AvailableSpace::Definite(hitbox.size.width),
            AvailableSpace::MinContent,
<|editable_region_start|>
        );

        header.prepaint_as_root(origin, size, window, cx);

        header
    }
    
    // Design:
    // 
    // `layout_cursor_popovers` will layout new edit predictions thing, completions menu, and
    // signature help, in that order. If there isn't space for signature help, it will be hidden.
    // completions menu is the only variable size part for now.
    // 
    // `layout_gutter_menu` will render code actions menu if it is on the gutter.
    // 
    #[allow(clippy::too_many_arguments)]
    fn layout_gutter_menu(
        &self,
        line_height: Pixels,
        text_hitbox: &Hitbox,
        content_origin: gpui::Point<Pixels>,
        start_row: DisplayRow,
        scroll_pixel_position: gpui::Point<Pixels>,
        line_layouts: &[LineWithInvisibles],
        newest_selection_head: DisplayPoint,
        gutter_overshoot: Pixels,
        window: &mut Window,
        cx: &mut App,
    ) {
        let Some(context_menu_origin) = self
            .editor
            .read(cx)
            .context_menu_origin(newest_selection_head)
        else {
            return;
        };
    }
    
<|editable_region_end|>
    #[allow(clippy::too_many_arguments)]
    fn layout_context_menu(
        &self,
        line_height: Pixels,
        text_hitbox: &Hitbox,
        content_origin: gpui::Point<Pixels>,
        start_row: DisplayRow,
        scroll_pixel_position: gpui::Point<Pixels>,
        line_layouts: &[LineWithInvisibles],
        newest_selection_head: DisplayPoint,
        gutter_overshoot: Pixels,
        window: &mut Window,
        cx: &mut App,
```
</output>
<outline>
```crates/editor/src/element.rs
const INLINE_BLAME_PADDING_EM_WIDTHS
enum DisplayDiffHunk
 Folded
  display_row
 Unfolded
  diff_base_byte_range
  display_row_range
  multi_buffer_range
  status
struct SelectionLayout
 head
 cursor_shape
 is_newest
 is_local
 range
 active_rows
 user_name
impl SelectionLayout
 fn new
pub struct EditorElement
 editor
 style
type DisplayRowDelta
impl EditorElement
 pub(crate) const SCROLLBAR_WIDTH
 pub fn new
 fn register_actions
 fn register_key_listeners
 fn modifiers_changed
 fn mouse_left_down
 fn mouse_right_down
 fn mouse_middle_down
 fn mouse_up
 fn click
 fn mouse_dragged
 fn mouse_moved
 fn update_visible_cursor
 fn layout_selections
 fn collect_cursors
 fn layout_visible_cursors
 fn layout_scrollbars
 fn prepaint_crease_toggles
 fn prepaint_crease_trailers
 fn layout_gutter_diff_hunks
 fn layout_inline_blame
  const INLINE_BLAME_PADDING_EM_WIDTHS
  const INLINE_ACCEPT_SUGGESTION_EM_WIDTHS
 fn layout_blame_entries
 fn layout_indent_guides
 fn calculate_indent_guide_bounds
 fn layout_run_indicators
 fn layout_code_actions_indicator
 fn get_participant_color
 fn calculate_relative_line_numbers
 fn layout_line_numbers
 fn layout_crease_toggles
 fn layout_crease_trailers
 fn layout_lines
 fn prepaint_lines
 fn render_block
 fn render_buffer_header
 fn render_expand_excerpt_button
 fn render_blocks
 fn layout_blocks
 fn layout_sticky_buffer_header
 fn layout_gut
  fn layout_context_menu
  fn layout_context_menu_aside
  fn render_context_menu_aside
  fn layout_inline_completion_popover
   const PADDING_X
   const PADDING_Y
  fn layout_mouse_context_menu
  fn layout_hover_popovers
   struct MeasuredHoverPopover
    element
    size
    horizontal_offset
   fn draw_occluder
  fn layout_diff_hunk_controls
  fn layout_signature_help
  fn paint_background
  fn paint_indent_guides
   const INDENT_AWARE_ALPHA
   const INDENT_AWARE_ACTIVE_ALPHA
   const INDENT_AWARE_BACKGROUND_ALPHA
   const INDENT_AWARE_BACKGROUND_ACTIVE_ALPHA
  fn paint_line_numbers
  fn paint_diff_hunks
  fn diff_hunk_bounds
  fn paint_gutter_indicators
  fn paint_gutter_highlights
  fn paint_blamed_display_rows
  fn paint_text
  fn paint_highlights
  fn paint_lines
  fn paint_redactions
  fn paint_cursors
  fn paint_scrollbars
  fn collect_fast_scrollbar_markers
   const LIMIT
  fn refresh_slow_scrollbar_markers
  fn paint_highlighted_range
  fn paint_inline_blame
  fn paint_diff_hunk_controls
  fn paint_blocks
  fn paint_inline_completion_popover
  fn paint_mouse_context_menu
  fn paint_scroll_wheel_listener
  fn paint_mouse_listeners
  fn scrollbar_left
  fn column_pixels
  fn max_line_number_width
  fn shape_line_number
 fn header_jump_data
 fn inline_completion_tab_indicator
 fn prepaint_gutter_button
 fn render_inline_blame_entry
 fn render_blame_entry
 fn deploy_blame_entry_context_menu
 pub(crate) struct LineWithInvisibles
  fragments
  invisibles
  len
  width
  font_size
 enum LineFragment
  Text
  Element
   element
   size
   len
 impl fmt::Debug for LineFragment
  fn fmt
 impl LineWithInvisibles
  fn from_chunks
  fn prepaint
  fn draw
  fn draw_invisibles
  pub fn x_for_index
  pub fn index_for_x
  pub fn font_id_for_index
 enum Invisible
  Tab
   line_start_offset
   line_end_offset
  Whitespace
   line_offset
 impl EditorElement
  fn rem_size
 impl Element for EditorElement
  type RequestLayoutState
  type PrepaintState
  fn id
  fn request_layout
  fn prepaint
  fn paint
 pub(super) fn gutter_bounds
 struct ScrollbarRangeData
  scrollbar_bounds
  scroll_range
  letter_size
 impl ScrollbarRangeData
  pub fn new
 impl IntoElement for EditorElement
  type Element
  fn into_element
 pub struct EditorLayout
  position_map
  hitbox
  text_hitbox
  gutter_hitbox
  content_origin
  scrollbars_layout
  mode
  wrap_guides
  indent_guides
  visible_display_row_range
  active_rows
  highlighted_rows
  line_elements
  line_numbers
  display_hunks
  blamed_display_rows
  inline_blame
  blocks
  highlighted_ranges
  highlighted_gutter_ranges
  redacted_ranges
  cursors
  visible_cursors
  selections
  code_actions_indicator
  test_indicators
  crease_toggles
  diff_hunk_controls
  crease_trailers
  inline_completion_popover
  mouse_context_menu
  tab_invisible
  space_invisible
  sticky_buffer_header
 impl EditorLayout
  fn line_end_overshoot
 struct LineNumberLayout
  shaped_line
  hitbox
  display_row
 struct ColoredRange
  start
  end
  color
 struct ScrollbarLayout
  hitbox
  visible_range
  visible
  text_unit_size
  thumb_size
  axis
 impl ScrollbarLayout
  const BORDER_WIDTH
  const LINE_MARKER_HEIGHT
  const MIN_MARKER_HEIGHT
  fn thumb_bounds
  fn y_for_row
  fn marker_quads_for_ranges
   struct MinMax
    min
    max
 struct CreaseTrailerLayout
  element
  bounds
 struct PositionMap
  size
  line_height
  scroll_pixel_position
  scroll_max
  em_width
  em_advance
  line_layouts
  snapshot
 pub struct PointForPosition
  pub previous_valid
  pub next_valid
  pub exact_unclipped
  pub column_overshoot_after_line_end
 impl PointForPosition
  pub fn as_valid
 impl PositionMap
  fn point_for_position
 struct BlockLayout
  id
  row
  element
  available_space
  style
 fn layout_line
 pub struct IndentGuideLayout
  origin
  length
  single_indent_width
  depth
  active
  settings
 pub struct CursorLayout
  origin
  block_width
  line_height
  color
  shape
  block_text
  cursor_name
 pub struct CursorName
  string
  color
  is_top_row
 impl CursorLayout
  pub fn new
  pub fn bounding_rect
  fn bounds
  pub fn layout
  pub fn paint
  pub fn shape
 pub struct HighlightedRange
  pub start_y
  pub line_height
  pub lines
  pub color
  pub corner_radius
 pub struct HighlightedRangeLine
  pub start_x
  pub end_x
 impl HighlightedRange
  pub fn paint
  fn paint_lines
 pub fn scale_vertical_mouse_autoscroll_delta
 fn scale_horizontal_mouse_autoscroll_delta
 pub fn register_action
 fn compute_auto_height_layout
 mod tests
  fn test_shape_line_numbers
  async fn test_vim_visual_selections
  fn test_layout_with_placeholder_text_and_blocks
  fn test_all_invisibles_drawing
   const TAB_SIZE
  fn test_invisibles_dont_appear_in_certain_editors
  fn test_wrapped_invisibles_drawing
  fn collect_invisibles_from_new_editor
 fn diff_hunk_controls
```

</outline>
<rejected>
```zed/crates/editor/src/element.rs
            let mut max_row = next_buffer_row - FILE_HEADER_HEIGHT * 2;

            if next_excerpt_controls_present {
                max_row -= MULTI_BUFFER_EXCERPT_HEADER_HEIGHT;
            }

            let offset = scroll_position - max_row as f32;

            if offset > 0.0 {
                origin.y -= Pixels(offset) * line_height;
            }
        }

        let size = size(
            AvailableSpace::Definite(hitbox.size.width),
            AvailableSpace::MinContent,
<|editable_region_start|>
        );

        header.prepaint_as_root(origin, size, window, cx);

        header
    }
    fn layout_gutter_menu(
        &self,
        line_height: Pixels,
        text_hitbox: &Hitbox,
        content_origin: gpui::Point<Pixels>,
        start_row: DisplayRow,
        scroll_pixel_position: gpui::Point<Pixels>,
        line_layouts: &[LineWithInvisibles],
        newest_selection_head: DisplayPoint,
        gutter_overshoot: Pixels,
        window: &mut Window,
        cx: &mut App,
    ) {
        let Some(context_menu_origin) = self
            .editor
            .read(cx)
            .context_menu_origin(newest_selection_head)
        else {
            return;
        };
    
<|editable_region_end|>
    #[allow(clippy::too_many_arguments)]
    fn layout_context_menu(
        &self,
        line_height: Pixels,
        text_hitbox: &Hitbox,
        content_origin: gpui::Point<Pixels>,
        start_row: DisplayRow,
        scroll_pixel_position: gpui::Point<Pixels>,
        line_layouts: &[LineWithInvisibles],
        newest_selection_head: DisplayPoint,
        gutter_overshoot: Pixels,
        window: &mut Window,
        cx: &mut App,
```
</rejected>

<labels>
local-edit,infer-intent
</labels>
