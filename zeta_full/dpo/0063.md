<events>
User edited "crates/editor/src/display_map.rs":
```diff
@@ -1069,7 +1069,7 @@
     }
 
     pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {
-        dbg!(&point);
+        dbg!(&point, se);
         if point.column() != self.line_len(point.row()) {
             return point;
         }

```
</events>
<input>
```zed/crates/editor/src/display_map.rs
    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot.chars_at(offset).map(move |ch| {
            let ret = (ch, offset);
            offset += ch.len_utf8();
            ret
        })
<|editable_region_start|>
    }

    pub fn reverse_buffer_chars_at(
        &self,
        mut offset: usize,
    ) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot
            .reversed_chars_at(offset)
            .map(move |ch| {
                offset -= ch.len_utf8();
                (ch, offset)
            })
    }

    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {
        let mut clipped = self.block_snapshot.clip_point(point.0, bias);
        if self.clip_at_line_ends {
            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0
        }
        DisplayPoint(clipped)
    }
<|user_cursor_is_here|>
    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {
        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))
    }

    pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {
        dbg!(&point, se);
        if point.column() != self.line_len(point.row()) {
            return point;
        }
        let mut point = self.display_point_to_point(point, Bias::Left);
        point.column = point.column.saturating_sub(1);
        point = self.buffer_snapshot.clip_point(point, Bias::Left);
        self.point_to_display_point(point, Bias::Left)
    }

    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>
    where
        T: ToOffset,
    {
        self.fold_snapshot.folds_in_range(range)
    }

    pub fn blocks_in_range(
        &self,
        rows: Range<DisplayRow>,
    ) -> impl Iterator<Item = (DisplayRow, &Block)> {
        self.block_snapshot
            .blocks_in_range(rows.start.0..rows.end.0)
<|editable_region_end|>
            .map(|(row, block)| (DisplayRow(row), block))
    }

    pub fn sticky_header_excerpt(&self, row: DisplayRow) -> Option<StickyHeaderExcerpt<'_>> {
        self.block_snapshot.sticky_header_excerpt(row.0)
    }

    pub fn block_for_id(&self, id: BlockId) -> Option<Block> {
        self.block_snapshot.block_for_id(id)
    }
```
</input>
<output>
```zed/crates/editor/src/display_map.rs
    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot.chars_at(offset).map(move |ch| {
            let ret = (ch, offset);
            offset += ch.len_utf8();
            ret
        })
<|editable_region_start|>
    }

    pub fn reverse_buffer_chars_at(
        &self,
        mut offset: usize,
    ) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot
            .reversed_chars_at(offset)
            .map(move |ch| {
                offset -= ch.len_utf8();
                (ch, offset)
            })
    }

    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {
        let mut clipped = self.block_snapshot.clip_point(point.0, bias);
        if self.clip_at_line_ends {
            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0
        }
        DisplayPoint(clipped)
    }

    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {
        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))
    }

    pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {
        dbg!(&point, self.display_point_to_point(point, Bias::Left));
        if point.column() != self.line_len(point.row()) {
            return point;
        }
        let mut point = self.display_point_to_point(point, Bias::Left);
        point.column = point.column.saturating_sub(1);
        point = self.buffer_snapshot.clip_point(point, Bias::Left);
        self.point_to_display_point(point, Bias::Left)
    }

    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>
    where
        T: ToOffset,
    {
        self.fold_snapshot.folds_in_range(range)
    }

    pub fn blocks_in_range(
        &self,
        rows: Range<DisplayRow>,
    ) -> impl Iterator<Item = (DisplayRow, &Block)> {
        self.block_snapshot
            .blocks_in_range(rows.start.0..rows.end.0)
<|editable_region_end|>
            .map(|(row, block)| (DisplayRow(row), block))
    }

    pub fn sticky_header_excerpt(&self, row: DisplayRow) -> Option<StickyHeaderExcerpt<'_>> {
        self.block_snapshot.sticky_header_excerpt(row.0)
    }

    pub fn block_for_id(&self, id: BlockId) -> Option<Block> {
        self.block_snapshot.block_for_id(id)
    }
```
</output>
<outline>
```crates/editor/src/display_map.rs
mod block_map
mod crease_map
mod custom_highlights
mod fold_map
mod inlay_map
pub(crate) mod invisibles
mod tab_map
mod wrap_map
pub enum FoldStatus
 Folded
 Foldable
pub trait ToDisplayPoint
 fn to_display_point
type TextHighlights
type InlayHighlights
pub struct DisplayMap
 buffer
 buffer_subscription
 inlay_map
 fold_map
 tab_map
 wrap_map
 block_map
 text_highlights
 inlay_highlights
 crease_map
 pub(crate) fold_placeholder
 pub clip_at_line_ends
 pub(crate) masked
impl DisplayMap
 pub fn new
 pub fn snapshot
 pub fn set_state
 pub fn fold
 pub fn remove_folds_with_type
 pub fn unfold_intersecting
 pub fn fold_buffer
 pub fn unfold_buffer
 pub(crate) fn is_buffer_folded
 pub(crate) fn folded_buffers
 pub fn insert_creases
 pub fn remove_creases
 pub fn insert_blocks
 pub fn resize_blocks
 pub fn replace_blocks
 pub fn remove_blocks
 pub fn row_for_block
 pub fn highlight_text
 pub(crate) fn highlight_inlays
 pub fn text_highlights
 pub fn clear_highlights
 pub fn set_font
 pub fn set_wrap_width
 pub(crate) fn current_inlays
 pub(crate) fn splice_inlays
 fn tab_size
 pub fn is_rewrapping
 pub fn show_excerpt_controls
pub(crate) struct Highlights
 pub text_highlights
 pub inlay_highlights
 pub styles
pub struct InlineCompletionStyles
 pub insertion
 pub whitespace
pub struct HighlightStyles
 pub inlay_hint
 pub inline_completion
pub enum ChunkReplacement
 Renderer
 Str
pub struct HighlightedChunk
 pub text
 pub style
 pub is_tab
 pub replacement
impl HighlightedChunk<'a>
 fn highlight_invisibles
pub struct DisplaySnapshot
 pub buffer_snapshot
 pub fold_snapshot
 pub crease_snapshot
 inlay_snapshot
 tab_snapshot
 wrap_snapshot
 block_snapshot
 text_highlights
 inlay_highlights
 clip_at_line_ends
 masked
 pub(crate) fold_placeholder
impl DisplaySnapshot
 pub fn fold_count
 pub fn is_empty
 pub fn row_infos
 pub fn widest_line_number
 pub fn prev_line_boundary
 pub fn next_line_boundary
 pub fn expand_to_line
 pub fn point_to_display_point
 pub fn display_point_to_point
 pub fn display_point_to_inlay_offset
 pub fn anchor_to_inlay_offset
 pub fn display_point_to_anchor
 fn display_point_to_inlay_point
 pub fn display_point_to_fold_point
 pub fn fold_point_to_display_point
 pub fn max_point
 pub fn text_chunks
 pub fn reverse_text_chunks
 pub fn chunks
 pub fn highlighted_chunks
 pub fn layout_row
 pub fn x_for_display_point
 pub fn display_column_for_x
 pub fn grapheme_at
 pub fn buffer_chars_at
 pub fn reverse_buffer_chars_at
 pub fn clip_point
 pub fn clip_ignoring_line_ends
 pub fn clip_at_line_end
 pub fn folds_in_range
 pub fn blocks_in_range
 pub fn sticky_header_excerpt
 pub fn block_for_id
 pub fn intersects_fold
 pub fn is_line_folded
 pub fn is_block_line
 pub fn soft_wrap_indent
 pub fn text
 pub fn line
 pub fn line_indent_for_buffer_row
 pub fn line_len
 pub fn longest_row
 pub fn longest_row_in_range
 pub fn starts_indent
 pub fn crease_for_buffer_row
 pub fn text_highlight_ranges
 pub(crate) fn inlay_highlights
 pub fn buffer_header_height
 pub fn excerpt_footer_height
 pub fn excerpt_header_height
pub struct DisplayPoint
impl Debug for DisplayPoint
 fn fmt
impl Add for DisplayPoint
 type Output
 fn add
impl Sub for DisplayPoint
 type Output
 fn sub
pub struct DisplayRow
impl Add<DisplayRow> for DisplayRow
 type Output
 fn add
impl Add<u32> for DisplayRow
 type Output
 fn add
impl Sub<DisplayRow> for DisplayRow
 type Output
 fn sub
impl Sub<u32> for DisplayRow
 type Output
 fn sub
impl DisplayPoint
 pub fn new
 pub fn zero
 pub fn is_zero
 pub fn row
 pub fn column
 pub fn row_mut
 pub fn column_mut
 pub fn to_point
 pub fn to_offset
impl ToDisplayPoint for usize
 fn to_display_point
impl ToDisplayPoint for OffsetUtf16
 fn to_display_point
impl ToDisplayPoint for Point
 fn to_display_point
impl ToDisplayPoint for Anchor
 fn to_display_point
pub mod tests
 async fn test_random_display_map
 async fn test_soft_wraps
 fn test_text_chunks
 async fn test_chunks
 async fn test_chunks_with_syntax_highlighting_across_blocks
 async fn test_chunks_with_diagnostics_across_blocks
 async fn test_point_translation_with_replace_blocks
 async fn test_chunks_with_soft_wrapping
 async fn test_chunks_with_text_highlights
  enum MyType
 fn test_clip_point
  fn assert
 fn test_clip_at_line_ends
  fn assert
 fn test_creases
 fn test_tabs_with_multibyte_chars
 fn test_max_point
 fn syntax_chunks
 fn chunks
 fn init_test
```

</outline>
<rejected>
```zed/crates/editor/src/display_map.rs
    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot.chars_at(offset).map(move |ch| {
            let ret = (ch, offset);
            offset += ch.len_utf8();
            ret
        })
<|editable_region_start|>
    }

    pub fn reverse_buffer_chars_at(
        &self,
        mut offset: usize,
    ) -> impl Iterator<Item = (char, usize)> + '_ {
        self.buffer_snapshot
            .reversed_chars_at(offset)
            .map(move |ch| {
                offset -= ch.len_utf8();
                (ch, offset)
            })
    }

    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {
        let mut clipped = self.block_snapshot.clip_point(point.0, bias);
        if self.clip_at_line_ends {
            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0
        }
        DisplayPoint(clipped)
    }
<|editable_region_end|>
            .map(|(row, block)| (DisplayRow(row), block))
    }

    pub fn sticky_header_excerpt(&self, row: DisplayRow) -> Option<StickyHeaderExcerpt<'_>> {
        self.block_snapshot.sticky_header_excerpt(row.0)
    }

    pub fn block_for_id(&self, id: BlockId) -> Option<Block> {
        self.block_snapshot.block_for_id(id)
    }
```
</rejected>

<labels>
non-local-edit,infer-intent
</labels>
