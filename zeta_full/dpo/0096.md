<events>

</events>
<input>
```zed/crates/extension/src/extension_builder.rs
} else if cfg!(target_os = "windows") {
    Some("wasi-sdk-21.0.m-mingw.tar.gz")
} else {
    None
};

pub struct ExtensionBuilder {
    cache_dir: PathBuf,
    pub http: Arc<dyn HttpClient>,
}

pub struct CompileExtensionOptions {
    pub release: bool,
}

#[derive(Deserialize)]
struct CargoToml {
    package: CargoTomlPackage,
}

#[derive(Deserialize)]
struct CargoTomlPackage {
    name: String,
}

impl ExtensionBuilder {
    pub fn new(http_client: Arc<dyn HttpClient>, cache_dir: PathBuf) -> Self {
        Self {
            cache_dir,
            http: http_client,
<|editable_region_start|>
        }
    }

    pub async fn compile_extension<|user_cursor_is_here|>(
        &self,
        extension_dir: &Path,
        extension_manifest: &mut ExtensionManifest,
        options: CompileExtensionOptions,
    ) -> Result<()> {
        populate_defaults(extension_manifest, extension_dir)?;

        if extension_dir.is_relative() {
            bail!(
                "extension dir {} is not an absolute path",
                extension_dir.display()
            );
        }

        fs::create_dir_all(&self.cache_dir).context("failed to create cache dir")?;
<|editable_region_end|>

        if extension_manifest.lib.kind == Some(ExtensionLibraryKind::Rust) {
            log::info!("compiling Rust extension {}", extension_dir.display());
            self.compile_rust_extension(extension_dir, extension_manifest, options)
                .await
                .context("failed to compile Rust extension")?;
            log::info!("compiled Rust extension {}", extension_dir.display());
        }

        for (grammar_name, grammar_metadata) in &extension_manifest.grammars {
            log::info!(
                "compiling grammar {grammar_name} for extension {}",
                extension_dir.display()
            );
            self.compile_grammar(extension_dir, grammar_name.as_ref(), grammar_metadata)
                .await
                .with_context(|| format!("failed to compile grammar '{grammar_name}'"))?;
            log::info!(
```
</input>
<output>
```zed/crates/extension/src/extension_builder.rs
} else if cfg!(target_os = "windows") {
    Some("wasi-sdk-21.0.m-mingw.tar.gz")
} else {
    None
};

pub struct ExtensionBuilder {
    cache_dir: PathBuf,
    pub http: Arc<dyn HttpClient>,
}

pub struct CompileExtensionOptions {
    pub release: bool,
}

#[derive(Deserialize)]
struct CargoToml {
    package: CargoTomlPackage,
}

#[derive(Deserialize)]
struct CargoTomlPackage {
    name: String,
}

impl ExtensionBuilder {
    pub fn new(http_client: Arc<dyn HttpClient>, cache_dir: PathBuf) -> Self {
        Self {
            cache_dir,
            http: http_client,
<|editable_region_start|>
        }
    }

    pub async fn compile_extension(
        &self,
        extension_dir: &Path,
        extension_manifest: &mut ExtensionManifest,
        options: CompileExtensionOptions,
    ) -> Result<()> {
        populate_defaults(extension_manifest, extension_dir)?;

        if extension_dir.is_relative() {
            bail!(
                "extension dir {} is not an absolute path",
                extension_dir.display()
            );
        }

        fs::create_dir_all(&self.cache_dir).context("failed to create cache dir")?;
<|editable_region_end|>

        if extension_manifest.lib.kind == Some(ExtensionLibraryKind::Rust) {
            log::info!("compiling Rust extension {}", extension_dir.display());
            self.compile_rust_extension(extension_dir, extension_manifest, options)
                .await
                .context("failed to compile Rust extension")?;
            log::info!("compiled Rust extension {}", extension_dir.display());
        }

        for (grammar_name, grammar_metadata) in &extension_manifest.grammars {
            log::info!(
                "compiling grammar {grammar_name} for extension {}",
                extension_dir.display()
            );
            self.compile_grammar(extension_dir, grammar_name.as_ref(), grammar_metadata)
                .await
                .with_context(|| format!("failed to compile grammar '{grammar_name}'"))?;
            log::info!(
```
</output>
<outline>
```crates/extension/src/extension_builder.rs
const RUST_TARGET
const WASI_ADAPTER_URL
const WASI_SDK_URL
const WASI_SDK_ASSET_NAME
pub struct ExtensionBuilder
 cache_dir
 pub http
pub struct CompileExtensionOptions
 pub release
struct CargoToml
 package
struct CargoTomlPackage
 name
impl ExtensionBuilder
 pub fn new
 pub async fn compile_extension
 async fn compile_rust_extension
 async fn compile_grammar
 fn checkout_repo
 fn install_rust_wasm_target_if_needed
 async fn install_wasi_preview1_adapter_if_needed
 async fn install_wasi_sdk_if_needed
 fn strip_custom_sections
fn populate_defaults
 struct GrammarConfigToml
  pub repository
  pub commit
  pub path
```

</outline>
<rejected>
```zed/crates/extension/src/extension_builder.rs
} else if cfg!(target_os = "windows") {
    Some("wasi-sdk-21.0.m-mingw.tar.gz")
} else {
    None
};

pub struct ExtensionBuilder {
    cache_dir: PathBuf,
    pub http: Arc<dyn HttpClient>,
}

pub struct CompileExtensionOptions {
    pub release: bool,
}

#[derive(Deserialize)]
struct CargoToml {
    package: CargoTomlPackage,
}

#[derive(Deserialize)]
struct CargoTomlPackage {
    name: String,
}

impl ExtensionBuilder {
    pub fn new(http_client: Arc<dyn HttpClient>, cache_dir: PathBuf) -> Self {
        Self {
            cache_dir,
            http: http_client,
<|editable_region_start|>
        }

    pub async fn compile_extension(
        &self,
        extension_dir: &Path,
        extension_manifest: &mut ExtensionManifest,
        options: CompileExtensionOptions,
    ) -> Result<()> {
        populate_defaults(extension_manifest, extension_dir)?;

        if extension_dir.is_relative() {
            bail!(
                "extension dir {} is not an absolute path",
                extension_dir.display()
            );
        }

        fs::create_dir_all(&self.cache_dir).context("failed to create cache dir")?;
<|editable_region_end|>

        if extension_manifest.lib.kind == Some(ExtensionLibraryKind::Rust) {
            log::info!("compiling Rust extension {}", extension_dir.display());
            self.compile_rust_extension(extension_dir, extension_manifest, options)
                .await
                .context("failed to compile Rust extension")?;
            log::info!("compiled Rust extension {}", extension_dir.display());
        }

        for (grammar_name, grammar_metadata) in &extension_manifest.grammars {
            log::info!(
                "compiling grammar {grammar_name} for extension {}",
                extension_dir.display()
            );
            self.compile_grammar(extension_dir, grammar_name.as_ref(), grammar_metadata)
                .await
                .with_context(|| format!("failed to compile grammar '{grammar_name}'"))?;
            log::info!(
```
</rejected>

<labels>
no-op,unknown
</labels>
