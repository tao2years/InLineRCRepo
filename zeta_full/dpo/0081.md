<events>
User edited "crates/language/src/buffer.rs":
```diff
@@ -749,7 +749,7 @@
             }
 
             if !edit_text.is_empty() {
-                println!("LINE: ", &self.applied_edits_snapshot.)
+                println!("LINE: ", &self.applied_edits_snapshot)
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -749,6 +749,8 @@
             }
 
             if !edit_text.is_empty() {
+                let range= 
+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                 println!("LINE: ", &self.applied_edits_snapshot)
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -750,7 +750,7 @@
 
             if !edit_text.is_empty() {
                 let range= 
-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshotl
                 println!("LINE: ", &self.applied_edits_snapshot)
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -749,8 +749,8 @@
             }
 
             if !edit_text.is_empty() {
-                let range= 
-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshotl
+                let range=
+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
                 println!("LINE: ", &self.applied_edits_snapshot)
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -751,7 +751,7 @@
             if !edit_text.is_empty() {
                 let range=
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: ", &self.applied_edits_snapshot)
+                println!("LINE: ", range.to_po)
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -751,7 +751,7 @@
             if !edit_text.is_empty() {
                 let range=
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: ", range.to_po)
+                println!("LINE: ", range.to_point(snapshot))
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -751,7 +751,7 @@
             if !edit_text.is_empty() {
                 let range=
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: ", range.to_point(snapshot))
+                println!("LINE: ", range.to_point(&self.applied_edits_snapshot))
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -749,9 +749,8 @@
             }
 
             if !edit_text.is_empty() {
-                let range=
-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: ", range.to_point(&self.applied_edits_snapshot))
+                let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
+                println!("LINE: ", range.to_point(&self.applied_edits_snapshot));
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -750,7 +750,7 @@
 
             if !edit_text.is_empty() {
                 let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: ", range.to_point(&self.applied_edits_snapshot));
+                println!("LINE: {:?}", range.to_point(&self.applied_edits_snapshot));
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -750,7 +750,6 @@
 
             if !edit_text.is_empty() {
                 let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;
-                println!("LINE: {:?}", range.to_point(&self.applied_edits_snapshot));
                 highlighted_text.add_text_from_buffer_range(
                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,
                     &self.applied_edits_snapshot,

```

User edited "crates/language/src/buffer.rs":
```diff
@@ -591,6 +591,7 @@
 pub struct HighlightedText {
     pub text: SharedString,
     pub highlights: Vec<(Range<usize>, HighlightStyle)>,
+    pub first_touched_line
 }
 
 #[derive(Default, Debug)]

```


</events>
<input>
```zed/crates/language/src/buffer.rs
    pub fn from_buffer_range<T: ToOffset>(
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) -> Self {
        let mut highlighted_text = HighlightedTextBuilder::default();
        highlighted_text.add_text_from_buffer_range(
            range,
            snapshot,
            syntax_snapshot,
            override_style,
            syntax_theme,
        );
        highlighted_text.build()
    }

    pub fn to_styled_text(&self, default_style: &TextStyle) -> StyledText {
        gpui::StyledText::new(self.text.clone())
            .with_highlights(default_style, self.highlights.iter().cloned())
    }
}

<|editable_region_start|>
impl HighlightedTextBuilder {
    pub fn build(self) -> HighlightedText {
        HighlightedText {
            text: self.text.into(),
            highlights: self.highlights,
            first_touched_line: self.first_touched_line,
        }
    }
    
    p<|user_cursor_is_here|>

    pub fn add_text_from_buffer_range<T: ToOffset>(
        &mut self,
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) {
        let range = range.to_offset(snapshot);
        for chunk in Self::highlighted_chunks(range, snapshot, syntax_snapshot) {
<|editable_region_end|>
            let start = self.text.len();
            self.text.push_str(chunk.text);
            let end = self.text.len();

            if let Some(mut highlight_style) = chunk
                .syntax_highlight_id
                .and_then(|id| id.style(syntax_theme))
            {
                if let Some(override_style) = override_style {
                    highlight_style.highlight(override_style);
                }
                self.highlights.push((start..end, highlight_style));
            } else if let Some(override_style) = override_style {
                self.highlights.push((start..end, override_style));
            }
        }
    }

    fn highlighted_chunks<'a>(
        range: Range<usize>,
        snapshot: &'a text::BufferSnapshot,
        syntax_snapshot: &'a SyntaxSnapshot,
```
</input>
<output>
```zed/crates/language/src/buffer.rs
    pub fn from_buffer_range<T: ToOffset>(
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) -> Self {
        let mut highlighted_text = HighlightedTextBuilder::default();
        highlighted_text.add_text_from_buffer_range(
            range,
            snapshot,
            syntax_snapshot,
            override_style,
            syntax_theme,
        );
        highlighted_text.build()
    }

    pub fn to_styled_text(&self, default_style: &TextStyle) -> StyledText {
        gpui::StyledText::new(self.text.clone())
            .with_highlights(default_style, self.highlights.iter().cloned())
    }
}

<|editable_region_start|>
impl HighlightedTextBuilder {
    pub fn build(self) -> HighlightedText {
        HighlightedText {
            text: self.text.into(),
            highlights: self.highlights,
            first_touched_line: self.first_touched_line,
        }
    }
    
    pub fn new() -> Self {
        Self {
            text: String::new(),
            highlights: Vec::new(),
            first_touched_line: None,
        }
    }
    
    pub fn add_text_from_buffer_range<T: ToOffset>(
        &mut self,
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) {
        let range = range.to_offset(snapshot);
        for chunk in Self::highlighted_chunks(range, snapshot, syntax_snapshot) {
<|editable_region_end|>
            let start = self.text.len();
            self.text.push_str(chunk.text);
            let end = self.text.len();

            if let Some(mut highlight_style) = chunk
                .syntax_highlight_id
                .and_then(|id| id.style(syntax_theme))
            {
                if let Some(override_style) = override_style {
                    highlight_style.highlight(override_style);
                }
                self.highlights.push((start..end, highlight_style));
            } else if let Some(override_style) = override_style {
                self.highlights.push((start..end, override_style));
            }
        }
    }

    fn highlighted_chunks<'a>(
        range: Range<usize>,
        snapshot: &'a text::BufferSnapshot,
        syntax_snapshot: &'a SyntaxSnapshot,
```
</output>
<outline>
```crates/language/src/buffer.rs
pub static BUFFER_DIFF_TASK
pub enum Capability
 ReadWrite
 ReadOnly
pub type BufferRow
pub struct Buffer
 text
 branch_state
 file
 saved_mtime
 saved_version
 preview_version
 transaction_depth
 was_dirty_before_starting_transaction
 reload_task
 language
 autoindent_requests
 pending_autoindent
 sync_parse_timeout
 syntax_map
 parsing_in_background
 parse_status
 non_text_state_update_count
 diagnostics
 remote_selections
 diagnostics_timestamp
 completion_triggers
 completion_triggers_per_language_server
 completion_triggers_timestamp
 deferred_ops
 capability
 has_conflict
 has_unsaved_edits
 _subscriptions
pub enum ParseStatus
 Idle
 Parsing
struct BufferBranchState
 base_buffer
 merged_operations
pub struct BufferSnapshot
 pub text
 pub(crate) syntax
 file
 diagnostics
 remote_selections
 language
 non_text_state_update_count
pub struct IndentSize
 pub len
 pub kind
pub enum IndentKind
 Space
 Tab
pub enum CursorShape
 Bar
 Block
 Underline
 Hollow
struct SelectionSet
 line_mode
 cursor_shape
 selections
 lamport_timestamp
pub struct Diagnostic
 pub source
 pub code
 pub severity
 pub message
 pub group_id
 pub is_primary
 pub is_disk_based
 pub is_unnecessary
 pub data
pub async fn prepare_completion_documentation
pub enum CompletionDocumentation
 Undocumented
 SingleLine
 MultiLinePlainText
 MultiLineMarkdown
pub enum Operation
 Buffer
 UpdateDiagnostics
  server_id
  diagnostics
  lamport_timestamp
 UpdateSelections
  selections
  lamport_timestamp
  line_mode
  cursor_shape
 UpdateCompletionTriggers
  triggers
  lamport_timestamp
  server_id
pub enum BufferEvent
 Operation
  operation
  is_local
 Edited
 DirtyChanged
 Saved
 FileHandleChanged
 Reloaded
 ReloadNeeded
 LanguageChanged
 Reparsed
 DiagnosticsUpdated
 CapabilityChanged
 Closed
 Discarded
pub trait File
 fn as_local
 fn is_local
 fn disk_state
 fn path
 fn full_path
 fn file_name
 fn worktree_id
 fn as_any
 fn to_proto
 fn is_private
pub enum DiskState
 New
 Present
  mtime
 Deleted
impl DiskState
 pub fn mtime
pub trait LocalFile
 fn abs_path
 fn load
 fn load_bytes
pub enum AutoindentMode
 EachLine
 Block
  original_indent_columns
struct AutoindentRequest
 before_edit
 entries
 is_block_mode
 ignore_empty_lines
struct AutoindentRequestEntry
 range
 first_line_is_new
 indent_size
 original_indent_column
struct IndentSuggestion
 basis_row
 delta
 within_error
struct BufferChunkHighlights
 captures
 next_capture
 stack
 highlight_maps
pub struct BufferChunks
 buffer_snapshot
 range
 chunks
 diagnostic_endpoints
 error_depth
 warning_depth
 information_depth
 hint_depth
 unnecessary_depth
 highlights
pub struct Chunk
 pub text
 pub syntax_highlight_id
 pub highlight_style
 pub diagnostic_severity
 pub is_unnecessary
 pub is_tab
 pub renderer
pub struct ChunkRenderer
 pub render
 pub constrain_width
pub struct ChunkRendererContext
 pub window
 pub context
 pub max_width
impl fmt::Debug for ChunkRenderer
 fn fmt
impl Deref for ChunkRendererContext<'a, 'b>
 type Target
 fn deref
impl DerefMut for ChunkRendererContext<'a, 'b>
 fn deref_mut
pub struct Diff
 pub(crate) base_version
 line_ending
 pub edits
pub(crate) struct DiagnosticEndpoint
 offset
 is_start
 severity
 is_unnecessary
pub enum CharKind
 Whitespace
 Punctuation
 Word
pub struct Runnable
 pub tags
 pub language
 pub buffer
pub struct HighlightedText
 pub text
 pub highlights
 pub first_touched_line
struct HighlightedTextBuilder
 pub text
 pub highlights
impl HighlightedText
 pub fn from_buffer_range
 pub fn to_styled_text
impl HighlightedTextBuilder
 pub fn build
 pub fn add_text_from_buffer_range
 fn highlighted_chunks
pub struct EditPreview
 old_snapshot
 applied_edits_snapshot
 syntax_snapshot
impl EditPreview
 pub fn highlight_edits
 fn compute_visible_range
impl Buffer
 pub fn local
 pub fn local_normalized
 pub fn remote
 pub fn from_proto
 pub fn to_proto
 pub fn serialize_ops
 pub fn with_language
 pub fn capability
 pub fn read_only
 pub fn build
 pub fn build_snapshot
 pub fn snapshot
 pub fn branch
 pub fn preview_edits
 pub fn merge_into_base
 fn on_base_buffer_event
 pub(crate) fn as_text_snapshot
 pub fn text_snapshot
 pub fn file
 pub fn saved_version
 pub fn saved_mtime
 pub fn set_language
 pub fn set_language_registry
 pub fn language_registry
 pub fn set_capability
 pub fn did_save
 pub fn discarded
 pub fn reload
 pub fn did_reload
 pub fn file_updated
 pub fn base_buffer
 pub fn language
 pub fn language_at
 pub fn non_text_state_update_count
 pub fn is_parsing
 pub fn contains_unknown_injections
 pub fn set_sync_parse_timeout
 pub fn reparse
 fn did_finish_parsing
 pub fn parse_status
 pub fn update_diagnostics
 fn request_autoindent
 fn compute_autoindents
 fn apply_autoindents
 pub fn edit_for_indent_size_adjustment
 pub fn diff
 pub fn remove_trailing_whitespace
 pub fn ensure_final_newline
 pub fn apply_diff
 fn has_unsaved_edits
 pub fn is_dirty
 pub fn has_conflict
 pub fn subscribe
 pub fn start_transaction
 pub fn start_transaction_at
 pub fn end_transaction
 pub fn end_transaction_at
 pub fn push_transaction
 pub fn finalize_last_transaction
 pub fn group_until_transaction
 pub fn forget_transaction
 pub fn merge_transactions
 pub fn wait_for_edits
 pub fn wait_for_anchors
 pub fn wait_for_version
 pub fn give_up_waiting
 pub fn set_active_selections
 pub fn remove_active_selections
 pub fn set_text
 pub fn edit
 fn did_edit
 pub fn autoindent_ranges
 pub fn insert_empty_line
 pub fn apply_ops
 fn flush_deferred_ops
 pub fn has_deferred_ops
 fn can_apply_op
 fn apply_op
 fn apply_diagnostic_update
 fn send_operation
 pub fn remove_peer
 pub fn undo
 pub fn undo_transaction
 pub fn undo_to_transaction
 pub fn undo_operations
 pub fn redo
 pub fn redo_to_transaction
 pub fn set_completion_triggers
 pub fn completion_triggers
 pub fn refresh_preview
 pub fn preserve_preview
impl Buffer
 pub fn edit_via_marked_text
 pub fn set_group_interval
 pub fn randomly_edit
 pub fn randomly_undo_redo
impl EventEmitter<BufferEvent> for Buffer
impl Deref for Buffer
 type Target
 fn deref
impl BufferSnapshot
 pub fn indent_size_for_line
 pub fn language_indent_size_at
 pub fn suggested_indents
 fn suggest_autoindents
 fn prev_non_blank_row
 fn get_highlights
 pub fn chunks
 pub fn highlighted_text_for_range
 fn for_each_line
 pub fn syntax_layers
 pub fn syntax_layer_at
 pub fn language
 pub fn language_at
 pub fn settings_at
 pub fn char_classifier_at
 pub fn language_scope_at
 pub fn surrounding_word
 pub fn syntax_ancestor
 pub fn outline
 pub fn symbols_containing
 pub fn outline_range_containing
 pub fn outline_items_containing
 fn next_outline_item
 pub fn function_body_fold_ranges
 pub fn matches
 pub fn bracket_ranges
 pub fn text_object_ranges
 pub fn enclosing_bracket_ranges
 pub fn innermost_enclosing_bracket_ranges
 pub fn redacted_ranges
 pub fn injections_intersecting_range
 pub fn runnable_ranges
 pub fn selections_in_range
 pub fn has_diagnostics
 pub fn diagnostics_in_range
 pub fn diagnostic_groups
 pub fn diagnostic_group
 pub fn non_text_state_update_count
 pub fn file
 pub fn resolve_file_path
fn indent_size_for_line
fn indent_size_for_text
impl Clone for BufferSnapshot
 fn clone
impl Deref for BufferSnapshot
 type Target
 fn deref
impl Send for BufferChunks<'a>
impl BufferChunks<'a>
 pub(crate) fn new
 pub fn seek
 fn initialize_diagnostic_endpoints
 pub fn offset
 pub fn range
 fn update_diagnostic_depths
 fn current_diagnostic_severity
 fn current_code_is_unnecessary
impl Iterator for BufferChunks<'a>
 type Item
 fn next
impl operation_queue::Operation for Operation
 fn lamport_timestamp
impl Default for Diagnostic
 fn default
impl IndentSize
 pub fn spaces
 pub fn tab
 pub fn chars
 pub fn char
 pub fn with_delta
 pub fn len_with_expanded_tabs
pub struct TestFile
 pub path
 pub root_name
impl File for TestFile
 fn path
 fn full_path
 fn as_local
 fn disk_state
 fn file_name
 fn worktree_id
 fn as_any
 fn to_proto
 fn is_private
pub(crate) fn contiguous_ranges
pub struct CharClassifier
 scope
 for_completion
 ignore_punctuation
impl CharClassifier
 pub fn new
 pub fn for_completion
 pub fn ignore_punctuation
 pub fn is_whitespace
 pub fn is_word
 pub fn is_punctuation
 pub fn kind_with
 pub fn kind
pub fn trailing_whitespace_ranges
```

</outline>
<rejected>
```zed/crates/language/src/buffer.rs
    pub fn from_buffer_range<T: ToOffset>(
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) -> Self {
        let mut highlighted_text = HighlightedTextBuilder::default();
        highlighted_text.add_text_from_buffer_range(
            range,
            snapshot,
            syntax_snapshot,
            override_style,
            syntax_theme,
        );
        highlighted_text.build()
    }

    pub fn to_styled_text(&self, default_style: &TextStyle) -> StyledText {
        gpui::StyledText::new(self.text.clone())
            .with_highlights(default_style, self.highlights.iter().cloned())
    }
}

<|editable_region_start|>
impl HighlightedTextBuilder {
    pub fn build(self) -> HighlightedText {
        HighlightedText {
            text: self.text.into(),
            highlights: self.highlights,
            first_touched_line: self.first_touched_line,
        }
    }
    
    pub fn add_text_from_buffer_range<T: ToOffset>(
        &mut self,
        range: Range<T>,
        snapshot: &text::BufferSnapshot,
        syntax_snapshot: &SyntaxSnapshot,
        override_style: Option<HighlightStyle>,
        syntax_theme: &SyntaxTheme,
    ) {
        let range = range.to_offset(snapshot);
        for chunk in Self::highlighted_chunks(range, snapshot, syntax_snapshot) {
<|editable_region_end|>
            let start = self.text.len();
            self.text.push_str(chunk.text);
            let end = self.text.len();

            if let Some(mut highlight_style) = chunk
                .syntax_highlight_id
                .and_then(|id| id.style(syntax_theme))
            {
                if let Some(override_style) = override_style {
                    highlight_style.highlight(override_style);
                }
                self.highlights.push((start..end, highlight_style));
            } else if let Some(override_style) = override_style {
                self.highlights.push((start..end, override_style));
            }
        }
    }

    fn highlighted_chunks<'a>(
        range: Range<usize>,
        snapshot: &'a text::BufferSnapshot,
        syntax_snapshot: &'a SyntaxSnapshot,
```
</rejected>

<labels>
local-edit,complete-implementation
</labels>
