<events>
User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -278,7 +278,7 @@
             return Task::ready(Err(anyhow!("thread store not available")));
         };
         
-        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx))
+        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
 
         let Some(thread) = self
             .thread_store

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -277,17 +277,8 @@
         else {
             return Task::ready(Err(anyhow!("thread store not available")));
         };
-        
-        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
 
-        let Some(thread) = self
-            .thread_store
-            .clone()
-            .and_then(|this| this.upgrade())
-            .and_then(|this| this.update(cx, |this, cx| this.open_thread(&thread.id, cx)))
-        else {
-            return;
-        };
+        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
 
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,8 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-
+        cx.spawn
+        
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);
         });

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,7 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-        cx.spawn
+        cx.spawn()
         
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,7 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-        cx.spawn()
+        cx.spawn(cx, |this, cx| )
         
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,7 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-        cx.spawn(cx, |this, cx| )
+        cx.spawn(|)
         
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,9 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-        cx.spawn(|)
+        cx.spawn(|this, cx| async move {
+            
+        })
         
         context_store.update(cx, |context_store, cx| {
             context_store.add_thread(thread, cx);

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -280,14 +280,12 @@
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
         cx.spawn(|this, cx| async move {
-            
+            context_store.update(cx, |context_store, cx| {
+                context_store.add_thread(thread, cx);
+            });
+
+            cx.notify();
         })
-        
-        context_store.update(cx, |context_store, cx| {
-            context_store.add_thread(thread, cx);
-        });
-
-        cx.notify();
     }
 
     fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -279,7 +279,7 @@
         };
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
-        cx.spawn(|this, cx| async move {
+        cx.spawn(|this, mut cx| async move {
             context_store.update(cx, |context_store, cx| {
                 context_store.add_thread(thread, cx);
             });

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -280,7 +280,7 @@
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
         cx.spawn(|this, mut cx| async move {
-            context_store.update(cx, |context_store, cx| {
+            context_store.update(&mut cx, |context_store, cx| {
                 context_store.add_thread(thread, cx);
             });
 

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -280,6 +280,7 @@
 
         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
         cx.spawn(|this, mut cx| async move {
+            let thread = open_thread_task.await?;
             context_store.update(&mut cx, |context_store, cx| {
                 context_store.add_thread(thread, cx);
             });

```

User edited "crates/assistant2/src/context_picker.rs":
```diff
@@ -286,6 +286,8 @@
             });
 
             cx.notify();
+            
+            anyhow:
         })
     }
 

```
</events>
<input>
```crates/assistant2/src/context_picker.rs
        });

        cx.spawn(|_, mut cx| async move { task.await.notify_async_err(&mut cx) })
            .detach();

        cx.notify();
    }

    fn add_recent_thread(
        &self,
        thread: ThreadContextEntry,
        cx: &mut ViewContext<Self>,
    ) -> Task<Result<()>> {
        let Some(context_store) = self.context_store.upgrade() else {
            return Task::ready(Err(anyhow!("context store not available")));
        };

        let Some(thread_store) = self
<|editable_region_start|>
            .thread_store
            .and_then(|thread_store| thread_store.upgrade())
        else {
            return Task::ready(Err(anyhow!("thread store not available")));
        };

        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
        cx.spawn(|this, mut cx| async move {
            let thread = open_thread_task.await?;
            context_store.update(&mut cx, |context_store, cx| {
                context_store.add_thread(thread, cx);
            });

            cx.notify();
            
            anyhow:<|user_cursor_is_here|>
        })
    }

    fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {
        let Some(workspace) = self.workspace.upgrade().map(|w| w.read(cx)) else {
            return vec![];
        };

        let Some(context_store) = self.context_store.upgrade().map(|cs| cs.read(cx)) else {
            return vec![];
        };

        let mut recent = Vec::with_capacity(6);

        let mut current_files = context_store.file_paths(cx);

        if let Some(active_path) = Self::active_singleton_buffer_path(&workspace, cx) {
            current_files.insert(active_path);
        }

        let project = workspace.project().read(cx);

        recent.extend(
            workspace
<|editable_region_end|>
                .recent_navigation_history_iter(cx)
                .filter(|(path, _)| !current_files.contains(&path.path.to_path_buf()))
                .take(4)
                .filter_map(|(project_path, _)| {
                    project
                        .worktree_for_id(project_path.worktree_id, cx)
                        .map(|worktree| RecentEntry::File {
                            project_path,
                            path_prefix: worktree.read(cx).root_name().into(),
```
</input>
<output>
```crates/assistant2/src/context_picker.rs
        });

        cx.spawn(|_, mut cx| async move { task.await.notify_async_err(&mut cx) })
            .detach();

        cx.notify();
    }

    fn add_recent_thread(
        &self,
        thread: ThreadContextEntry,
        cx: &mut ViewContext<Self>,
    ) -> Task<Result<()>> {
        let Some(context_store) = self.context_store.upgrade() else {
            return Task::ready(Err(anyhow!("context store not available")));
        };

        let Some(thread_store) = self
<|editable_region_start|>
            .thread_store
            .and_then(|thread_store| thread_store.upgrade())
        else {
            return Task::ready(Err(anyhow!("thread store not available")));
        };

        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
        cx.spawn(|this, mut cx| async move {
            let thread = open_thread_task.await?;
            context_store.update(&mut cx, |context_store, cx| {
                context_store.add_thread(thread, cx);
            });

            cx.notify();
            
            anyhow::Ok(())
        })
    }

    fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {
        let Some(workspace) = self.workspace.upgrade().map(|w| w.read(cx)) else {
            return vec![];
        };

        let Some(context_store) = self.context_store.upgrade().map(|cs| cs.read(cx)) else {
            return vec![];
        };

        let mut recent = Vec::with_capacity(6);

        let mut current_files = context_store.file_paths(cx);

        if let Some(active_path) = Self::active_singleton_buffer_path(&workspace, cx) {
            current_files.insert(active_path);
        }

        let project = workspace.project().read(cx);

        recent.extend(
            workspace
<|editable_region_end|>
                .recent_navigation_history_iter(cx)
                .filter(|(path, _)| !current_files.contains(&path.path.to_path_buf()))
                .take(4)
                .filter_map(|(project_path, _)| {
                    project
                        .worktree_for_id(project_path.worktree_id, cx)
                        .map(|worktree| RecentEntry::File {
                            project_path,
                            path_prefix: worktree.read(cx).root_name().into(),
```
</output>
<outline>
```crates/assistant2/src/context_picker.rs
mod directory_context_picker
mod fetch_context_picker
mod file_context_picker
mod thread_context_picker
pub enum ConfirmBehavior
 KeepOpen
 Close
enum ContextPickerMode
 Default
 File
 Directory
 Fetch
 Thread
pub(super) struct ContextPicker
 mode
 workspace
 editor
 context_store
 thread_store
 confirm_behavior
impl ContextPicker
 pub fn new
 pub fn init
 fn build_menu
 pub fn allow_threads
 fn select_kind
 fn recent_menu_item
 fn add_recent_file
 fn add_recent_thread
 fn recent_entries
 fn active_singleton_buffer_path
impl EventEmitter<DismissEvent> for ContextPicker
impl FocusableView for ContextPicker
 fn focus_handle
impl Render for ContextPicker
 fn render
enum RecentEntry
 File
  project_path
  path_prefix
 Thread
```

</outline>
<rejected>
```crates/assistant2/src/context_picker.rs
        });

        cx.spawn(|_, mut cx| async move { task.await.notify_async_err(&mut cx) })
            .detach();

        cx.notify();
    }

    fn add_recent_thread(
        &self,
        thread: ThreadContextEntry,
        cx: &mut ViewContext<Self>,
    ) -> Task<Result<()>> {
        let Some(context_store) = self.context_store.upgrade() else {
            return Task::ready(Err(anyhow!("context store not available")));
        };

        let Some(thread_store) = self
<|editable_region_start|>
            .thread_store
            .and_then(|thread_store| thread_store.upgrade())
        else {
            return Task::ready(Err(anyhow!("thread store not available")));
        };

        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));
        cx.spawn(|this, mut cx| async move {
            let thread = open_thread_task.await?;
            context_store.update(&mut cx, |context_store, cx| {
                context_store.add_thread(thread, cx);
            });

            cx.notify();
        })
    }

    fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {
        let Some(workspace) = self.workspace.upgrade().map(|w| w.read(cx)) else {
            return vec![];
        };

        let Some(context_store) = self.context_store.upgrade().map(|cs| cs.read(cx)) else {
            return vec![];
        };

        let mut recent = Vec::with_capacity(6);

        let mut current_files = context_store.file_paths(cx);

        if let Some(active_path) = Self::active_singleton_buffer_path(&workspace, cx) {
            current_files.insert(active_path);
        }

        let project = workspace.project().read(cx);

        recent.extend(
            workspace
<|editable_region_end|>
                .recent_navigation_history_iter(cx)
                .filter(|(path, _)| !current_files.contains(&path.path.to_path_buf()))
                .take(4)
                .filter_map(|(project_path, _)| {
                    project
                        .worktree_for_id(project_path.worktree_id, cx)
                        .map(|worktree| RecentEntry::File {
                            project_path,
                            path_prefix: worktree.read(cx).root_name().into(),
```
</rejected>

<labels>
local-edit,complete-implementation
</labels>
