<events>
User edited "app/queries/recon.py":
```diff
@@ -393,6 +393,7 @@
     def download_recon_file(
         cls, session: Session, org_id: str, recon_id: int
     ) -> io.BytesIO:
+        
         job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()
         storage = OrgStorage(org_id)
         buffer = storage.download(job.result_location)  # type: ignore

```
</events>
<input>
```app/queries/recon.py
        for col in columns:
            sub_df = df[col]
            sub_a = sub_df["A"]
            sub_b = sub_df["B"]
            data.append(
                ReconColumnData(
                    field_name=col,
                    value_a=list(sub_a),
                    value_b=list(sub_b),
                    matches=list(sub_a == sub_b),
                )
            )

        return ReconDetails(
            pk_name=job.config.pk_a.name, pk_data=list(df.index), fields=data
        )
<|editable_region_start|>

    @classmethod
    def patch_config(cls, session: Session, recon_id: int, patch: ReconPatch):
        if patch.scheduled and patch.schedule is None:
            raise HTTPException(
                422,
                [
                    make_error(
                        "schedule", "schedule is required if schedule_run is true"
                    )
                ],
            )

        if (
            patch.scheduled
            and patch.schedule
            and not (re.match(r"^\d+[HD]$", patch.schedule))
        ):
            raise HTTPException(
                422,
                [make_error("schedule", "schedule must be <number>D or <number>H")],
            )

        config = cls._config_by_job_id(session, recon_id)
        config.schedule = patch.scheduled
        config.schedule_run = patch.schedule
        session.commit()

    @classmethod
    def download_recon_file(
        cls, session: Session, org_id: str, recon_id: int
    ) -> io.BytesIO:
        <|user_cursor_is_here|>
        job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()
        storage = OrgStorage(org_id)
        buffer = storage.download(job.result_location)  # type: ignore
        df = pd.read_parquet(buffer)
        df.drop(["_exclusive"], axis=1, level=0, inplace=True)
        buffer = io.BytesIO()
        df.to_csv(buffer)
        buffer.seek(0)
        return buffer

    @classmethod
    def _config_by_job_id(cls, session: Session, recon_id: int) -> ReconConfig:
        query = session.query(ReconJob).filter(ReconJob.id == recon_id)
        result: ReconJob = query.one()
        config: ReconConfig = result.config
        return config

<|editable_region_end|>
```
</input>
<output>
```app/queries/recon.py
        for col in columns:
            sub_df = df[col]
            sub_a = sub_df["A"]
            sub_b = sub_df["B"]
            data.append(
                ReconColumnData(
                    field_name=col,
                    value_a=list(sub_a),
                    value_b=list(sub_b),
                    matches=list(sub_a == sub_b),
                )
            )

        return ReconDetails(
            pk_name=job.config.pk_a.name, pk_data=list(df.index), fields=data
        )
<|editable_region_start|>

    @classmethod
    def patch_config(cls, session: Session, recon_id: int, patch: ReconPatch):
        if patch.scheduled and patch.schedule is None:
            raise HTTPException(
                422,
                [
                    make_error(
                        "schedule", "schedule is required if schedule_run is true"
                    )
                ],
            )

        if (
            patch.scheduled
            and patch.schedule
            and not (re.match(r"^\d+[HD]$", patch.schedule))
        ):
            raise HTTPException(
                422,
                [make_error("schedule", "schedule must be <number>D or <number>H")],
            )

        config = cls._config_by_job_id(session, recon_id)
        config.schedule = patch.scheduled
        config.schedule_run = patch.schedule
        session.commit()

    @classmethod
    def download_recon_file(
        cls, session: Session, org_id: str, recon_id: int
    ) -> io.BytesIO:
        
        job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()
        storage = OrgStorage(org_id)
        buffer = storage.download(job.result_location)  # type: ignore
        df = pd.read_parquet(buffer)
        df.drop(["_exclusive"], axis=1, level=0, inplace=True)
        buffer = io.BytesIO()
        df.to_csv(buffer)
        buffer.seek(0)
        return buffer

    @classmethod
    def _config_by_job_id(cls, session: Session, recon_id: int) -> ReconConfig:
        query = session.query(ReconJob).filter(ReconJob.id == recon_id)
        result: ReconJob = query.one()
        config: ReconConfig = result.config
        return config

<|editable_region_end|>
```
</output>
<outline>
```app/queries/recon.py
def make_error
class ReconQueries
 def get_all_sources
 def get_all_job
 def get_job
 def create_new
 def run_from_config
 def get_config_by_recon_job_id
 def delete_recon_config_by_recon_id
 def start_recon
 def get_details
 def patch_config
 def download_recon_file
 def _config_by_job_id
```

</outline>
<rejected>
```app/queries/recon.py
        for col in columns:
            sub_df = df[col]
            sub_a = sub_df["A"]
            sub_b = sub_df["B"]
            data.append(
                ReconColumnData(
                    field_name=col,
                    value_a=list(sub_a),
                    value_b=list(sub_b),
                    matches=list(sub_a == sub_b),
                )
            )

        return ReconDetails(
            pk_name=job.config.pk_a.name, pk_data=list(df.index), fields=data
        )
<|editable_region_start|>

    @classmethod
    def patch_config(cls, session: Session, recon_id: int, patch: ReconPatch):
        if patch.scheduled and patch.schedule is None:
            raise HTTPException(
                422,
                [
                    make_error(
                        "schedule", "schedule is required if schedule_run is true"
                    )
                ],
            )

        if (
            patch.scheduled
            and patch.schedule
            and not (re.match(r"^\d+[HD]$", patch.schedule))
        ):
            raise HTTPException(
                422,
                [make_error("schedule", "schedule must be <number>D or <number>H")],
            )

        config = cls._config_by_job_id(session, recon_id)
        config.schedule = patch.scheduled
        config.schedule_run = patch.schedule
        session.commit()

    @classmethod
    def download_recon_file(
        cls, session: Session, org_id: str, recon_id: int
    ) -> io.BytesIO:
        job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()
        storage = OrgStorage(org_id)
        buffer = storage.download(job.result_location)  # type: ignore
        df = pd.read_parquet(buffer)
        df.drop(["_exclusive"], axis=1, level=0, inplace=True)
        buffer = io.BytesIO()
        df.to_csv(buffer)
        buffer.seek(0)
        return buffer

    @classmethod
    def _config_by_job_id(cls, session: Session, recon_id: int) -> ReconConfig:
        query = session.query(ReconJob).filter(ReconJob.id == recon_id)
        result: ReconJob = query.one()
        config: ReconConfig = result.config
        return config

<|editable_region_end|>
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
