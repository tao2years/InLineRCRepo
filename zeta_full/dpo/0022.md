<events>
User edited "crates/rope/src/rope.rs":
```diff
@@ -450,6 +450,8 @@
         self.clip_point(Point::new(row, u32::MAX), Bias::Left)
             .column
     }
+    
+    pub fn ptr_eq(&self, other: &elf
 }
 
 impl<'a> From<&'a str> for Rope {

```
</events>
<input>
```crates/rope/src/rope.rs
            *cursor.start() + chunk.as_slice().clip_offset_utf16(overshoot, bias)
        } else {
<|editable_region_start|>
            self.summary().len_utf16
        }
    }
<|user_cursor_is_here|>
    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {
        let mut cursor = self.chunks.cursor::<Point>(&());
        cursor.seek(&point, Bias::Right, &());
        if let Some(chunk) = cursor.item() {
            let overshoot = point - cursor.start();
            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)
        } else {
<|editable_region_end|>
            self.summary().lines
        }
    }

    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {
        let mut cursor = self.chunks.cursor::<PointUtf16>(&());
        cursor.seek(&point.0, Bias::Right, &());
        if let Some(chunk) = cursor.item() {
            let overshoot = Unclipped(point.0 - cursor.start());
            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)
        } else {
            self.summary().lines_utf16()
        }
    }

    pub fn line_len(&self, row: u32) -> u32 {
        self.clip_point(Point::new(row, u32::MAX), Bias::Left)
            .column
    }
    
    pub fn ptr_eq(&self, other: &elf
}

impl<'a> From<&'a str> for Rope {
    fn from(text: &'a str) -> Self {
        let mut rope = Self::new();
        rope.push(text);
        rope
    }
}

impl<'a> FromIterator<&'a str> for Rope {
    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {
        let mut rope = Rope::new();
        for chunk in iter {
            rope.push(chunk);
        }
        rope
    }
}

impl From<String> for Rope {
    fn from(text: String) -> Self {
        Rope::from(text.as_str())
    }
}

impl fmt::Display for Rope {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for chunk in self.chunks() {
            write!(f, "{}", chunk)?;
        }
        Ok(())
    }
```
</input>
<output>
```crates/rope/src/rope.rs
            *cursor.start() + chunk.as_slice().clip_offset_utf16(overshoot, bias)
        } else {
<|editable_region_start|>
            self.summary().len_utf16
        }
    }

    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {
        let mut cursor = self.chunks.cursor::<Point>(&());
        cursor.seek(&point, Bias::Right, &());
        if let Some(chunk) = cursor.item() {
            let overshoot = point - cursor.start();
            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)
        } else {
<|editable_region_end|>
            self.summary().lines
        }
    }

    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {
        let mut cursor = self.chunks.cursor::<PointUtf16>(&());
        cursor.seek(&point.0, Bias::Right, &());
        if let Some(chunk) = cursor.item() {
            let overshoot = Unclipped(point.0 - cursor.start());
            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)
        } else {
            self.summary().lines_utf16()
        }
    }

    pub fn line_len(&self, row: u32) -> u32 {
        self.clip_point(Point::new(row, u32::MAX), Bias::Left)
            .column
    }
    
    pub fn ptr_eq(&self, other: &elf
}

impl<'a> From<&'a str> for Rope {
    fn from(text: &'a str) -> Self {
        let mut rope = Self::new();
        rope.push(text);
        rope
    }
}

impl<'a> FromIterator<&'a str> for Rope {
    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {
        let mut rope = Rope::new();
        for chunk in iter {
            rope.push(chunk);
        }
        rope
    }
}

impl From<String> for Rope {
    fn from(text: String) -> Self {
        Rope::from(text.as_str())
    }
}

impl fmt::Display for Rope {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for chunk in self.chunks() {
            write!(f, "{}", chunk)?;
        }
        Ok(())
    }
```
</output>
<outline>
```crates/rope/src/rope.rs
mod chunk
mod offset_utf16
mod point
mod point_utf16
mod unclipped
pub struct Rope
 chunks
pub fn new
pub fn append
pub fn replace
pub fn slice
pub fn slice_rows
pub fn push
 const PARALLEL_THRESHOLD
 const PARALLEL_THRESHOLD
fn push_large
 const MIN_CHUNK_SIZE
 const PARALLEL_THRESHOLD
 const PARALLEL_THRESHOLD
fn push_chunk
pub fn push_front
fn check_invariants
pub fn summary
pub fn len
pub fn is_empty
pub fn max_point
pub fn max_point_utf16
pub fn cursor
pub fn chars
pub fn chars_at
pub fn reversed_chars_at
pub fn bytes_in_range
pub fn reversed_bytes_in_range
pub fn chunks
pub fn chunks_in_range
pub fn reversed_chunks_in_range
pub fn offset_to_offset_utf16
pub fn offset_utf16_to_offset
pub fn offset_to_point
pub fn offset_to_point_utf16
pub fn point_to_point_utf16
pub fn point_to_offset
pub fn point_utf16_to_offset
pub fn unclipped_point_utf16_to_offset
fn point_utf16_to_offset_impl
pub fn unclipped_point_utf16_to_point
pub fn clip_offset
pub fn clip_offset_utf16
pub fn clip_point
pub fn clip_point_utf16
pub fn line_len
```

</outline>
<rejected>
```crates/rope/src/rope.rs
            *cursor.start() + chunk.as_slice().clip_offset_utf16(overshoot, bias)
        } else {
<|editable_region_start|>
            self.summary().len_utf16
        }
    }

    pub fn ptr_eq(&self, other: &Rope) -> bool {
        self as *const Rope == other as *const Rope
    }
<|editable_region_end|>
            self.summary().lines
        }
    }

    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {
        let mut cursor = self.chunks.cursor::<PointUtf16>(&());
        cursor.seek(&point.0, Bias::Right, &());
        if let Some(chunk) = cursor.item() {
            let overshoot = Unclipped(point.0 - cursor.start());
            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)
        } else {
            self.summary().lines_utf16()
        }
    }

    pub fn line_len(&self, row: u32) -> u32 {
        self.clip_point(Point::new(row, u32::MAX), Bias::Left)
            .column
    }
    
    pub fn ptr_eq(&self, other: &Rope) -> bool {
        self as *const Rope == other as *const Rope
    }
}

impl<'a> From<&'a str> for Rope {
    fn from(text: &'a str) -> Self {
        let mut rope = Self::new();
        rope.push(text);
        rope
    }
}

impl<'a> FromIterator<&'a str> for Rope {
    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {
        let mut rope = Rope::new();
        for chunk in iter {
            rope.push(chunk);
        }
        rope
    }
}

impl From<String> for Rope {
    fn from(text: String) -> Self {
        Rope::from(text.as_str())
    }
}

impl fmt::Display for Rope {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for chunk in self.chunks() {
            write!(f, "{}", chunk)?;
        }
        Ok(())
    }
```
</rejected>

<labels>
non-local-edit,complete-implementation
</labels>
