<events>
User edited "crates/editor/src/editor_tests.rs":
```diff
@@ -12513,6 +12513,9 @@
     }
 }
 
+#[gpuy]
+async fn 
+
 #[gpui::test]
 async fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {
     init_test(cx, |_| {});

```
</events>
<input>
```zed/crates/editor/src/editor_tests.rs
    // Now, when all ranges selected belong to buffer_1, the revert should succeed,
    // but not affect buffer_2 and its related excerpts.
    editor.update(cx, |editor, cx| {
        assert_eq!(
            editor.text(cx),
            "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj\n\n\nXlll\nXmmm\nXnnn\n\nXqqq\nXrrr\n\nXuuu\nXvvv\nXwww\nXxxx\n\nX{{{\nX|||\n\nX\u{7f}\u{7f}\u{7f}"
        );
    });
    buffer_1.update(cx, |buffer, _| {
        assert_eq!(buffer.text(), base_text_1);
    });
    buffer_2.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
<|editable_region_start|>
            "Xlll\nXmmm\nXnnn\nXooo\nXppp\nXqqq\nXrrr\nXsss\nXttt\nXuuu"
        );
    });
    buffer_3.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
            "Xvvv\nXwww\nXxxx\nXyyy\nXzzz\nX{{{\nX|||\nX}}}\nX~~~\nX\u{7f}\u{7f}\u{7f}"
        );
    });

    fn edit_first_char_of_every_line(text: &str) -> String {
        text.split('\n')
            .map(|line| format!("X{}", &line[1..]))
            .collect::<Vec<_>>()
            .join("\n")
    }
}

#[gpuy<|user_cursor_is_here|>]
async fn 

#[gpui::test]
async fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {
    init_test(cx, |_| {});

    let cols = 4;
    let rows = 10;
    let sample_text_1 = sample_text(rows, cols, 'a');
    assert_eq!(
<|editable_region_end|>
        sample_text_1,
        "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj"
    );
    let sample_text_2 = sample_text(rows, cols, 'l');
    assert_eq!(
        sample_text_2,
        "llll\nmmmm\nnnnn\noooo\npppp\nqqqq\nrrrr\nssss\ntttt\nuuuu"
    );
    let sample_text_3 = sample_text(rows, cols, 'v');
    assert_eq!(
        sample_text_3,
        "vvvv\nwwww\nxxxx\nyyyy\nzzzz\n{{{{\n||||\n}}}}\n~~~~\n\u{7f}\u{7f}\u{7f}\u{7f}"
    );

    let buffer_1 = cx.new(|cx| Buffer::local(sample_text_1.clone(), cx));
    let buffer_2 = cx.new(|cx| Buffer::local(sample_text_2.clone(), cx));
    let buffer_3 = cx.new(|cx| Buffer::local(sample_text_3.clone(), cx));

    let multi_buffer = cx.new(|cx| {
        let mut multibuffer = MultiBuffer::new(ReadWrite);
        multibuffer.push_excerpts(
            buffer_1.clone(),
            [
```
</input>
<output>
```zed/crates/editor/src/editor_tests.rs
    // Now, when all ranges selected belong to buffer_1, the revert should succeed,
    // but not affect buffer_2 and its related excerpts.
    editor.update(cx, |editor, cx| {
        assert_eq!(
            editor.text(cx),
            "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj\n\n\nXlll\nXmmm\nXnnn\n\nXqqq\nXrrr\n\nXuuu\nXvvv\nXwww\nXxxx\n\nX{{{\nX|||\n\nX\u{7f}\u{7f}\u{7f}"
        );
    });
    buffer_1.update(cx, |buffer, _| {
        assert_eq!(buffer.text(), base_text_1);
    });
    buffer_2.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
<|editable_region_start|>
            "Xlll\nXmmm\nXnnn\nXooo\nXppp\nXqqq\nXrrr\nXsss\nXttt\nXuuu"
        );
    });
    buffer_3.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
            "Xvvv\nXwww\nXxxx\nXyyy\nXzzz\nX{{{\nX|||\nX}}}\nX~~~\nX\u{7f}\u{7f}\u{7f}"
        );
    });

    fn edit_first_char_of_every_line(text: &str) -> String {
        text.split('\n')
            .map(|line| format!("X{}", &line[1..]))
            .collect::<Vec<_>>()
            .join("\n")
    }
}

#[gpui::test]
async fn test_multibuffer_revert_changes(cx: &mut gpui::TestAppContext) {
    init_test(cx, |_| {});
}

#[gpui::test]
async fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {
    init_test(cx, |_| {});

    let cols = 4;
    let rows = 10;
    let sample_text_1 = sample_text(rows, cols, 'a');
    assert_eq!(
<|editable_region_end|>
        sample_text_1,
        "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj"
    );
    let sample_text_2 = sample_text(rows, cols, 'l');
    assert_eq!(
        sample_text_2,
        "llll\nmmmm\nnnnn\noooo\npppp\nqqqq\nrrrr\nssss\ntttt\nuuuu"
    );
    let sample_text_3 = sample_text(rows, cols, 'v');
    assert_eq!(
        sample_text_3,
        "vvvv\nwwww\nxxxx\nyyyy\nzzzz\n{{{{\n||||\n}}}}\n~~~~\n\u{7f}\u{7f}\u{7f}\u{7f}"
    );

    let buffer_1 = cx.new(|cx| Buffer::local(sample_text_1.clone(), cx));
    let buffer_2 = cx.new(|cx| Buffer::local(sample_text_2.clone(), cx));
    let buffer_3 = cx.new(|cx| Buffer::local(sample_text_3.clone(), cx));

    let multi_buffer = cx.new(|cx| {
        let mut multibuffer = MultiBuffer::new(ReadWrite);
        multibuffer.push_excerpts(
            buffer_1.clone(),
            [
```
</output>
<outline>
```crates/editor/src/editor_tests.rs
fn test_edit_events
fn test_undo_redo_with_selection_restoration
fn test_ime_composition
fn test_selection_with_mouse
fn test_multiple_cursor_removal
fn test_canceling_pending_selection
fn test_movement_actions_with_pending_selection
fn test_clone
async fn test_navigation_history
 fn pop_history
fn test_cancel
fn test_fold_action
fn test_fold_action_whitespace_sensitive_language
fn test_fold_action_multiple_line_breaks
fn test_fold_at_level
fn test_move_cursor
fn test_move_cursor_multibyte
fn test_move_cursor_different_line_lengths
fn test_beginning_end_of_line
fn test_beginning_end_of_line_ignore_soft_wrap
fn test_prev_next_word_boundary
fn test_prev_next_word_bounds_with_soft_wrap
async fn test_move_start_of_paragraph_end_of_paragraph
async fn test_scroll_page_up_page_down
async fn test_autoscroll
async fn test_move_page_up_page_down
async fn test_delete_to_beginning_of_line
fn test_delete_to_word_boundary
fn test_delete_to_previous_word_start_or_newline
fn test_delete_to_next_word_end_or_newline
fn test_newline
fn test_newline_with_old_selections
async fn test_newline_above
async fn test_newline_below
async fn test_newline_comments
fn test_insert_with_old_selections
async fn test_tab
async fn test_tab_in_leading_whitespace_auto_indents_lines
async fn test_tab_with_mixed_whitespace
async fn test_indent_outdent
async fn test_indent_outdent_with_hard_tabs
fn test_indent_outdent_with_excerpts
async fn test_backspace
async fn test_delete
fn test_delete_line
fn test_join_lines_with_single_selection
fn test_join_lines_with_multi_selection
async fn test_join_lines_with_git_diff_base
async fn test_custom_newlines_cause_no_false_positive_diffs
async fn test_manipulate_lines_with_single_selection
async fn test_unique_lines_multi_selection
async fn test_unique_lines_single_selection
async fn test_manipulate_lines_with_multi_selection
async fn test_manipulate_text
fn test_duplicate_line
fn test_move_line_up_down
fn test_move_line_up_down_with_blocks
async fn test_selections_and_replace_blocks
fn test_transpose
async fn test_rewrap
 fn assert_rewrap
async fn test_clipboard
async fn test_paste_multiline
fn test_select_all
fn test_select_line
fn test_split_selection_into_lines
async fn test_add_selection_above_below
async fn test_select_next
async fn test_select_all_matches
async fn test_select_next_with_multiple_carets
async fn test_select_previous_multibuffer
async fn test_select_previous_with_single_caret
async fn test_select_previous_with_multiple_carets
async fn test_select_previous_with_single_selection
async fn test_select_larger_smaller_syntax_node
async fn test_fold_function_bodies
async fn test_autoindent
async fn test_autoindent_selections
async fn test_autoclose_and_auto_surround_pairs
async fn test_always_treat_brackets_as_autoclosed_skip_over
async fn test_autoclose_with_embedded_language
async fn test_autoclose_with_overrides
async fn test_surround_with_pair
async fn test_delete_autoclose_pair
async fn test_always_treat_brackets_as_autoclosed_delete
async fn test_auto_replace_emoji_shortcode
async fn test_snippet_placeholder_choices
 fn assert
async fn test_snippets
 fn assert
async fn test_document_format_during_save
async fn test_multibuffer_format_during_save
async fn test_range_format_during_save
async fn test_document_format_manual_trigger
async fn test_concurrent_format_requests
async fn test_strip_whitespace_and_format_via_lsp
async fn test_handle_input_for_show_signature_help_auto_signature_help_true
async fn test_handle_input_with_different_show_signature_settings
async fn test_signature_help
async fn test_completion
async fn test_multiline_completion
async fn test_completion_page_up_down_keys
async fn test_completion_sort
async fn test_no_duplicated_completion_requests
async fn test_toggle_comment
async fn test_toggle_comment_ignore_indent
async fn test_advance_downward_on_toggle_comment
async fn test_toggle_block_comment
fn test_editing_disjoint_excerpts
fn test_editing_overlapping_excerpts
fn test_refresh_selections
fn test_refresh_selections_while_selecting_with_mouse
async fn test_extra_newline_insertion
fn test_highlighted_ranges
 struct Type1
 struct Type2
async fn test_following
async fn test_following_with_multiple_excerpts
async fn go_to_prev_overlapping_diagnostic
async fn test_diagnostics_with_links
async fn test_go_to_hunk
fn test_split_words
 fn split
async fn test_move_to_enclosing_bracket
async fn test_on_type_formatting_not_triggered
 fn main
async fn test_language_server_restart_due_to_settings_change
 fn main
async fn test_completions_with_additional_edits
async fn test_completions_resolve_updates_labels_if_filter_text_matches
async fn test_completions_resolve_happens_once
async fn test_completions_default_resolve_data_handling
async fn test_completions_in_languages_with_extra_word_characters
fn completion_menu_entries
async fn test_document_format_with_prettier
async fn test_addition_reverts
async fn test_modification_reverts
async fn test_deleting_over_diff_hunk
async fn test_deletion_reverts
async fn test_multibuffer_reverts
 fn edit_first_char_of_every_line
async fn test_mutlibuffer_in_navigation_history
async fn test_toggle_selected_diff_hunks
async fn test_diff_base_change_with_expanded_diff_hunks
async fn test_toggle_diff_expand_in_multi_buffer
async fn test_expand_diff_hunk_at_excerpt_boundary
async fn test_edits_around_expanded_insertion_hunks
async fn test_toggling_adjacent_diff_hunks
async fn test_edits_around_expanded_deletion_hunks
async fn test_backspace_after_deletion_hunk
async fn test_edit_after_expanded_modification_hunk
async fn setup_indent_guides_editor
fn assert_indent_guides
fn indent_guide
async fn test_indent_guide_single_line
async fn test_indent_guide_simple_block
async fn test_indent_guide_nested
async fn test_indent_guide_tab
async fn test_indent_guide_continues_on_empty_line
async fn test_indent_guide_complex
async fn test_indent_guide_starts_off_screen
async fn test_indent_guide_ends_off_screen
async fn test_indent_guide_without_brackets
async fn test_indent_guide_ends_before_empty_line
async fn test_indent_guide_continuing_off_screen
async fn test_indent_guide_tabs
async fn test_active_indent_guide_single_line
async fn test_active_indent_guide_respect_indented_range
async fn test_active_indent_guide_empty_line
async fn test_active_indent_guide_non_matching_indent
async fn test_indent_guide_with_expanded_diff_hunks
fn test_crease_insertion_and_rendering
 struct RenderArgs
  row
  folded
  callback
async fn test_input_text
async fn test_scroll_cursor_center_top_bottom
async fn test_goto_definition_with_find_all_references_fallback
async fn test_find_enclosing_node_with_task
async fn test_multi_buffer_folding
async fn test_multi_buffer_single_excerpts_folding
async fn test_multi_buffer_with_single_excerpt_folding
 enum TestHighlight
async fn test_inline_completion_text
async fn test_inline_completion_text_with_deletions
async fn assert_highlighted_edits
async fn test_rename_with_duplicate_edits
async fn test_rename_without_prepare
fn empty_range
fn assert_selection_ranges
pub fn handle_signature_help_request
pub fn handle_completion_request
fn handle_resolve_completion_request
pub(crate) fn update_test_language_settings
pub(crate) fn update_test_project_settings
pub(crate) fn init_test
fn assert_hunk_revert
```

</outline>
<rejected>
```zed/crates/editor/src/editor_tests.rs
    // Now, when all ranges selected belong to buffer_1, the revert should succeed,
    // but not affect buffer_2 and its related excerpts.
    editor.update(cx, |editor, cx| {
        assert_eq!(
            editor.text(cx),
            "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj\n\n\nXlll\nXmmm\nXnnn\n\nXqqq\nXrrr\n\nXuuu\nXvvv\nXwww\nXxxx\n\nX{{{\nX|||\n\nX\u{7f}\u{7f}\u{7f}"
        );
    });
    buffer_1.update(cx, |buffer, _| {
        assert_eq!(buffer.text(), base_text_1);
    });
    buffer_2.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
<|editable_region_start|>
            "Xlll\nXmmm\nXnnn\nXooo\nXppp\nXqqq\nXrrr\nXsss\nXttt\nXuuu"
        );
    });
    buffer_3.update(cx, |buffer, _| {
        assert_eq!(
            buffer.text(),
            "Xvvv\nXwww\nXxxx\nXyyy\nXzzz\nX{{{\nX|||\nX}}}\nX~~~\nX\u{7f}\u{7f}\u{7f}"
        );
    });

    fn edit_first_char_of_every_line(text: &str) -> String {
        text.split('\n')
            .map(|line| format!("X{}", &line[1..]))
            .collect::<Vec<_>>()
            .join("\n")
    }
}

#[gpui::test]
async fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {
    init_test(cx, |_| {});

    let cols = 4;
    let rows = 10;
    let sample_text_1 = sample_text(rows, cols, 'a');
    assert_eq!(
<|editable_region_end|>
        sample_text_1,
        "aaaa\nbbbb\ncccc\ndddd\neeee\nffff\ngggg\nhhhh\niiii\njjjj"
    );
    let sample_text_2 = sample_text(rows, cols, 'l');
    assert_eq!(
        sample_text_2,
        "llll\nmmmm\nnnnn\noooo\npppp\nqqqq\nrrrr\nssss\ntttt\nuuuu"
    );
    let sample_text_3 = sample_text(rows, cols, 'v');
    assert_eq!(
        sample_text_3,
        "vvvv\nwwww\nxxxx\nyyyy\nzzzz\n{{{{\n||||\n}}}}\n~~~~\n\u{7f}\u{7f}\u{7f}\u{7f}"
    );

    let buffer_1 = cx.new(|cx| Buffer::local(sample_text_1.clone(), cx));
    let buffer_2 = cx.new(|cx| Buffer::local(sample_text_2.clone(), cx));
    let buffer_3 = cx.new(|cx| Buffer::local(sample_text_3.clone(), cx));

    let multi_buffer = cx.new(|cx| {
        let mut multibuffer = MultiBuffer::new(ReadWrite);
        multibuffer.push_excerpts(
            buffer_1.clone(),
            [
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
