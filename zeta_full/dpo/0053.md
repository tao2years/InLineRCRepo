<events>
```diff
@@ -194,6 +194,7 @@
             editor.set_show_inline_completions(Some(false), window, cx);
             editor.set_vertical_scroll_margin(5, cx);
             editor.set_use_modal_editing(false);
+            edit
             editor
         });
 

```
</events>
<input>
```crates/feedback/src/feedback_modal.rs
                .detach_and_log_err(cx);
        });
    }

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
                cx,
            );
<|editable_region_start|>
            editor.set_show_gutter(false, cx);
            editor.set_show_indent_guides(false, cx);
            editor.set_show_inline_completions(Some(false), window, cx);
            editor.set_vertical_scroll_margin(5, cx);
            editor.set_use_modal_editing(false);
            edit<|user_cursor_is_here|>
            editor
        });

        cx.subscribe(&feedback_editor, |this, editor, event: &EditorEvent, cx| {
            if matches!(event, EditorEvent::Edited { .. }) {
                this.character_count = editor
                    .read(cx)
                    .buffer()
                    .read(cx)
                    .as_singleton()
                    .expect("Feedback editor is never a multi-buffer")
                    .read(cx)
                    .len() as i32;
                cx.notify();
            }
        })
        .detach();

        Self {
            system_specs: system_specs.clone(),
            feedback_editor,
            email_address_editor,
            submission_state: None,
<|editable_region_end|>
            dismiss_modal: false,
            character_count: 0,
        }
    }

    pub fn submit(
        &mut self,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Task<anyhow::Result<()>> {
```
</input>
<output>
```crates/feedback/src/feedback_modal.rs
                .detach_and_log_err(cx);
        });
    }

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
                cx,
            );
<|editable_region_start|>
            editor.set_show_gutter(false, cx);
            editor.set_show_indent_guides(false, cx);
            editor.set_show_inline_completions(Some(false), window, cx);
            editor.set_vertical_scroll_margin(5, cx);
            editor.set_use_modal_editing(false);
            editor.set_auto_height(true, cx);
            editor
        });

        cx.subscribe(&feedback_editor, |this, editor, event: &EditorEvent, cx| {
            if matches!(event, EditorEvent::Edited { .. }) {
                this.character_count = editor
                    .read(cx)
                    .buffer()
                    .read(cx)
                    .as_singleton()
                    .expect("Feedback editor is never a multi-buffer")
                    .read(cx)
                    .len() as i32;
                cx.notify();
            }
        })
        .detach();

        Self {
            system_specs: system_specs.clone(),
            feedback_editor,
            email_address_editor,
            submission_state: None,
<|editable_region_end|>
            dismiss_modal: false,
            character_count: 0,
        }
    }

    pub fn submit(
        &mut self,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Task<anyhow::Result<()>> {
```
</output>
<outline>
```crates/feedback/src/feedback_modal.rs
const SEND_SUCCESS_IN_DEV_MODE
const SEND_TIME_IN_DEV_MODE
const DEV_MODE
const DEV_MODE
const DATABASE_KEY_NAME
static EMAIL_REGEX
const FEEDBACK_CHAR_LIMIT
const FEEDBACK_SUBMISSION_ERROR_TEXT
struct FeedbackRequestBody
 feedback_text
 email
 installation_id
 metrics_id
 system_specs
 is_staff
struct InvalidStateFlags
enum CannotSubmitReason
 InvalidState
  flags
 AwaitingSubmission
enum SubmissionState
 CanSubmit
 CannotSubmit
  reason
pub struct FeedbackModal
 system_specs
 feedback_editor
 email_address_editor
 submission_state
 dismiss_modal
 character_count
impl Focusable for FeedbackModal
 fn focus_handle
impl EventEmitter<DismissEvent> for FeedbackModal
impl ModalView for FeedbackModal
 fn on_before_dismiss
impl FeedbackModal
 pub fn register
 pub fn new
 pub fn submit
 async fn submit_feedback
 fn update_submission_state
 fn update_email_in_store
 fn valid_email_address
 fn valid_character_count
 fn in_invalid_state
 fn awaiting_submission
 fn can_submit
 fn cancel
impl Render for FeedbackModal
 fn render
```

</outline>
<rejected>
```crates/feedback/src/feedback_modal.rs
                .detach_and_log_err(cx);
        });
    }

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
                cx,
            );
<|editable_region_start|>
            editor.set_show_gutter(false, cx);
            editor.set_show_indent_guides(false, cx);
            editor.set_show_inline_completions(Some(false), window, cx);
            editor.set_vertical_scroll_margin(5, cx);
            editor.set_use_modal_editing(false);
            editor
        });

        cx.subscribe(&feedback_editor, |this, editor, event: &EditorEvent, cx| {
            if matches!(event, EditorEvent::Edited { .. }) {
                this.character_count = editor
                    .read(cx)
                    .buffer()
                    .read(cx)
                    .as_singleton()
                    .expect("Feedback editor is never a multi-buffer")
                    .read(cx)
                    .len() as i32;
                cx.notify();
            }
        })
        .detach();

        Self {
            system_specs: system_specs.clone(),
            feedback_editor,
            email_address_editor,
            submission_state: None,
<|editable_region_end|>
            dismiss_modal: false,
            character_count: 0,
        }
    }

    pub fn submit(
        &mut self,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Task<anyhow::Result<()>> {
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
