<events>

</events>
<input>
```zed/crates/vim/src/visual.rs
                            id: s.new_selection_id(),
                            start: start.to_offset(&map.buffer_snapshot),
                            end: new_end.to_offset(&map, Bias::Left),
                            reversed,
                            goal: SelectionGoal::None,
                        }
                    })
                    .collect();
                s.select(ranges);
            })
        });
        vim.switch_mode(stored_mode, true, window, cx)
    });
}

impl Vim {
    pub fn visual_motion(
        &mut self,
        motion: Motion,
        times: Option<usize>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) {
        self.update_editor(window, cx, |vim, editor, window, cx| {
            let text_layout_details = editor.text_layout_details(window);
            if vim.mode == Mode::VisualBlock
                && !matches!(
                    motion,
                    Motion::EndOfLine {
                        display_lines: false
<|editable_region_start|>
                    }
                )
            {
                let is_up_or_down = matches!(motion, Motion::Up { .. } | Motion::Down<|user_cursor_is_here|> { .. });
                vim.visual_block_motion(is_up_or_down, editor, window, cx, |map, point, goal| {
                    motion.move_point(map, point, goal, times, &text_layout_details)
                })
            } else {
                editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {
                    s.move_with(|map, selection| {
                        let was_reversed = selection.reversed;
                        let mut current_head = selection.head();
<|editable_region_end|>

                        // our motions assume the current character is after the cursor,
                        // but in (forward) visual mode the current character is just
                        // before the end of the selection.

                        // If the file ends with a newline (which is common) we don't do this.
                        // so that if you go to the end of such a file you can use "up" to go
                        // to the previous line and have it work somewhat as expected.
                        #[allow(clippy::nonminimal_bool)]
                        if !selection.reversed
                            && !selection.is_empty()
                            && !(selection.end.column() == 0 && selection.end == map.max_point())
                        {
                            current_head = movement::left(map, selection.end)
                        }

                        let Some((new_head, goal)) = motion.move_point(
                            map,
                            current_head,
                            selection.goal,
                            times,
                            &text_layout_details,
                        ) else {
                            return;
                        };
```
</input>
<output>
```zed/crates/vim/src/visual.rs
                            id: s.new_selection_id(),
                            start: start.to_offset(&map.buffer_snapshot),
                            end: new_end.to_offset(&map, Bias::Left),
                            reversed,
                            goal: SelectionGoal::None,
                        }
                    })
                    .collect();
                s.select(ranges);
            })
        });
        vim.switch_mode(stored_mode, true, window, cx)
    });
}

impl Vim {
    pub fn visual_motion(
        &mut self,
        motion: Motion,
        times: Option<usize>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) {
        self.update_editor(window, cx, |vim, editor, window, cx| {
            let text_layout_details = editor.text_layout_details(window);
            if vim.mode == Mode::VisualBlock
                && !matches!(
                    motion,
                    Motion::EndOfLine {
                        display_lines: false
<|editable_region_start|>
                    }
                )
            {
                let is_up_or_down = matches!(motion, Motion::Up { .. } | Motion::Down { .. });
                vim.visual_block_motion(is_up_or_down, editor, window, cx, |map, point, goal| {
                    motion.move_point(map, point, goal, times, &text_layout_details)
                })
            } else {
                editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {
                    s.move_with(|map, selection| {
                        let was_reversed = selection.reversed;
                        let mut current_head = selection.head();
<|editable_region_end|>

                        // our motions assume the current character is after the cursor,
                        // but in (forward) visual mode the current character is just
                        // before the end of the selection.

                        // If the file ends with a newline (which is common) we don't do this.
                        // so that if you go to the end of such a file you can use "up" to go
                        // to the previous line and have it work somewhat as expected.
                        #[allow(clippy::nonminimal_bool)]
                        if !selection.reversed
                            && !selection.is_empty()
                            && !(selection.end.column() == 0 && selection.end == map.max_point())
                        {
                            current_head = movement::left(map, selection.end)
                        }

                        let Some((new_head, goal)) = motion.move_point(
                            map,
                            current_head,
                            selection.goal,
                            times,
                            &text_layout_details,
                        ) else {
                            return;
                        };
```
</output>
<outline>
```crates/vim/src/visual.rs
pub fn register
impl Vim
 pub fn visual_motion
 pub fn visual_block_motion
 pub fn visual_object
 fn visual_insert_end_of_line
 fn visual_insert_first_non_white_space
 fn toggle_mode
 pub fn other_end
 pub fn visual_delete
 pub fn visual_yank
 pub(crate) fn visual_replace
 pub fn select_next
 pub fn select_previous
 pub fn select_match
mod test
 async fn test_enter_visual_mode
 async fn test_visual_insert_first_non_whitespace
 async fn test_visual_insert_end_of_line
 async fn test_enter_visual_line_mode
 async fn test_visual_delete
 async fn test_visual_line_delete
 async fn test_visual_yank
 async fn test_visual_block_mode
 async fn test_visual_block_issue_2123
 async fn test_visual_block_insert
 async fn test_visual_object
 async fn test_mode_across_command
 async fn test_gn
 async fn test_gl
 async fn test_dgn_repeat
 async fn test_cgn_repeat
 async fn test_cgn_nomatch
 async fn test_visual_shift_d
 async fn test_shift_y
 async fn test_gv
```

</outline>
<rejected>
```zed/crates/vim/src/visual.rs
                            id: s.new_selection_id(),
                            start: start.to_offset(&map.buffer_snapshot),
                            end: new_end.to_offset(&map, Bias::Left),
                            reversed,
                            goal: SelectionGoal::None,
                        }
                    })
                    .collect();
                s.select(ranges);
            })
        });
        vim.switch_mode(stored_mode, true, window, cx)
    });
}

impl Vim {
    pub fn visual_motion(
        &mut self,
        motion: Motion,
        times: Option<usize>,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) {
        self.update_editor(window, cx, |vim, editor, window, cx| {
            let text_layout_details = editor.text_layout_details(window);
            if vim.mode == Mode::VisualBlock
                && !matches!(
                    motion,
                    Motion::EndOfLine {
                        display_lines: false
<|editable_region_start|>
                    }
                )
            } else {
                editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {
                    s.move_with(|map, selection| {
                        let was_reversed = selection.reversed;
                        let mut current_head = selection.head();
<|editable_region_end|>

                        // our motions assume the current character is after the cursor,
                        // but in (forward) visual mode the current character is just
                        // before the end of the selection.

                        // If the file ends with a newline (which is common) we don't do this.
                        // so that if you go to the end of such a file you can use "up" to go
                        // to the previous line and have it work somewhat as expected.
                        #[allow(clippy::nonminimal_bool)]
                        if !selection.reversed
                            && !selection.is_empty()
                            && !(selection.end.column() == 0 && selection.end == map.max_point())
                        {
                            current_head = movement::left(map, selection.end)
                        }

                        let Some((new_head, goal)) = motion.move_point(
                            map,
                            current_head,
                            selection.goal,
                            times,
                            &text_layout_details,
                        ) else {
                            return;
                        };
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
