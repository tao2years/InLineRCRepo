<events>
User edited "crates/editor/src/editor.rs":
```diff
@@ -7977,7 +7977,7 @@
                 if !selection.is_empty() && !line_mode {
                     selection.goal = SelectionGoal::None;
                 }
-                let (cursor, gzoal) = movement::down_by_rows(
+                let (cursor, gzzxoal) = movement::down_by_rows(
                     map,
                     selection.start,
                     action.lines,

```

User edited "crates/editor/src/editor.rs":
```diff
@@ -7977,7 +7977,7 @@
                 if !selection.is_empty() && !line_mode {
                     selection.goal = SelectionGoal::None;
                 }
-                let (cursor, gzzxoal) = movement::down_by_rows(
+                let (cursor, goal) = movement::down_by_rows(
                     map,
                     selection.start,
                     action.lines,

```

User edited "crates/editor/src/movement.rs":
```diff
@@ -102,6 +102,7 @@
     preserve_column_at_end: bool,
     text_layout_details: &TextLayoutDetails,
 ) -> (DisplayPoint, SelectionGoal) {
+    dbg!(start);
     down_by_rows(
         map,
         start,

```
</events>
<input>
```zed/crates/editor/src/movement.rs
/// if that point is already at the end of line.
pub fn saturating_right(map: &DisplaySnapshot, mut point: DisplayPoint) -> DisplayPoint {
    *point.column_mut() += 1;
    map.clip_point(point, Bias::Right)
}

/// Returns a display point for the preceding displayed line (which might be a soft-wrapped line).
pub fn up(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    up_by_rows(
        map,
        start,
        1,
<|editable_region_start|>
        goal,
        preserve_column_at_start,
        text_layout_details,
    )
}

/// Returns a display point for the next displayed line (which might be a soft-wrapped line).
pub fn down(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_end: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    dbg!(start);
    down_by_rows<|user_cursor_is_here|>(
        map,
        start,
        1,
        goal,
        preserve_column_at_end,
        text_layout_details,
    )
}

pub(crate) fn up_by_rows(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    row_count: u32,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    let goal_x = match goal {
        SelectionGoal::HorizontalPosition(x) => x.into(),
<|editable_region_end|>
        SelectionGoal::WrappedHorizontalPosition((_, x)) => x.into(),
        SelectionGoal::HorizontalRange { end, .. } => end.into(),
        _ => map.x_for_display_point(start, text_layout_details),
    };

    let prev_row = DisplayRow(start.row().0.saturating_sub(row_count));
    let mut point = map.clip_point(
        DisplayPoint::new(prev_row, map.line_len(prev_row)),
        Bias::Left,
    );
    if point.row() < start.row() {
        *point.column_mut() = map.display_column_for_x(point.row(), goal_x, text_layout_details)
    } else if preserve_column_at_start {
        return (start, goal);
```
</input>
<output>
```zed/crates/editor/src/movement.rs
/// if that point is already at the end of line.
pub fn saturating_right(map: &DisplaySnapshot, mut point: DisplayPoint) -> DisplayPoint {
    *point.column_mut() += 1;
    map.clip_point(point, Bias::Right)
}

/// Returns a display point for the preceding displayed line (which might be a soft-wrapped line).
pub fn up(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    up_by_rows(
        map,
        start,
        1,
<|editable_region_start|>
        goal,
        preserve_column_at_start,
        text_layout_details,
    )
}

/// Returns a display point for the next displayed line (which might be a soft-wrapped line).
pub fn down(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_end: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    dbg!(start);
    down_by_rows(
        map,
        start,
        1,
        goal,
        preserve_column_at_end,
        text_layout_details,
    )
}

pub(crate) fn up_by_rows(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    row_count: u32,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    let goal_x = match goal {
        SelectionGoal::HorizontalPosition(x) => x.into(),
<|editable_region_end|>
        SelectionGoal::WrappedHorizontalPosition((_, x)) => x.into(),
        SelectionGoal::HorizontalRange { end, .. } => end.into(),
        _ => map.x_for_display_point(start, text_layout_details),
    };

    let prev_row = DisplayRow(start.row().0.saturating_sub(row_count));
    let mut point = map.clip_point(
        DisplayPoint::new(prev_row, map.line_len(prev_row)),
        Bias::Left,
    );
    if point.row() < start.row() {
        *point.column_mut() = map.display_column_for_x(point.row(), goal_x, text_layout_details)
    } else if preserve_column_at_start {
        return (start, goal);
```
</output>
<outline>
```crates/editor/src/movement.rs
pub enum FindRange
 SingleLine
 MultiLine
pub struct TextLayoutDetails
 pub(crate) text_system
 pub(crate) editor_style
 pub(crate) rem_size
 pub scroll_anchor
 pub visible_rows
 pub vertical_scroll_margin
pub fn left
pub fn saturating_left
pub fn right
pub fn saturating_right
pub fn up
pub fn down
pub(crate) fn up_by_rows
pub(crate) fn down_by_rows
pub fn line_beginning
pub fn indented_line_beginning
pub fn line_end
pub fn previous_word_start
pub fn previous_word_start_or_newline
pub fn previous_subword_start
pub fn next_word_end
pub fn next_word_end_or_newline
pub fn next_subword_end
pub fn start_of_paragraph
pub fn end_of_paragraph
pub fn find_preceding_boundary_point
pub fn find_preceding_boundary_display_point
pub fn find_boundary_point
pub fn find_preceding_boundary_trail
pub fn find_boundary_trail
pub fn find_boundary
pub fn find_boundary_exclusive
pub fn chars_after
pub fn chars_before
pub(crate) fn is_inside_word
pub(crate) fn surrounding_word
pub fn split_display_range_by_lines
mod tests
 fn test_previous_word_start
  fn assert
 fn test_previous_subword_start
  fn assert
 fn test_find_preceding_boundary
  fn assert
 fn test_find_preceding_boundary_with_inlays
 fn test_next_word_end
  fn assert
 fn test_next_subword_end
  fn assert
 fn test_find_boundary
  fn assert
 fn test_surrounding_word
  fn assert
 async fn test_move_up_and_down_with_excerpts
 fn init_test
```

</outline>
<rejected>
```zed/crates/editor/src/movement.rs
/// if that point is already at the end of line.
pub fn saturating_right(map: &DisplaySnapshot, mut point: DisplayPoint) -> DisplayPoint {
    *point.column_mut() += 1;
    map.clip_point(point, Bias::Right)
}

/// Returns a display point for the preceding displayed line (which might be a soft-wrapped line).
pub fn up(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    up_by_rows(
        map,
        start,
        1,
<|editable_region_start|>
        goal,
        preserve_column_at_start,
        text_layout_details,
    )
}

/// Returns a display point for the next displayed line (which might be a soft-wrapped line).
pub fn down(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    goal: SelectionGoal,
    preserve_column_at_end: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    down_by_rows(
        map,
        start,
        1,
        goal,
        preserve_column_at_end,
        text_layout_details,
    )
}

pub(crate) fn up_by_rows(
    map: &DisplaySnapshot,
    start: DisplayPoint,
    row_count: u32,
    goal: SelectionGoal,
    preserve_column_at_start: bool,
    text_layout_details: &TextLayoutDetails,
) -> (DisplayPoint, SelectionGoal) {
    let goal_x = match goal {
        SelectionGoal::HorizontalPosition(x) => x.into(),
<|editable_region_end|>
        SelectionGoal::WrappedHorizontalPosition((_, x)) => x.into(),
        SelectionGoal::HorizontalRange { end, .. } => end.into(),
        _ => map.x_for_display_point(start, text_layout_details),
    };

    let prev_row = DisplayRow(start.row().0.saturating_sub(row_count));
    let mut point = map.clip_point(
        DisplayPoint::new(prev_row, map.line_len(prev_row)),
        Bias::Left,
    );
    if point.row() < start.row() {
        *point.column_mut() = map.display_column_for_x(point.row(), goal_x, text_layout_details)
    } else if preserve_column_at_start {
        return (start, goal);
```
</rejected>

<labels>
no-op,unknown
</labels>
