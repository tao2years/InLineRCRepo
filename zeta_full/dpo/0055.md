<events>
User edited "":
```diff
@@ -944,6 +944,7 @@
             } else {
                 $in.name | path split | last
             }
+
             {
                 name: $name
                 line_count: ($in.name | open | lines | length)

```

User edited "":
```diff
@@ -950,5 +950,4 @@
                 line_count: ($in.name | open | lines | length)
             }
         }
-        | sort-by line_count
 }

```

User edited "":
```diff
@@ -930,7 +930,7 @@
 # TODO - error recovery when encountering a binary file
 # TODO - parameter for
 
-def file-line-counts [...extension: string, --full-path]: nothing -> list<any> {
+def file-line-counts [...extension: string, ---path]: nothing -> list<any> {
     let pattern = if ($extension | is-empty) {
         "**/*"
     } else {

```

User edited "":
```diff
@@ -930,7 +930,7 @@
 # TODO - error recovery when encountering a binary file
 # TODO - parameter for
 
-def file-line-counts [...extension: string, ---path]: nothing -> list<any> {
+def file-line-counts [...extension: string, --name-path]: nothing -> list<any> {
     let pattern = if ($extension | is-empty) {
         "**/*"
     } else {

```

User edited "":
```diff
@@ -930,7 +930,7 @@
 # TODO - error recovery when encountering a binary file
 # TODO - parameter for
 
-def file-line-counts [...extension: string, --name-path]: nothing -> list<any> {
+def file-line-counts [...extension: string, --name-only]: nothing -> list<any> {
     let pattern = if ($extension | is-empty) {
         "**/*"
     } else {

```

User edited "":
```diff
@@ -930,7 +930,7 @@
 # TODO - error recovery when encountering a binary file
 # TODO - parameter for
 
-def file-line-counts [...extension: string, --name-only]: nothing -> list<any> {
+def file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {
     let pattern = if ($extension | is-empty) {
         "**/*"
     } else {

```

User edited "":
```diff
@@ -939,7 +939,7 @@
 
     ls ...(glob $pattern)
         | each {
-            let name = if $full_path {
+            let name = if $name_o {
                 $in.name
             } else {
                 $in.name | path split | last

```
</events>
<input>
```
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: alt
            keycode: char_f
            mode: emacs
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: delete_one_word_forward
            modifier: alt
            keycode: delete
            mode: emacs
            event: { edit: deleteword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: backspace
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: char_m
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: cut_word_to_right
            modifier: alt
            keycode: char_d
            mode: emacs
            event: { edit: cutwordright }
        }
        {
            name: upper_case_word
            modifier: alt
            keycode: char_u
            mode: emacs
            event: { edit: uppercaseword }
        }
        {
            name: lower_case_word
            modifier: alt
            keycode: char_l
            mode: emacs
            event: { edit: lowercaseword }
        }
        {
            name: capitalize_char
            modifier: alt
            keycode: char_c
            mode: emacs
<|editable_region_start|>
            event: { edit: capitalizechar }
        }
        # The following bindings with `*system` events require that Nushell has
        # been compiled with the `system-clipboard` feature.
        # If you want to use the system clipboard for visual selection or to
        # paste directly, uncomment the respective lines and replace the version
        # using the internal clipboard.
        {
            name: copy_selection
            modifier: control_shift
            keycode: char_c
            mode: emacs
            event: { edit: copyselection }
            # event: { edit: copyselectionsystem }
        }
        {
            name: cut_selection
            modifier: control_shift
            keycode: char_x
            mode: emacs
            event: { edit: cutselection }
            # event: { edit: cutselectionsystem }
        }
        # {
        #     name: paste_system
        #     modifier: control_shift
        #     keycode: char_v
        #     mode: emacs
        #     event: { edit: pastesystem }
        # }
        {
            name: select_all
            modifier: control_shift
            keycode: char_a
            mode: emacs
            event: { edit: selectall }
        }
    ]
}

# Custom config

$env.config.buffer_editor = "zed"

def "restart" []: nothing -> nothing {
    exec $nu.current-exe
}

# git

def git-tags []: nothing -> list<any> {
    git tag -n --sort=version:refname
        | from ssv -n
        | rename tag "commit description"
}

def zed-git-tags [--no-releases (-r), --no-collab (-c)]: nothing -> list<any> {
    mut tags = git-tags

    if $no_releases {
        $tags = $tags | filter {not ($in.tag | str starts-with "v0.")}
    }

    if $no_collab {
        $tags = $tags | filter {not ($in.tag | str starts-with "collab")}
    }

    $tags
}

# TODO - error recovery when encountering a binary file
# TODO - parameter for

def file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {
    let pattern = if ($extension | is-empty) {
        "**/*"
    } else {
        $"**/*.{($extension | str join ",")}"
    }

    ls ...(glob $pattern)
        | each {
            let name = if $name_o<|user_cursor_is_here|> {
                $in.name
            } else {
                $in.name | path split | last
            }

<|editable_region_end|>
            {
                name: $name
                line_count: ($in.name | open | lines | length)
            }
        }
}

```
</input>
<output>
```
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: alt
            keycode: char_f
            mode: emacs
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: delete_one_word_forward
            modifier: alt
            keycode: delete
            mode: emacs
            event: { edit: deleteword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: backspace
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: char_m
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: cut_word_to_right
            modifier: alt
            keycode: char_d
            mode: emacs
            event: { edit: cutwordright }
        }
        {
            name: upper_case_word
            modifier: alt
            keycode: char_u
            mode: emacs
            event: { edit: uppercaseword }
        }
        {
            name: lower_case_word
            modifier: alt
            keycode: char_l
            mode: emacs
            event: { edit: lowercaseword }
        }
        {
            name: capitalize_char
            modifier: alt
            keycode: char_c
            mode: emacs
<|editable_region_start|>
            event: { edit: capitalizechar }
        }
        # The following bindings with `*system` events require that Nushell has
        # been compiled with the `system-clipboard` feature.
        # If you want to use the system clipboard for visual selection or to
        # paste directly, uncomment the respective lines and replace the version
        # using the internal clipboard.
        {
            name: copy_selection
            modifier: control_shift
            keycode: char_c
            mode: emacs
            event: { edit: copyselection }
            # event: { edit: copyselectionsystem }
        }
        {
            name: cut_selection
            modifier: control_shift
            keycode: char_x
            mode: emacs
            event: { edit: cutselection }
            # event: { edit: cutselectionsystem }
        }
        # {
        #     name: paste_system
        #     modifier: control_shift
        #     keycode: char_v
        #     mode: emacs
        #     event: { edit: pastesystem }
        # }
        {
            name: select_all
            modifier: control_shift
            keycode: char_a
            mode: emacs
            event: { edit: selectall }
        }
    ]
}

# Custom config

$env.config.buffer_editor = "zed"

def "restart" []: nothing -> nothing {
    exec $nu.current-exe
}

# git

def git-tags []: nothing -> list<any> {
    git tag -n --sort=version:refname
        | from ssv -n
        | rename tag "commit description"
}

def zed-git-tags [--no-releases (-r), --no-collab (-c)]: nothing -> list<any> {
    mut tags = git-tags

    if $no_releases {
        $tags = $tags | filter {not ($in.tag | str starts-with "v0.")}
    }

    if $no_collab {
        $tags = $tags | filter {not ($in.tag | str starts-with "collab")}
    }

    $tags
}

# TODO - error recovery when encountering a binary file
# TODO - parameter for

def file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {
    let pattern = if ($extension | is-empty) {
        "**/*"
    } else {
        $"**/*.{($extension | str join ",")}"
    }

    ls ...(glob $pattern)
        | each {
            let name = if $name_only {
                $in.name
            } else {
                $in.name | path split | last
            }

<|editable_region_end|>
            {
                name: $name
                line_count: ($in.name | open | lines | length)
            }
        }
}

```
</output>
<outline>
```
```

</outline>
<rejected>
```
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: alt
            keycode: char_f
            mode: emacs
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: delete_one_word_forward
            modifier: alt
            keycode: delete
            mode: emacs
            event: { edit: deleteword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: backspace
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: char_m
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: cut_word_to_right
            modifier: alt
            keycode: char_d
            mode: emacs
            event: { edit: cutwordright }
        }
        {
            name: upper_case_word
            modifier: alt
            keycode: char_u
            mode: emacs
            event: { edit: uppercaseword }
        }
        {
            name: lower_case_word
            modifier: alt
            keycode: char_l
            mode: emacs
            event: { edit: lowercaseword }
        }
        {
            name: capitalize_char
            modifier: alt
            keycode: char_c
            mode: emacs
<|editable_region_start|>
            event: { edit: copyselection }
            # event: { edit: copyselectionsystem }
        }
        {
            name: cut_selection
            modifier: control_shift
            keycode: char_x
            mode: emacs
            event: { edit: cutselection }
            # event: { edit: cutselectionsystem }
        }
        # {
        #     name: paste_system
        #     modifier: control_shift
        #     keycode: char_v
        #     mode: emacs
        #     event: { edit: pastesystem }
        # }
        {
            name: select_all
            modifier: control_shift
            keycode: char_a
            mode: emacs
            event: { edit: selectall }
        }
    ]
}

# Custom config

$env.config.buffer_editor = "zed"

def "restart" []: nothing -> nothing {
    exec $nu.current-exe
}

# git

def git-tags []: nothing -> list<any> {
    git tag -n --sort=version:refname
        | from ssv -n
        | rename tag "commit description"
}

def zed-git-tags [--no-releases (-r), --no-collab (-c)]: nothing -> list<any> {
    mut tags = git-tags

    if $no_releases {
        $tags = $tags | filter {not ($in.tag | str starts-with "v0.")}
    }

    if $no_collab {
        $tags = $tags | filter {not ($in.tag | str starts-with "collab")}
    }

    $tags
}

# TODO - error recovery when encountering a binary file
# TODO - parameter for

def file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {
    let pattern = if ($extension | is-empty) {
        "**/*"
    } else {
        $"**/*.{($extension | str join ",")}"
    }

    ls ...(glob $pattern)
        | each {
            let name = if $name_only {
                $in.name
            } else {
                $in.name | path split | last
            }

<|editable_region_end|>
            {
                name: $name
                line_count: ($in.name | open | lines | length)
            }
        }
}

```
</rejected>

<labels>
local-edit,infer-intent
</labels>
