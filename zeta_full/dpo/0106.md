<events>

</events>
<input>
```zed/crates/feedback/src/feedback_modal.rs
                })
                .log_err();
            }
        })
        .detach();

        DismissDecision::Pending
    }
}

impl FeedbackModal {
    pub fn register(workspace: &mut Workspace, _: &mut Window, cx: &mut Context<Workspace>) {
        let _handle = cx.entity().downgrade();
        workspace.register_action(move |workspace, _: &GiveFeedback, window, cx| {
            workspace
                .with_local_workspace(window, cx, |workspace, window, cx| {
                    let markdown = workspace
                        .app_state()
                        .languages
                        .language_for_name("Markdown");

                    let project = workspace.project().clone();

                    let system_specs = SystemSpecs::new(window, cx);
                    cx.spawn_in(window, |workspace, mut cx| async move {
                        let markdown = markdown.await.log_err();
                        let buffer = project.update(&mut cx, |project, cx| {
                            project.create_local_buffer("", markdown, cx)
                        })?;
                        let system_specs = system_specs.await;

<|editable_region_start|>
                        workspace.update_in(&mut cx, |workspace, window, cx| {
                            workspace.toggle_modal(window, cx, move |window, cx| {
                                FeedbackModal::new(system_specs, project, buffer, window<|user_cursor_is_here|>, cx)
                            });
                        })?;

                        anyhow::Ok(())
                    })
                    .detach_and_log_err(cx);
                })
                .detach_and_log_err(cx);
        });
    }

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
<|editable_region_end|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
```
</input>
<output>
```zed/crates/feedback/src/feedback_modal.rs
                })
                .log_err();
            }
        })
        .detach();

        DismissDecision::Pending
    }
}

impl FeedbackModal {
    pub fn register(workspace: &mut Workspace, _: &mut Window, cx: &mut Context<Workspace>) {
        let _handle = cx.entity().downgrade();
        workspace.register_action(move |workspace, _: &GiveFeedback, window, cx| {
            workspace
                .with_local_workspace(window, cx, |workspace, window, cx| {
                    let markdown = workspace
                        .app_state()
                        .languages
                        .language_for_name("Markdown");

                    let project = workspace.project().clone();

                    let system_specs = SystemSpecs::new(window, cx);
                    cx.spawn_in(window, |workspace, mut cx| async move {
                        let markdown = markdown.await.log_err();
                        let buffer = project.update(&mut cx, |project, cx| {
                            project.create_local_buffer("", markdown, cx)
                        })?;
                        let system_specs = system_specs.await;

<|editable_region_start|>
                        workspace.update_in(&mut cx, |workspace, window, cx| {
                            workspace.toggle_modal(window, cx, move |window, cx| {
                                FeedbackModal::new(system_specs, project, buffer, window, cx)
                            });
                        })?;

                        anyhow::Ok(())
                    })
                    .detach_and_log_err(cx);
                })
                .detach_and_log_err(cx);
        });
    }

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
<|editable_region_end|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
```
</output>
<outline>
```crates/feedback/src/feedback_modal.rs
const SEND_SUCCESS_IN_DEV_MODE
const SEND_TIME_IN_DEV_MODE
const DEV_MODE
const DEV_MODE
const DATABASE_KEY_NAME
static EMAIL_REGEX
const FEEDBACK_CHAR_LIMIT
const FEEDBACK_SUBMISSION_ERROR_TEXT
struct FeedbackRequestBody
 feedback_text
 email
 installation_id
 metrics_id
 system_specs
 is_staff
struct InvalidStateFlags
enum CannotSubmitReason
 InvalidState
  flags
 AwaitingSubmission
enum SubmissionState
 CanSubmit
 CannotSubmit
  reason
pub struct FeedbackModal
 system_specs
 feedback_editor
 email_address_editor
 submission_state
 dismiss_modal
 character_count
impl Focusable for FeedbackModal
 fn focus_handle
impl EventEmitter<DismissEvent> for FeedbackModal
impl ModalView for FeedbackModal
 fn on_before_dismiss
impl FeedbackModal
 pub fn register
 pub fn new
 pub fn submit
 async fn submit_feedback
 fn update_submission_state
 fn update_email_in_store
 fn valid_email_address
 fn valid_character_count
 fn in_invalid_state
 fn awaiting_submission
 fn can_submit
 fn cancel
impl Render for FeedbackModal
 fn render
```

</outline>
<rejected>
```zed/crates/feedback/src/feedback_modal.rs
                })
                .log_err();
            }
        })
        .detach();

        DismissDecision::Pending
    }
}

impl FeedbackModal {
    pub fn register(workspace: &mut Workspace, _: &mut Window, cx: &mut Context<Workspace>) {
        let _handle = cx.entity().downgrade();
        workspace.register_action(move |workspace, _: &GiveFeedback, window, cx| {
            workspace
                .with_local_workspace(window, cx, |workspace, window, cx| {
                    let markdown = workspace
                        .app_state()
                        .languages
                        .language_for_name("Markdown");

                    let project = workspace.project().clone();

                    let system_specs = SystemSpecs::new(window, cx);
                    cx.spawn_in(window, |workspace, mut cx| async move {
                        let markdown = markdown.await.log_err();
                        let buffer = project.update(&mut cx, |project, cx| {
                            project.create_local_buffer("", markdown, cx)
                        })?;
                        let system_specs = system_specs.await;

<|editable_region_start|>
                        workspace.update_in(&mut cx, |workspace, window, cx| {
                            workspace.toggle_modal(window, cx, move |window, cx| {
                                FeedbackModal::new(system_specs, project, buffer, window, cx)
                            });
                        })?;

                        anyhow::Ok(())
                    })
                    .detach_and_log_err(cx);
                })
                .detach_and_log_err(cx);
        });

    pub fn new(
        system_specs: SystemSpecs,
        project: Entity<Project>,
        buffer: Entity<Buffer>,
<|editable_region_end|>
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        let email_address_editor = cx.new(|cx| {
            let mut editor = Editor::single_line(window, cx);
            editor.set_placeholder_text("Email address (optional)", cx);

            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {
                editor.set_text(email_address, window, cx)
            }

            editor
        });

        let feedback_editor = cx.new(|cx| {
            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);
            editor.set_placeholder_text(
                "You can use markdown to organize your feedback with code and links.",
```
</rejected>

<labels>
local-edit,infer-intent
</labels>
