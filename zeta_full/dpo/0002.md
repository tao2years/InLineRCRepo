<events>
User edited "crates/editor/src/color_swatches.rs":
```diff
@@ -67,7 +67,7 @@
             .update(&mut cx, |editor, cx| {
                 let snapshot = editor.buffer.read(cx).snapshot(cx);
                 
-                for (i, )
+                for (i, color_swatches) = col
 
                 for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {
                     let old_inlay_ids = editor

```
</events>
<input>
```crates/editor/src/color_swatches.rs
    let mut buffers = editor
        .buffer
        .read(cx)
        .all_buffers()
        .iter()
        .map(|b| b.downgrade());

    editor.color_swatches_task = Some(cx.spawn(|editor, mut cx| async move {
        cx.background_executor().timer(UPDATE_DEBOUNCE).await;

<|editable_region_start|>
        let excerpts = editor
            .update(&mut cx, |editor, cx| editor.excerpts_for_color_swatches(cx))
            .ok()?;

        let color_swatch_tasks = project
            .update(&mut cx, |project, cx| {
                excerpts
                    .iter()
                    .map(|(_, buffer)| project.color_swatches(&buffer, cx))
                    .collect::<Vec<_>>()
            })
            .ok()?;

        let color_swatches = futures::future::join_all(color_swatch_tasks)
            .await
            .into_iter()
            .flatten()
            .collect::<Vec<_>>();

        editor
            .update(&mut cx, |editor, cx| {
                let snapshot = editor.buffer.read(cx).snapshot(cx);
                
                for (i, color_swatches) = col<|user_cursor_is_here|>

                for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {
                    let old_inlay_ids = editor
                        .color_swatches
                        .0
                        .get_mut(&excerpt_id)
                        .map(|old_swatches| std::mem::take(&mut old_swatches.inlays))
                        .unwrap_or_default();

                    let mut inlays = Vec::new();
                    for color_swatch in color_swatches[i].iter() {
                        if let Some(position) =
                            snapshot.anchor_in_excerpt(*excerpt_id, color_swatch.range.start)
                        {
                            inlays.push(Inlay::color_swatch(
                                post_inc(&mut editor.next_inlay_id),
                                position,
                                color_swatch.color.into(),
                            ));
                        }
                    }

<|editable_region_end|>
                    //TODO: Do not reinsert inlays that are already present
                    editor.color_swatches.0.insert(
                        *excerpt_id,
                        BufferColorSwatches {
                            swatches: color_swatches[i],
                            inlays: inlays.iter().map(|inlay| inlay.id).collect(),
                        },
                    );
                    editor.splice_inlays(old_inlay_ids, inlays, cx);
                }
                cx.notify();
```
</input>
<output>
```crates/editor/src/color_swatches.rs
    let mut buffers = editor
        .buffer
        .read(cx)
        .all_buffers()
        .iter()
        .map(|b| b.downgrade());

    editor.color_swatches_task = Some(cx.spawn(|editor, mut cx| async move {
        cx.background_executor().timer(UPDATE_DEBOUNCE).await;

<|editable_region_start|>
        let excerpts = editor
            .update(&mut cx, |editor, cx| editor.excerpts_for_color_swatches(cx))
            .ok()?;

        let color_swatch_tasks = project
            .update(&mut cx, |project, cx| {
                excerpts
                    .iter()
                    .map(|(_, buffer)| project.color_swatches(&buffer, cx))
                    .collect::<Vec<_>>()
            })
            .ok()?;

        let color_swatches = futures::future::join_all(color_swatch_tasks)
            .await
            .into_iter()
            .flatten()
            .collect::<Vec<_>>();

        editor
            .update(&mut cx, |editor, cx| {
                let snapshot = editor.buffer.read(cx).snapshot(cx);
                
                for (i, color_swatches) in color_swatches {
                    
                }

                for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {
                    let old_inlay_ids = editor
                        .color_swatches
                        .0
                        .get_mut(&excerpt_id)
                        .map(|old_swatches| std::mem::take(&mut old_swatches.inlays))
                        .unwrap_or_default();

                    let mut inlays = Vec::new();
                    for color_swatch in color_swatches[i].iter() {
                        if let Some(position) =
                            snapshot.anchor_in_excerpt(*excerpt_id, color_swatch.range.start)
                        {
                            inlays.push(Inlay::color_swatch(
                                post_inc(&mut editor.next_inlay_id),
                                position,
                                color_swatch.color.into(),
                            ));
                        }
                    }

<|editable_region_end|>
                    //TODO: Do not reinsert inlays that are already present
                    editor.color_swatches.0.insert(
                        *excerpt_id,
                        BufferColorSwatches {
                            swatches: color_swatches[i],
                            inlays: inlays.iter().map(|inlay| inlay.id).collect(),
                        },
                    );
                    editor.splice_inlays(old_inlay_ids, inlays, cx);
                }
                cx.notify();
```
</output>
<outline>
```crates/editor/src/color_swatches.rs
pub(crate) struct ColorSwatches
struct BufferColorSwatches
 swatches
 inlays
const UPDATE_DEBOUNCE
pub(crate) fn refresh_color_swatches
```

</outline>
<rejected>
```crates/editor/src/color_swatches.rs
    let mut buffers = editor
        .buffer
        .read(cx)
        .all_buffers()
        .iter()
        .map(|b| b.downgrade());

    editor.color_swatches_task = Some(cx.spawn(|editor, mut cx| async move {
        cx.background_executor().timer(UPDATE_DEBOUNCE).await;

<|editable_region_start|>
        let excerpts = editor
            .update(&mut cx, |editor, cx| editor.excerpts_for_color_swatches(cx))
            .ok()?;

        let color_swatch_tasks = project
            .update(&mut cx, |project, cx| {
                excerpts
                    .iter()
                    .map(|(_, buffer)| project.color_swatches(&buffer, cx))
                    .collect::<Vec<_>>()
            })
            .ok()?;

        let color_swatches = futures::future::join_all(color_swatch_tasks)
            .await
            .into_iter()
            .flatten()
            .collect::<Vec<_>>();

        editor
            .update(&mut cx, |editor, cx| {
                let snapshot = editor.buffer.read(cx).snapshot(cx);
                
                for (i, color_swatches) in color_swatches.iter().enumerate() {
                    for (j, color_swatch) in color_swatches.iter().enumerate() {
                        if let Some(position) =
                            snapshot.anchor_in_excerpt(*excerpt_id, color_swatch.range.start)
                        {
                            inlays.push(Inlay::color_swatch(
                                post_inc(&mut editor.next_inlay_id),
                                position,
                                color_swatch.color.into(),
                            ));
                        }
                    }
                }

<|editable_region_end|>
                    //TODO: Do not reinsert inlays that are already present
                    editor.color_swatches.0.insert(
                        *excerpt_id,
                        BufferColorSwatches {
                            swatches: color_swatches[i],
                            inlays: inlays.iter().map(|inlay| inlay.id).collect(),
                        },
                    );
                    editor.splice_inlays(old_inlay_ids, inlays, cx);
                }
                cx.notify();
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
