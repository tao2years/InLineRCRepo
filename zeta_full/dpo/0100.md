<events>

</events>
<input>
```zed/crates/sum_tree/src/sum_tree.rs
/// - The left anchor of the selection has [Bias::Right], attaching it to the character `B`
/// - The right anchor of the selection has [Bias::Left], attaching it to the character `C`
///
/// Given the buffer `{ˇ<...>`, where `<...>` is a folded region:
/// - The display offset of the cursor is 1, but the offset in the buffer is determined by the bias
/// - [Bias::Left] would attach the cursor to the character `{`, with a buffer offset of 1
/// - [Bias::Right] would attach the cursor to the first character of the folded region,
///   and the buffer offset would be the offset of the first character of the folded region
#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Hash, Default)]
pub enum Bias {
    /// Attach to the character on the left
    #[default]
    Left,
    /// Attach to the character on the right
    Right,
}

impl Bias {
    pub fn invert(self) -> Self {
        match self {
            Self::Left => Self::Right,
            Self::Right => Self::Left,
<|editable_region_start|>
        }
    }
}

/// A B+ tree in which each leaf node contains `Item`s of type `T` and a `Summary`s for each `Item`.
/// Each internal node contains a `Summary` of the items in its subtree.
///
/// The maximum number of items per node is `TREE_BASE * 2`.
///
/// Any [`Dimension`] supported by the [`Summary`] type can be used to seek to a specific location in the tree.
#[derive(Clone)]
pub struct SumTree<|user_cursor_is_here|><T: Item>(Arc<Node<T>>);

impl<T> fmt::Debug for SumTree<T>
where
    T: fmt::Debug + Item,
    T::Summary: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_tuple("SumTree").field(&self.0).finish()
    }
}

impl<T: Item> SumTree<T> {
<|editable_region_end|>
    pub fn new(cx: &<T::Summary as Summary>::Context) -> Self {
        SumTree(Arc::new(Node::Leaf {
            summary: <T::Summary as Summary>::zero(cx),
            items: ArrayVec::new(),
            item_summaries: ArrayVec::new(),
        }))
    }

    pub fn from_item(item: T, cx: &<T::Summary as Summary>::Context) -> Self {
        let mut tree = Self::new(cx);
        tree.push(item, cx);
        tree
    }

    pub fn from_iter<I: IntoIterator<Item = T>>(
        iter: I,
        cx: &<T::Summary as Summary>::Context,
    ) -> Self {
        let mut nodes = Vec::new();

        let mut iter = iter.into_iter().fuse().peekable();
```
</input>
<output>
```zed/crates/sum_tree/src/sum_tree.rs
/// - The left anchor of the selection has [Bias::Right], attaching it to the character `B`
/// - The right anchor of the selection has [Bias::Left], attaching it to the character `C`
///
/// Given the buffer `{ˇ<...>`, where `<...>` is a folded region:
/// - The display offset of the cursor is 1, but the offset in the buffer is determined by the bias
/// - [Bias::Left] would attach the cursor to the character `{`, with a buffer offset of 1
/// - [Bias::Right] would attach the cursor to the first character of the folded region,
///   and the buffer offset would be the offset of the first character of the folded region
#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Hash, Default)]
pub enum Bias {
    /// Attach to the character on the left
    #[default]
    Left,
    /// Attach to the character on the right
    Right,
}

impl Bias {
    pub fn invert(self) -> Self {
        match self {
            Self::Left => Self::Right,
            Self::Right => Self::Left,
<|editable_region_start|>
        }
    }
}

/// A B+ tree in which each leaf node contains `Item`s of type `T` and a `Summary`s for each `Item`.
/// Each internal node contains a `Summary` of the items in its subtree.
///
/// The maximum number of items per node is `TREE_BASE * 2`.
///
/// Any [`Dimension`] supported by the [`Summary`] type can be used to seek to a specific location in the tree.
#[derive(Clone)]
pub struct SumTree<T: Item>(Arc<Node<T>>);

impl<T> fmt::Debug for SumTree<T>
where
    T: fmt::Debug + Item,
    T::Summary: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_tuple("SumTree").field(&self.0).finish()
    }
}

impl<T: Item> SumTree<T> {
<|editable_region_end|>
    pub fn new(cx: &<T::Summary as Summary>::Context) -> Self {
        SumTree(Arc::new(Node::Leaf {
            summary: <T::Summary as Summary>::zero(cx),
            items: ArrayVec::new(),
            item_summaries: ArrayVec::new(),
        }))
    }

    pub fn from_item(item: T, cx: &<T::Summary as Summary>::Context) -> Self {
        let mut tree = Self::new(cx);
        tree.push(item, cx);
        tree
    }

    pub fn from_iter<I: IntoIterator<Item = T>>(
        iter: I,
        cx: &<T::Summary as Summary>::Context,
    ) -> Self {
        let mut nodes = Vec::new();

        let mut iter = iter.into_iter().fuse().peekable();
```
</output>
<outline>
```crates/sum_tree/src/sum_tree.rs
mod cursor
mod tree_map
pub const TREE_BASE
pub const TREE_BASE
pub trait Item
 type Summary
 fn summary
pub trait KeyedItem
 type Key
 fn key
pub trait Summary
 type Context
 fn zero
 fn add_summary
pub struct Unit
impl Summary for Unit
 type Context
 fn zero
 fn add_summary
pub trait Dimension
 fn zero
 fn add_summary
 fn from_summary
impl Dimension<'a, T> for T
 fn zero
 fn add_summary
pub trait SeekTarget
 fn cmp
impl SeekTarget<'a, S, D> for D
 fn cmp
impl Dimension<'a, T> for ()
 fn zero
 fn add_summary
impl Dimension<'a, T> for (D1, D2)
 fn zero
 fn add_summary
impl SeekTarget<'a, S, (D1, D2)> for D1
 fn cmp
impl SeekTarget<'a, S, ((D1, D2), D3)> for D1
 fn cmp
struct End
impl End<D>
 fn new
impl SeekTarget<'a, S, D> for End<D>
 fn cmp
impl fmt::Debug for End<D>
 fn fmt
pub enum Bias
 Left
 Right
impl Bias
 pub fn invert
pub struct SumTree
impl fmt::Debug for SumTree<T>
 fn fmt
impl SumTree<T>
 pub fn new
 pub fn from_item
 pub fn from_iter
 pub fn from_par_iter
 pub fn items
 pub fn iter
 pub fn cursor
 pub fn filter
 pub fn first
 pub fn last
 pub fn update_last
 fn update_last_recursive
 pub fn extent
 pub fn summary
 pub fn is_empty
 pub fn extend
 pub fn par_extend
 pub fn push
 pub fn append
 pub fn ptr_eq
 fn push_tree_recursive
 fn from_child_trees
 fn leftmost_leaf
 fn rightmost_leaf
 pub fn _debug_entries
impl PartialEq for SumTree<T>
 fn eq
impl Eq for SumTree<T>
impl SumTree<T>
 pub fn insert_or_replace
 pub fn remove
 pub fn edit
 pub fn get
 pub fn contains
 pub fn update
 pub fn retain
impl Default for SumTree<T>
 fn default
pub enum Node
 Internal
  height
  summary
  child_summaries
  child_trees
 Leaf
  summary
  items
  item_summaries
impl fmt::Debug for Node<T>
 fn fmt
impl Node<T>
 fn is_leaf
 fn height
 fn summary
 fn child_summaries
 fn child_trees
 fn items
 fn is_underflowing
pub enum Edit
 Insert
 Remove
impl Edit<T>
 fn key
fn sum
mod tests
 fn init_logger
 fn test_extend_and_push_tree
 fn test_random
 fn test_cursor
 fn test_edit
 fn test_from_iter
 pub struct IntegersSummary
  count
  sum
  contains_even
  max
 struct Count
 struct Sum
 impl Item for u8
  type Summary
  fn summary
 impl KeyedItem for u8
  type Key
  fn key
 impl Summary for IntegersSummary
  type Context
  fn zero
  fn add_summary
 impl Dimension<'a, IntegersSummary> for u8
  fn zero
  fn add_summary
 impl Dimension<'a, IntegersSummary> for Count
  fn zero
  fn add_summary
 impl SeekTarget<'a, IntegersSummary, IntegersSummary> for Count
  fn cmp
 impl Dimension<'a, IntegersSummary> for Sum
  fn zero
  fn add_summary
```

</outline>
<rejected>
```zed/crates/sum_tree/src/sum_tree.rs
/// - The left anchor of the selection has [Bias::Right], attaching it to the character `B`
/// - The right anchor of the selection has [Bias::Left], attaching it to the character `C`
///
/// Given the buffer `{ˇ<...>`, where `<...>` is a folded region:
/// - The display offset of the cursor is 1, but the offset in the buffer is determined by the bias
/// - [Bias::Left] would attach the cursor to the character `{`, with a buffer offset of 1
/// - [Bias::Right] would attach the cursor to the first character of the folded region,
///   and the buffer offset would be the offset of the first character of the folded region
#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Hash, Default)]
pub enum Bias {
    /// Attach to the character on the left
    #[default]
    Left,
    /// Attach to the character on the right
    Right,
}

impl Bias {
    pub fn invert(self) -> Self {
        match self {
            Self::Left => Self::Right,
            Self::Right => Self::Left,
<|editable_region_start|>
        }
    }

    /// A B+ tree in which each leaf node contains `Item`s of type `T` and a `Summary`s for each `Item`.
    /// Each internal node contains a `Summary` of the items in its subtree.
    ///
    /// The maximum number of items per node is `TREE_BASE * 2`.
    ///
    /// Any [`Dimension`] supported by the [`Summary`] type can be used to seek to a specific location in the tree.
    #[derive(Clone)]
    pub struct SumTree<T: Item>(Arc<Node<T>>);

    impl<T> fmt::Debug for SumTree<T>
    where
        T: fmt::Debug + Item,
        T::Summary: fmt::Debug,
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_tuple("SumTree").field(&self.0).finish()
        }
    }

    impl<T: Item> SumTree<T> {
<|editable_region_end|>
    pub fn new(cx: &<T::Summary as Summary>::Context) -> Self {
        SumTree(Arc::new(Node::Leaf {
            summary: <T::Summary as Summary>::zero(cx),
            items: ArrayVec::new(),
            item_summaries: ArrayVec::new(),
        }))
    }

    pub fn from_item(item: T, cx: &<T::Summary as Summary>::Context) -> Self {
        let mut tree = Self::new(cx);
        tree.push(item, cx);
        tree
    }

    pub fn from_iter<I: IntoIterator<Item = T>>(
        iter: I,
        cx: &<T::Summary as Summary>::Context,
    ) -> Self {
        let mut nodes = Vec::new();

        let mut iter = iter.into_iter().fuse().peekable();
```
</rejected>

<labels>
no-op,unknown
</labels>
