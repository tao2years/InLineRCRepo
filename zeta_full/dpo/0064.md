<events>
User edited "crates/search/src/buffer_search.rs":
```diff
@@ -703,7 +703,7 @@
         cx.notify();
     }
     
-    pub fn deploy_replace(&mut self, deploy_)
+    pub fn deploy_replace(&mut self, _:)
 
     pub fn deploy(&mut self, deploy: &Deploy, window: &mut Window, cx: &mut Context<Self>) -> bool {
         if self.show(window, cx) {

```
</events>
<input>
```zed/crates/search/src/buffer_search.rs
            editor_scroll_handle: ScrollHandle::new(),
            editor_needed_width: px(0.),
        }
    }

    pub fn is_dismissed(&self) -> bool {
        self.dismissed
    }

    pub fn dismiss(&mut self, _: &Dismiss, window: &mut Window, cx: &mut Context<Self>) {
        self.dismissed = true;
        for searchable_item in self.searchable_items_with_matches.keys() {
            if let Some(searchable_item) =
                WeakSearchableItemHandle::upgrade(searchable_item.as_ref(), cx)
            {
                searchable_item.clear_matches(window, cx);
            }
        }
        if let Some(active_editor) = self.active_searchable_item.as_mut() {
            self.selection_search_enabled = false;
            self.replace_enabled = false;
<|editable_region_start|>
            active_editor.search_bar_visibility_changed(false, window, cx);
            active_editor.toggle_filtered_search_ranges(false, window, cx);
            let handle = active_editor.item_focus_handle(cx);
            self.focus(&handle, window, cx);
        }
        cx.emit(Event::UpdateLocation);
        cx.emit(ToolbarItemEvent::ChangeLocation(
            ToolbarItemLocation::Hidden,
        ));
        cx.notify();
    }
    
    pub fn deploy_replace(&mut self, _:)

    pub fn deploy(&mut self, deploy: &Deploy, window: &mut<|user_cursor_is_here|> Window, cx: &mut Context<Self>) -> bool {
        if self.show(window, cx) {
            if let Some(active_item) = self.active_searchable_item.as_mut() {
                active_item.toggle_filtered_search_ranges(
<|editable_region_end|>
                    deploy.selection_search_enabled,
                    window,
                    cx,
                );
            }
            self.search_suggested(window, cx);
            self.smartcase(window, cx);
            self.replace_enabled = deploy.replace_enabled;
            self.selection_search_enabled = deploy.selection_search_enabled;
            if deploy.focus {
                let mut handle = self.query_editor.focus_handle(cx).clone();
                let mut select_query = true;
                if deploy.replace_enabled && handle.is_focused(window) {
                    handle = self.replacement_editor.focus_handle(cx).clone();
                    select_query = false;
                };

                if select_query {
                    self.select_query(window, cx);
                }

                window.focus(&handle);
            }
            return true;
        }

        cx.propagate();
        false
```
</input>
<output>
```zed/crates/search/src/buffer_search.rs
            editor_scroll_handle: ScrollHandle::new(),
            editor_needed_width: px(0.),
        }
    }

    pub fn is_dismissed(&self) -> bool {
        self.dismissed
    }

    pub fn dismiss(&mut self, _: &Dismiss, window: &mut Window, cx: &mut Context<Self>) {
        self.dismissed = true;
        for searchable_item in self.searchable_items_with_matches.keys() {
            if let Some(searchable_item) =
                WeakSearchableItemHandle::upgrade(searchable_item.as_ref(), cx)
            {
                searchable_item.clear_matches(window, cx);
            }
        }
        if let Some(active_editor) = self.active_searchable_item.as_mut() {
            self.selection_search_enabled = false;
            self.replace_enabled = false;
<|editable_region_start|>
            active_editor.search_bar_visibility_changed(false, window, cx);
            active_editor.toggle_filtered_search_ranges(false, window, cx);
            let handle = active_editor.item_focus_handle(cx);
            self.focus(&handle, window, cx);
        }
        cx.emit(Event::UpdateLocation);
        cx.emit(ToolbarItemEvent::ChangeLocation(
            ToolbarItemLocation::Hidden,
        ));
        cx.notify();
    }
    
    pub fn deploy_replace(&mut self, _: &DeployReplace, window: &mut Window, cx: &mut Context<Self>) -> bool {
        
    }

    pub fn deploy(&mut self, deploy: &Deploy, window: &mut Window, cx: &mut Context<Self>) -> bool {
        if self.show(window, cx) {
            if let Some(active_item) = self.active_searchable_item.as_mut() {
                active_item.toggle_filtered_search_ranges(
<|editable_region_end|>
                    deploy.selection_search_enabled,
                    window,
                    cx,
                );
            }
            self.search_suggested(window, cx);
            self.smartcase(window, cx);
            self.replace_enabled = deploy.replace_enabled;
            self.selection_search_enabled = deploy.selection_search_enabled;
            if deploy.focus {
                let mut handle = self.query_editor.focus_handle(cx).clone();
                let mut select_query = true;
                if deploy.replace_enabled && handle.is_focused(window) {
                    handle = self.replacement_editor.focus_handle(cx).clone();
                    select_query = false;
                };

                if select_query {
                    self.select_query(window, cx);
                }

                window.focus(&handle);
            }
            return true;
        }

        cx.propagate();
        false
```
</output>
<outline>
```crates/search/src/buffer_search.rs
mod registrar
const MAX_BUFFER_SEARCH_HISTORY_SIZE
pub struct Deploy
 pub focus
 pub replace_enabled
 pub selection_search_enabled
impl Deploy
 pub fn find
pub enum Event
 UpdateLocation
pub fn init
pub struct BufferSearchBar
 query_editor
 query_editor_focused
 replacement_editor
 replacement_editor_focused
 active_searchable_item
 active_match_index
 active_searchable_item_subscription
 active_search
 searchable_items_with_matches
 pending_search
 search_options
 default_options
 configured_options
 query_contains_error
 dismissed
 search_history
 search_history_cursor
 replace_enabled
 selection_search_enabled
 scroll_handle
 editor_scroll_handle
 editor_needed_width
impl BufferSearchBar
 fn render_text_input
 pub fn query_editor_focused
impl EventEmitter<Event> for BufferSearchBar
impl EventEmitter<workspace::ToolbarItemEvent> for BufferSearchBar
impl Render for BufferSearchBar
 fn render
impl Focusable for BufferSearchBar
 fn focus_handle
impl ToolbarItemView for BufferSearchBar
 fn set_active_pane_item
impl BufferSearchBar
 pub fn register
 pub fn new
 pub fn is_dismissed
 pub fn dismiss
 pub fn deploy_replace
 pub fn toggle
 pub fn show
 fn supported_options
 pub fn search_suggested
 pub fn activate_current_match
 pub fn select_query
 pub fn query
 pub fn replacement
 pub fn query_suggestion
 pub fn set_replacement
 pub fn search
 fn render_search_option_button
 pub fn focus_editor
 pub fn toggle_search_option
 pub fn has_search_option
 pub fn enable_search_option
 pub fn set_search_options
 fn select_next_match
 fn select_prev_match
 fn select_all_matches
 pub fn select_match
 pub fn select_last_match
 fn on_query_editor_event
 fn on_replacement_editor_event
 fn on_active_searchable_item_event
 fn toggle_case_sensitive
 fn toggle_whole_word
 fn toggle_selection
 fn toggle_regex
 fn clear_active_searchable_item_matches
 pub fn has_active_match
 fn clear_matches
 fn update_matches
 pub fn update_match_index
 fn tab
 fn tab_prev
 fn next_history_query
 fn previous_history_query
 fn focus
 fn toggle_replace
 fn replace_next
 pub fn replace_all
 pub fn match_exists
 pub fn should_use_smartcase_search
 pub fn is_contains_uppercase
 fn smartcase
mod tests
 fn init_globals
 fn init_test
 async fn test_search_simple
 fn display_points_of
 async fn test_search_option_handling
 async fn test_search_select_all_matches
 async fn test_search_query_with_match_whole_word
 async fn test_search_query_history
 async fn test_replace_simple
 struct ReplacementTestParams
  editor
  search_bar
  cx
  search_text
  search_options
  replacement_text
  replace_all
  expected_text
 async fn run_replacement_test
 async fn test_replace_special_characters
 async fn test_find_matches_in_selections_singleton_buffer_multiple_selections
 async fn test_find_matches_in_selections_multiple_excerpts_buffer_multiple_selections
 async fn test_invalid_regexp_search_after_valid
 async fn test_search_options_changes
 fn update_search_settings
```

</outline>
<rejected>
```zed/crates/search/src/buffer_search.rs
            editor_scroll_handle: ScrollHandle::new(),
            editor_needed_width: px(0.),
        }
    }

    pub fn is_dismissed(&self) -> bool {
        self.dismissed
    }

    pub fn dismiss(&mut self, _: &Dismiss, window: &mut Window, cx: &mut Context<Self>) {
        self.dismissed = true;
        for searchable_item in self.searchable_items_with_matches.keys() {
            if let Some(searchable_item) =
                WeakSearchableItemHandle::upgrade(searchable_item.as_ref(), cx)
            {
                searchable_item.clear_matches(window, cx);
            }
        }
        if let Some(active_editor) = self.active_searchable_item.as_mut() {
            self.selection_search_enabled = false;
            self.replace_enabled = false;
<|editable_region_start|>
            active_editor.search_bar_visibility_changed(false, window, cx);
            active_editor.toggle_filtered_search_ranges(false, window, cx);
            let handle = active_editor.item_focus_handle(cx);
            self.focus(&handle, window, cx);
        }
        cx.emit(Event::UpdateLocation);
        cx.emit(ToolbarItemEvent::ChangeLocation(
            ToolbarItemLocation::Hidden,
        ));
        cx.notify();
    }
    
    pub fn deploy_replace(&mut self, _: &Deploy, window: &mut Window, cx: &mut Context<Self>) -> bool {
        if self.show(window, cx) {
            if let Some(active_item) = self.active_searchable_item.as_mut() {
                active_item.toggle_filtered_search_ranges(
<|editable_region_end|>
                    deploy.selection_search_enabled,
                    window,
                    cx,
                );
            }
            self.search_suggested(window, cx);
            self.smartcase(window, cx);
            self.replace_enabled = deploy.replace_enabled;
            self.selection_search_enabled = deploy.selection_search_enabled;
            if deploy.focus {
                let mut handle = self.query_editor.focus_handle(cx).clone();
                let mut select_query = true;
                if deploy.replace_enabled && handle.is_focused(window) {
                    handle = self.replacement_editor.focus_handle(cx).clone();
                    select_query = false;
                };

                if select_query {
                    self.select_query(window, cx);
                }

                window.focus(&handle);
            }
            return true;
        }

        cx.propagate();
        false
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
