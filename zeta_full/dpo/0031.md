<events>
User edited "crates/terminal_view/src/terminal_panel.rs":
```diff
@@ -909,7 +909,7 @@
             workspace.clone(),
             project.clone(),
             Default::default(),
-            None,
+            Some(),
             NewTerminal.boxed_clone(),
             window,
             cx,

```
</events>
<input>
```crates/terminal_view/src/terminal_panel.rs
    fn has_no_terminals(&self, cx: &App) -> bool {
        self.active_pane.read(cx).items_len() == 0 && self.pending_terminals_to_add == 0
    }

    pub fn assistant_enabled(&self) -> bool {
        self.assistant_enabled
    }

    fn is_enabled(&self, cx: &App) -> bool {
        self.workspace.upgrade().map_or(false, |workspace| {
            is_enabled_in_workspace(workspace.read(cx), cx)
        })
    }
}

fn is_enabled_in_workspace(workspace: &Workspace, cx: &App) -> bool {
    workspace.project().read(cx).supports_terminal(cx)
}

pub fn new_terminal_pane(
    workspace: WeakEntity<Workspace>,
    project: Entity<Project>,
    zoomed: bool,
    window: &mut Window,
    cx: &mut Context<TerminalPanel>,
) -> Entity<Pane> {
    let is_local = project.read(cx).is_local();
    let terminal_panel = cx.entity().clone();
    let pane = cx.new(|cx| {
        let mut pane = Pane::new(
            workspace.clone(),
<|editable_region_start|>
            project.clone(),
    <|user_cursor_is_here|>        Default::default(),
            Some(),
            NewTerminal.boxed_clone(),
            window,
            cx,
        );
        pane.set_zoomed(zoomed, cx);
        pane.set_can_navigate(false, cx);
        pane.display_nav_history_buttons(None);
        pane.set_should_display_tab_bar(|_, _| true);
        pane.set_zoom_out_on_close(false);

        let split_closure_terminal_panel = terminal_panel.downgrade();
        pane.set_can_split(Some(Arc::new(move |pane, dragged_item, _window, cx| {
            if let Some(tab) = dragged_item.downcast_ref::<DraggedTab>() {
                let is_current_pane = tab.pane == cx.entity();
                let Some(can_drag_away) = split_closure_terminal_panel
<|editable_region_end|>
                    .update(cx, |terminal_panel, _| {
                        let current_panes = terminal_panel.center.panes();
                        !current_panes.contains(&&tab.pane)
                            || current_panes.len() > 1
                            || (!is_current_pane || pane.items_len() > 1)
                    })
                    .ok()
                else {
                    return false;
                };
                if can_drag_away {
                    let item = if is_current_pane {
                        pane.item_for_index(tab.ix)
                    } else {
                        tab.pane.read(cx).item_for_index(tab.ix)
                    };
                    if let Some(item) = item {
                        return item.downcast::<TerminalView>().is_some();
```
</input>
<output>
```crates/terminal_view/src/terminal_panel.rs
    fn has_no_terminals(&self, cx: &App) -> bool {
        self.active_pane.read(cx).items_len() == 0 && self.pending_terminals_to_add == 0
    }

    pub fn assistant_enabled(&self) -> bool {
        self.assistant_enabled
    }

    fn is_enabled(&self, cx: &App) -> bool {
        self.workspace.upgrade().map_or(false, |workspace| {
            is_enabled_in_workspace(workspace.read(cx), cx)
        })
    }
}

fn is_enabled_in_workspace(workspace: &Workspace, cx: &App) -> bool {
    workspace.project().read(cx).supports_terminal(cx)
}

pub fn new_terminal_pane(
    workspace: WeakEntity<Workspace>,
    project: Entity<Project>,
    zoomed: bool,
    window: &mut Window,
    cx: &mut Context<TerminalPanel>,
) -> Entity<Pane> {
    let is_local = project.read(cx).is_local();
    let terminal_panel = cx.entity().clone();
    let pane = cx.new(|cx| {
        let mut pane = Pane::new(
            workspace.clone(),
<|editable_region_start|>
            project.clone(),
            Default::default(),
            Some(),
            NewTerminal.boxed_clone(),
            window,
            cx,
        );
        pane.set_zoomed(zoomed, cx);
        pane.set_can_navigate(false, cx);
        pane.display_nav_history_buttons(None);
        pane.set_should_display_tab_bar(|_, _| true);
        pane.set_zoom_out_on_close(false);

        let split_closure_terminal_panel = terminal_panel.downgrade();
        pane.set_can_split(Some(Arc::new(move |pane, dragged_item, _window, cx| {
            if let Some(tab) = dragged_item.downcast_ref::<DraggedTab>() {
                let is_current_pane = tab.pane == cx.entity();
                let Some(can_drag_away) = split_closure_terminal_panel
<|editable_region_end|>
                    .update(cx, |terminal_panel, _| {
                        let current_panes = terminal_panel.center.panes();
                        !current_panes.contains(&&tab.pane)
                            || current_panes.len() > 1
                            || (!is_current_pane || pane.items_len() > 1)
                    })
                    .ok()
                else {
                    return false;
                };
                if can_drag_away {
                    let item = if is_current_pane {
                        pane.item_for_index(tab.ix)
                    } else {
                        tab.pane.read(cx).item_for_index(tab.ix)
                    };
                    if let Some(item) = item {
                        return item.downcast::<TerminalView>().is_some();
```
</output>
<outline>
```crates/terminal_view/src/terminal_panel.rs
const TERMINAL_PANEL_KEY
pub fn init
pub struct TerminalPanel
 pub(crate) active_pane
 pub(crate) center
 fs
 workspace
 pub(crate) width
 pub(crate) height
 pending_serialization
 pending_terminals_to_add
 deferred_tasks
 assistant_enabled
 assistant_tab_bar_button
 active
impl TerminalPanel
 pub fn new
 pub fn set_assistant_enabled
 fn apply_tab_bar_buttons
 pub async fn load
 fn handle_pane_event
 fn new_pane_with_cloned_active_terminal
 pub fn open_terminal
 fn spawn_task
 pub fn spawn_in_new_terminal
 fn new_terminal
 fn terminals_for_task
 fn activate_terminal_view
 pub fn add_center_terminal
 fn add_terminal
 fn serialize
 fn replace_terminal
 fn has_no_terminals
 pub fn assistant_enabled
 fn is_enabled
fn is_enabled_in_workspace
pub fn new_terminal_pane
async fn wait_for_terminals_tasks
fn add_paths_to_terminal
impl EventEmitter<PanelEvent> for TerminalPanel
impl Render for TerminalPanel
 fn render
impl Focusable for TerminalPanel
 fn focus_handle
impl Panel for TerminalPanel
 fn position
 fn position_is_valid
 fn set_position
 fn size
 fn set_size
 fn is_zoomed
 fn set_zoomed
 fn set_active
 fn icon_label
 fn persistent_name
 fn icon
 fn icon_tooltip
 fn toggle_action
 fn pane
 fn activation_priority
struct InlineAssistTabBarButton
 focus_handle
impl Render for InlineAssistTabBarButton
 fn render
```

</outline>
<rejected>
```crates/terminal_view/src/terminal_panel.rs
    fn has_no_terminals(&self, cx: &App) -> bool {
        self.active_pane.read(cx).items_len() == 0 && self.pending_terminals_to_add == 0
    }

    pub fn assistant_enabled(&self) -> bool {
        self.assistant_enabled
    }

    fn is_enabled(&self, cx: &App) -> bool {
        self.workspace.upgrade().map_or(false, |workspace| {
            is_enabled_in_workspace(workspace.read(cx), cx)
        })
    }
}

fn is_enabled_in_workspace(workspace: &Workspace, cx: &App) -> bool {
    workspace.project().read(cx).supports_terminal(cx)
}

pub fn new_terminal_pane(
    workspace: WeakEntity<Workspace>,
    project: Entity<Project>,
    zoomed: bool,
    window: &mut Window,
    cx: &mut Context<TerminalPanel>,
) -> Entity<Pane> {
    let is_local = project.read(cx).is_local();
    let terminal_panel = cx.entity().clone();
    let pane = cx.new(|cx| {
        let mut pane = Pane::new(
            workspace.clone(),
<|editable_region_start|>
            project.clone(),
    <|editable_region_end|>
                    .update(cx, |terminal_panel, _| {
                        let current_panes = terminal_panel.center.panes();
                        !current_panes.contains(&&tab.pane)
                            || current_panes.len() > 1
                            || (!is_current_pane || pane.items_len() > 1)
                    })
                    .ok()
                else {
                    return false;
                };
                if can_drag_away {
                    let item = if is_current_pane {
                        pane.item_for_index(tab.ix)
                    } else {
                        tab.pane.read(cx).item_for_index(tab.ix)
                    };
                    if let Some(item) = item {
                        return item.downcast::<TerminalView>().is_some();
```
</rejected>

<labels>
no-op,unknown
</labels>
