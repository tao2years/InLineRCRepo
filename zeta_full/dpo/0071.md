<events>
User edited "crates/call/src/cross_platform/room.rs":
```diff
@@ -531,6 +531,7 @@
     pub fn local_participant(&self) -> &LocalParticipant {
         &self.local_participant
     }
+    
 
     pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {
         &self.remote_participants

```
</events>
<input>
```zed/crates/call/src/cross_platform/room.rs
                for reshared_project in response.reshared_projects {
                    if let Some(project) = projects.get(&reshared_project.id) {
                        project.update(cx, |project, cx| {
                            project.reshared(reshared_project, cx).log_err();
                        });
                    }
                }

                for rejoined_project in response.rejoined_projects {
                    if let Some(project) = projects.get(&rejoined_project.id) {
                        project.update(cx, |project, cx| {
                            project.rejoined(rejoined_project, message_id, cx).log_err();
                        });
                    }
                }

                anyhow::Ok(())
            })?
        })
    }

<|editable_region_start|>
    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn status(&self) -> RoomStatus {
        self.status
    }

    pub fn local_participant(&self) -> &LocalParticipant {
        &self.local_participant
    }
    <|user_cursor_is_here|>

    pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {
        &self.remote_participants
    }

    pub fn remote_participant_for_peer_id(&self, peer_id: PeerId) -> Option<&RemoteParticipant> {
        self.remote_participants
            .values()
            .find(|p| p.peer_id == peer_id)
    }
<|editable_region_end|>

    pub fn role_for_user(&self, user_id: u64) -> Option<proto::ChannelRole> {
        self.remote_participants
            .get(&user_id)
            .map(|participant| participant.role)
    }

    pub fn contains_guests(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
            || self
                .remote_participants
                .values()
                .any(|p| p.role == proto::ChannelRole::Guest)
    }

    pub fn local_participant_is_admin(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Admin
    }

    pub fn local_participant_is_guest(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
    }
```
</input>
<output>
```zed/crates/call/src/cross_platform/room.rs
                for reshared_project in response.reshared_projects {
                    if let Some(project) = projects.get(&reshared_project.id) {
                        project.update(cx, |project, cx| {
                            project.reshared(reshared_project, cx).log_err();
                        });
                    }
                }

                for rejoined_project in response.rejoined_projects {
                    if let Some(project) = projects.get(&rejoined_project.id) {
                        project.update(cx, |project, cx| {
                            project.rejoined(rejoined_project, message_id, cx).log_err();
                        });
                    }
                }

                anyhow::Ok(())
            })?
        })
    }

<|editable_region_start|>
    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn status(&self) -> RoomStatus {
        self.status
    }

    pub fn local_participant(&self) -> &LocalParticipant {
        &self.local_participant
    }
    
    pub fn local_participant_mut(&mut self) -> &mut LocalParticipant {
        &mut self.local_participant
    }

    pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {
        &self.remote_participants
    }

    pub fn remote_participant_for_peer_id(&self, peer_id: PeerId) -> Option<&RemoteParticipant> {
        self.remote_participants
            .values()
            .find(|p| p.peer_id == peer_id)
    }
<|editable_region_end|>

    pub fn role_for_user(&self, user_id: u64) -> Option<proto::ChannelRole> {
        self.remote_participants
            .get(&user_id)
            .map(|participant| participant.role)
    }

    pub fn contains_guests(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
            || self
                .remote_participants
                .values()
                .any(|p| p.role == proto::ChannelRole::Guest)
    }

    pub fn local_participant_is_admin(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Admin
    }

    pub fn local_participant_is_guest(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
    }
```
</output>
<outline>
```crates/call/src/cross_platform/room.rs
pub const RECONNECT_TIMEOUT
pub enum Event
 RoomJoined
  channel_id
 ParticipantLocationChanged
  participant_id
 RemoteVideoTracksChanged
  participant_id
 RemoteAudioTracksChanged
  participant_id
 RemoteProjectShared
  owner
  project_id
  worktree_root_names
 RemoteProjectUnshared
  project_id
 RemoteProjectJoined
  project_id
 RemoteProjectInvitationDiscarded
  project_id
 RoomLeft
  channel_id
pub struct Room
 id
 channel_id
 live_kit
 status
 shared_projects
 joined_projects
 local_participant
 remote_participants
 pending_participants
 participant_user_ids
 pending_call_count
 leave_when_empty
 client
 user_store
 follows_by_leader_id_project_id
 client_subscriptions
 _subscriptions
 room_update_completed_tx
 room_update_completed_rx
 pending_room_update
 maintain_connection
impl EventEmitter<Event> for Room
impl Room
 pub fn channel_id
 pub fn is_sharing_project
 pub fn is_connected
 fn new
 pub(crate) fn create
 pub(crate) async fn join_channel
 pub(crate) async fn join
 fn released
 fn app_will_quit
 pub fn mute_on_join
 fn from_join_response
 fn should_leave
 pub(crate) fn leave
 fn leave_internal
 pub(crate) fn clear_state
 async fn maintain_connection
 fn rejoin
 pub fn id
 pub fn status
 pub fn local_participant
 pub fn remote_participants
 pub fn remote_participant_for_peer_id
 pub fn role_for_user
 pub fn contains_guests
 pub fn local_participant_is_admin
 pub fn local_participant_is_guest
 pub fn set_participant_role
 pub fn pending_participants
 pub fn contains_participant
 pub fn followers_for
 pub fn most_active_project
 async fn handle_room_updated
 fn apply_room_update
 pub fn room_update_completed
 fn start_room_connection
 fn start_room_connection
 fn livekit_room_updated
 fn check_invariants
 pub(crate) fn call
 pub fn join_project
 pub fn share_project
 pub(crate) fn unshare_project
 pub(crate) fn set_location
 pub fn is_screen_sharing
 pub fn is_sharing_mic
 pub fn is_muted
 pub fn muted_by_user
 pub fn is_speaking
 pub fn is_deafened
 pub fn can_use_microphone
 pub fn can_share_projects
 pub fn share_microphone
 pub fn share_microphone
 pub fn share_screen
 pub fn share_screen
 pub fn toggle_mute
 pub fn toggle_deafen
 pub fn unshare_screen
 fn set_deafened
 fn set_mute
fn spawn_room_connection
fn spawn_room_connection
struct LiveKitRoom
 room
 screen_track
 microphone_track
 muted_by_user
 deafened
 speaking
 next_publish_id
 _handle_updates
impl LiveKitRoom
 fn stop_publishing
 fn stop_publishing
enum LocalTrack
 None
 Pending
  publish_id
 Published
  track_publication
  _stream
impl Default for LocalTrack
 fn default
pub enum RoomStatus
 Online
 Rejoining
 Offline
impl RoomStatus
 pub fn is_offline
 pub fn is_online
```

</outline>
<rejected>
```zed/crates/call/src/cross_platform/room.rs
                for reshared_project in response.reshared_projects {
                    if let Some(project) = projects.get(&reshared_project.id) {
                        project.update(cx, |project, cx| {
                            project.reshared(reshared_project, cx).log_err();
                        });
                    }
                }

                for rejoined_project in response.rejoined_projects {
                    if let Some(project) = projects.get(&rejoined_project.id) {
                        project.update(cx, |project, cx| {
                            project.rejoined(rejoined_project, message_id, cx).log_err();
                        });
                    }
                }

                anyhow::Ok(())
            })?
        })
    }

<|editable_region_start|>
    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn status(&self) -> RoomStatus {
        self.status
    }

    pub fn local_participant(&self) -> &LocalParticipant {
        &self.local_participant
    }

    pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {
        &self.remote_participants
    }

    pub fn remote_participant_for_peer_id(&self, peer_id: PeerId) -> Option<&RemoteParticipant> {
        self.remote_participants
            .values()
            .find(|p| p.peer_id == peer_id)
    }
<|editable_region_end|>

    pub fn role_for_user(&self, user_id: u64) -> Option<proto::ChannelRole> {
        self.remote_participants
            .get(&user_id)
            .map(|participant| participant.role)
    }

    pub fn contains_guests(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
            || self
                .remote_participants
                .values()
                .any(|p| p.role == proto::ChannelRole::Guest)
    }

    pub fn local_participant_is_admin(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Admin
    }

    pub fn local_participant_is_guest(&self) -> bool {
        self.local_participant.role == proto::ChannelRole::Guest
    }
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
