<events>
User edited "services/webserver/src/server/websocket/session.rs":
```diff
@@ -40,6 +40,7 @@
         session: &mut Session,
         message: ServerResponse,
     ) -> Result<(), WebsocketError> {
+        
         let msg_encoded = serde_json::to_vec(&message)
             .map_err(WebsocketError::UnserializablePayload)?;
         session.binary(msg_encoded).await?;

```
</events>
<input>
```services/webserver/src/server/websocket/session.rs
    FuelStreams,
};
use fuel_web_utils::{
    server::middlewares::api_key::{
        rate_limiter::RateLimitsController,
        ApiKey,
    },
    telemetry::Telemetry,
};
use tokio::sync::{broadcast, Mutex};
<|editable_region_start|>

use crate::{
    metrics::{Metrics, SubscriptionChange},
    server::errors::WebsocketError,
};

#[derive(Clone)]
struct MessageHandler {
    api_key: ApiKey,
}

impl MessageHandler {
    fn new(api_key: &ApiKey) -> Self {
        Self {
            api_key: api_key.to_owned(),
        }
    }

    async fn send_message(
        &self,
        session: &mut Session,
        message: ServerResponse,
    ) -> Result<(), WebsocketError> {
        <|user_cursor_is_here|>
        let msg_encoded = serde_json::to_vec(&message)
            .map_err(WebsocketError::UnserializablePayload)?;
        session.binary(msg_encoded).await?;
        Ok(())
    }

    async fn send_error(
        &self,
        session: &mut Session,
        error: &WebsocketError,
    ) -> Result<(), WebsocketError> {
        let api_key = self.api_key.to_owned();
        let error_msg = ServerResponse::Error(error.to_string());
        if let Err(send_err) = self.send_message(session, error_msg).await {
            tracing::error!(
                %api_key,
                error = %send_err,
                "Failed to send error message"
            );
            return Err(WebsocketError::SendError);
        }
        Ok(())
    }
}

#[derive(Clone)]
struct MetricsHandler {
    telemetry: Arc<Telemetry<Metrics>>,
    api_key: ApiKey,
}

<|editable_region_end|>
impl MetricsHandler {
    fn new(telemetry: Arc<Telemetry<Metrics>>, api_key: &ApiKey) -> Self {
```
</input>
<output>
```services/webserver/src/server/websocket/session.rs
    FuelStreams,
};
use fuel_web_utils::{
    server::middlewares::api_key::{
        rate_limiter::RateLimitsController,
        ApiKey,
    },
    telemetry::Telemetry,
};
use tokio::sync::{broadcast, Mutex};
<|editable_region_start|>

use crate::{
    metrics::{Metrics, SubscriptionChange},
    server::errors::WebsocketError,
};

#[derive(Clone)]
struct MessageHandler {
    api_key: ApiKey,
}

impl MessageHandler {
    fn new(api_key: &ApiKey) -> Self {
        Self {
            api_key: api_key.to_owned(),
        }
    }

    async fn send_message(
        &self,
        session: &mut Session,
        message: ServerResponse,
    ) -> Result<(), WebsocketError> {
        tracing::debug!(%self.api_key, "Sending websocket message");
        let msg_encoded = serde_json::to_vec(&message)
            .map_err(WebsocketError::UnserializablePayload)?;
        session.binary(msg_encoded).await?;
        Ok(())
    }

    async fn send_error(
        &self,
        session: &mut Session,
        error: &WebsocketError,
    ) -> Result<(), WebsocketError> {
        let api_key = self.api_key.to_owned();
        let error_msg = ServerResponse::Error(error.to_string());
        if let Err(send_err) = self.send_message(session, error_msg).await {
            tracing::error!(
                %api_key,
                error = %send_err,
                "Failed to send error message"
            );
            return Err(WebsocketError::SendError);
        }
        Ok(())
    }
}

#[derive(Clone)]
struct MetricsHandler {
    telemetry: Arc<Telemetry<Metrics>>,
    api_key: ApiKey,
}

<|editable_region_end|>
impl MetricsHandler {
    fn new(telemetry: Arc<Telemetry<Metrics>>, api_key: &ApiKey) -> Self {
```
</output>
<outline>
```services/webserver/src/server/websocket/session.rs
struct MessageHandler
 api_key
impl MessageHandler
 fn new
 async fn send_message
 async fn send_error
struct MetricsHandler
 telemetry
 api_key
impl MetricsHandler
 fn new
 fn track_subscription
 fn track_connection_duration
 fn track_duplicate_subscription
struct ConnectionManager
 api_key
 start_time
 tx
 active_subscriptions
 metrics_handler
 rate_limiter_controller
impl ConnectionManager
 pub const CLIENT_TIMEOUT
 pub const HEARTBEAT_INTERVAL
 pub const MAX_FRAME_SIZE
 pub const CHANNEL_CAPACITY
 fn new
 fn subscribe
 async fn shutdown
 async fn is_subscribed
 async fn add_subscription
 async fn remove_subscription
 async fn clear_subscriptions
 fn connection_duration
 async fn check_duplicate_subscription
 async fn heartbeat
pub struct WsSession
 api_key
 messaging
 connection
 pub streams
impl WsSession
 pub fn new
 pub fn receiver
 pub fn api_key
 pub async fn send_message
 pub async fn send_error_msg
 pub async fn is_subscribed
 pub async fn add_subscription
 pub async fn remove_subscription
 pub async fn check_duplicate_subscription
 pub async fn shutdown_subscription
 pub async fn close_session
 fn log_connection_close
 pub async fn heartbeat
 pub fn heartbeat_interval
 pub fn max_frame_size
```

</outline>
<rejected>
```services/webserver/src/server/websocket/session.rs
    FuelStreams,
};
use fuel_web_utils::{
    server::middlewares::api_key::{
        rate_limiter::RateLimitsController,
        ApiKey,
    },
    telemetry::Telemetry,
};
use tokio::sync::{broadcast, Mutex};
<|editable_region_start|>

use crate::{
    metrics::{Metrics, SubscriptionChange},
    server::errors::WebsocketError,
};

#[derive(Clone)]
struct MessageHandler {
    api_key: ApiKey,
}

impl MessageHandler {
    fn new(api_key: &ApiKey) -> Self {
        Self {
            api_key: api_key.to_owned(),
        }
    }

    async fn send_message(
        &self,
        session: &mut Session,
        message: ServerResponse,
    ) -> Result<(), WebsocketError> {
        let msg_encoded = serde_json::to_vec(&message)
            .map_err(WebsocketError::UnserializablePayload)?;
        session.binary(msg_encoded).await?;
        Ok(())
    }

    async fn send_error(
        &self,
        session: &mut Session,
        error: &WebsocketError,
    ) -> Result<(), WebsocketError> {
        let api_key = self.api_key.to_owned();
        let error_msg = ServerResponse::Error(error.to_string());
        if let Err(send_err) = self.send_message(session, error_msg).await {
            tracing::error!(
                %api_key,
                error = %send_err,
                "Failed to send error message"
            );
            return Err(WebsocketError::SendError);
        }
        Ok(())
    }
}

#[derive(Clone)]
struct MetricsHandler {
    telemetry: Arc<Telemetry<Metrics>>,
    api_key: ApiKey,
}

<|editable_region_end|>
impl MetricsHandler {
    fn new(telemetry: Arc<Telemetry<Metrics>>, api_key: &ApiKey) -> Self {
```
</rejected>

<labels>
local-edit,complete-pattern
</labels>
