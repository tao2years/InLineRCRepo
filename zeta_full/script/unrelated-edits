#!/usr/bin/env python3

import os
import re
from pathlib import Path
from collections import OrderedDict

def get_edited_files(content):
    # Find all "User edited file:" lines
    edits = re.findall(r'User edited (?:file: )?"([^"]+)":', content)
    return sorted(edits)  # Sort the edited files

def get_input_file(content):
    # Find the filename at start of <input> section
    match = re.search(r'<input>\n```([^\n]+)\n', content)
    if match:
        # Extract just the filepath part before any potential additional content
        return match.group(1).split()[0]
    return None

def analyze_file(filepath):
    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()
    
    edited_files = get_edited_files(content)
    input_file = get_input_file(content)
    
    # Check conditions:
    # 1. Has 2+ edits
    # 2. At least one edit is to a different file than input file
    if len(edited_files) >= 2 and any(f != input_file for f in edited_files):
        return (filepath, input_file, edited_files)
    return None

def main():
    train_dir = Path('train')
    if not train_dir.exists():
        print("Error: 'train' directory not found")
        return

    # Collect all matching files and sort by filepath
    matching_files = []
    for md_file in train_dir.glob('*.md'):
        result = analyze_file(md_file)
        if result:
            matching_files.append(result)
    
    # Sort by filepath
    matching_files.sort(key=lambda x: str(x[0]))
    
    # Print results
    for filepath, input_file, edited_files in matching_files:
        print(f"\n{filepath}:")
        print(f"Input file: {input_file}")
        print("Edited files:", edited_files)
            
    print(f"\nTotal matching files: {len(matching_files)}")

if __name__ == '__main__':
    main()
