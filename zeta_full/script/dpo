#!/usr/bin/env node

const fs = require("fs").promises;
const path = require("path");
const OpenAI = require("openai");
const random_seed = require("random-seed");
const yargs = require("yargs");

if (!process.env.PREDICTION_API_URL) {
  throw new Error("PREDICTION_API_URL environment variable must be set");
}
if (!process.env.PREDICTION_API_KEY) {
  throw new Error("PREDICTION_API_KEY environment variable must be set");
}
if (!process.env.PREDICTION_MODEL) {
  throw new Error("PREDICTION_MODEL environment variable must be set");
}

const fireworks = new OpenAI({
  baseURL: process.env.PREDICTION_API_URL,
  apiKey: process.env.PREDICTION_API_KEY,
});

function getTagContent(content, tag) {
  const regex = new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`);
  const match = content.match(regex);
  return match ? match[1].trim() : "";
}

async function processFile(
  filePath,
  randomizeEditableRegion,
  randomizeCursorLocation,
  eventsToKeep,
) {
  try {
    const content = await fs.readFile(filePath, "utf8");
    const seed = Buffer.from(filePath).reduce((acc, byte) => acc + byte, 0);
    const rng = random_seed.create(seed);

    let inputContent = getTagContent(content, "input");
    let eventsContent = getTagContent(content, "events");

    if (!inputContent) {
      console.log(`Skipping ${filePath}: Could not find input`);
      return;
    }

    if (eventsContent == null) {
      console.log(`Skipping ${filePath}: Could not find events`);
      return;
    }

    if (eventsToKeep != null) {
      const edits = [...eventsContent.matchAll(/User edited/g)];
      if (edits.length > 0) {
        const editStartIndex = Math.max(0, edits.length - eventsToKeep);
        eventsContent = eventsContent.slice(edits[editStartIndex].index);
      }
    }

    if (randomizeCursorLocation) {
      inputContent = inputContent.replace("<|user_cursor_is_here|>", "");
    }

    const inputLines = inputContent.split("\n");
    const startIndex = inputLines.findIndex((line) =>
      line.includes("<|editable_region_start|>"),
    );
    const endIndex = inputLines.findIndex((line) =>
      line.includes("<|editable_region_end|>"),
    );

    if (startIndex === -1 || endIndex === -1) {
      console.log(
        `Skipping ${filePath}: Could not find editable region markers`,
      );
      return;
    }

    if (randomizeEditableRegion) {
      // Remove old markers
      inputLines.splice(endIndex, 1);
      inputLines.splice(startIndex, 1);

      let cursorIndex;
      if (randomizeCursorLocation) {
        // Reposition user cursor to get more variance in the data.
        cursorIndex = rng.intBetween(1, inputLines.length - 2);
        const lineToModify = inputLines[cursorIndex];
        const randomOffset = rng.intBetween(0, lineToModify.length);
        inputLines[cursorIndex] =
          lineToModify.slice(0, randomOffset) +
          "<|user_cursor_is_here|>" +
          lineToModify.slice(randomOffset);
      } else {
        // Find the cursor in the input lines
        cursorIndex = inputLines.findIndex((line) =>
          line.includes("<|user_cursor_is_here|>"),
        );
        if (cursorIndex === -1) {
          throw new Error("cursor not found");
        }
      }

      // Pick random start above cursor
      let newStartIndex = 1;
      if (inputLines[1] == "<|start_of_file|>") {
        newStartIndex = 2;
      }
      newStartIndex = rng.intBetween(
        newStartIndex,
        Math.max(newStartIndex, cursorIndex),
      );
      // Pick random end below cursor
      const newEndIndex = rng.intBetween(
        Math.min(inputLines.length - 1, cursorIndex + 1),
        inputLines.length - 1,
      );

      // Add new markers
      inputLines.splice(newEndIndex, 0, "<|editable_region_end|>");
      inputLines.splice(newStartIndex, 0, "<|editable_region_start|>");
      inputContent = inputLines.join("\n");
    }

    const prompt = await fs.readFile(
      path.join(__dirname, "prediction-prompt.md"),
      "utf8",
    );

    // Generate completion using Fireworks API
    const completion = await fireworks.completions.create({
      model: process.env.PREDICTION_MODEL,
      prompt: prompt
        .replace("<events>", eventsContent)
        .replace("<excerpt>", inputContent),
      max_tokens: 2048,
      temperature: 0.0,
    });

    const inputPrefix = inputContent.substring(
      0,
      inputContent.indexOf("<|editable_region_start|>"),
    );
    let output = `${inputPrefix}${completion.choices[0].text}`;
    // Remove trailing newline if present
    if (output.endsWith("\n")) {
      output = output.slice(0, -1);
    }

    // Replace the output and rejected tags in the file
    let updatedContent = content.replace(
      new RegExp(`<input>[\\s\\S]*?<\\/input>`),
      `<input>\n${inputContent}\n</input>`,
    );

    if (eventsToKeep) {
      updatedContent = updatedContent.replace(
        new RegExp(`<events>[\\s\\S]*?<\\/events>`),
        `<events>\n${eventsContent}\n</events>`,
      );
    }

    const outputReplacement = `<output>\n${output}\n</output>`;
    const rejectedReplacement = `<rejected>\n${output}\n</rejected>`;

    if (updatedContent.includes("<output>")) {
      updatedContent = updatedContent.replace(
        new RegExp(`<output>[\\s\\S]*?<\\/output>`),
        outputReplacement,
      );
    } else {
      updatedContent += `\n${outputReplacement}`;
    }

    if (updatedContent.includes("<rejected>")) {
      updatedContent = updatedContent.replace(
        new RegExp(`<rejected>[\\s\\S]*?<\\/rejected>`),
        rejectedReplacement,
      );
    } else {
      updatedContent += `\n${rejectedReplacement}`;
    }

    // Write the updated content back to the file
    await fs.writeFile(filePath, updatedContent, "utf8");
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
  }
}

async function processDirectory(
  dirPath,
  randomizeEditableRegion,
  randomizeCursorLocation,
  eventsToKeep,
) {
  const files = await fs.readdir(dirPath);
  const markdownFiles = files.filter((file) => file.endsWith(".md"));

  let processed = 0;
  const startTime = Date.now();

  const BATCH_SIZE = 128;
  for (let i = 0; i < markdownFiles.length; i += BATCH_SIZE) {
    const batch = markdownFiles.slice(i, i + BATCH_SIZE);
    await Promise.all(
      batch.map(async (file) => {
        const fullPath = path.join(dirPath, file);
        await processFile(
          fullPath,
          randomizeEditableRegion,
          randomizeCursorLocation,
          eventsToKeep,
        );
        processed++;
      }),
    );
    console.log(`Processed ${processed} files`);
  }

  const elapsedSeconds = (Date.now() - startTime) / 1000;
  const rate = processed / elapsedSeconds;
  console.log(
    `Processed ${processed} files at ${rate.toFixed(2)} files/second`,
  );
}

// Parse command line arguments
const argv = yargs
  .option("input", {
    alias: "i",
    description: "Input file or directory path",
    type: "string",
    default: "./completions",
  })
  .option("randomize-editable-region", {
    alias: "r",
    description: "Randomize editable region positions",
    type: "boolean",
    default: false,
  })
  .option("randomize-cursor-location", {
    alias: "c",
    description: "Randomize cursor positions",
    type: "boolean",
    default: false,
  })
  .option("events-to-keep", {
    alias: "e",
    description: "Number of events to keep (0 keeps none)",
    type: "number",
  })
  .help()
  .alias("help", "h").argv;

const inputPath = argv.input;

async function main() {
  try {
    if (argv.randomizeCursorLocation && !argv.randomizeEditableRegion) {
      throw new Error(
        "Cannot randomize cursor location without randomizing editable region",
      );
    }

    const stats = await fs.stat(inputPath);

    if (stats.isDirectory()) {
      await processDirectory(
        inputPath,
        argv.randomizeEditableRegion,
        argv.randomizeCursorLocation,
        argv.eventsToKeep,
      );
    } else if (stats.isFile() && inputPath.endsWith(".md")) {
      await processFile(
        inputPath,
        argv.randomizeEditableRegion,
        argv.randomizeCursorLocation,
        argv.eventsToKeep,
      );
    } else {
      console.log("Please provide a markdown file or directory path");
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
