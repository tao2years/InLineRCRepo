# InLineRCRepo 数据调用关系详解

## 📋 目录
1. [核心数据结构](#核心数据结构)
2. [模块间调用关系](#模块间调用关系)
3. [数据转换流程](#数据转换流程)
4. [关键函数调用链](#关键函数调用链)
5. [数据流向追踪](#数据流向追踪)

---

## 1. 核心数据结构

### 1.1 GitDiffRecord (Zeta数据格式)

**定义位置**: `zeta_full/data_processor.py`

```python
@dataclass
class GitDiffRecord:
    """原始Git Diff数据结构"""
    mrcr_url: str              # MR/CR链接
    file_path: str             # 文件路径
    code_type: str             # 编程语言 (java/python/js)
    old_file: str              # 修改前完整文件内容
    new_file: str              # 修改后完整文件内容
    old_hunk: str              # 修改前代码块
    new_hunk: str              # 修改后代码块
    old_commit_id: str         # 旧commit SHA
    new_commit_id: str         # 新commit SHA
    review_line: int           # Review所在行号
    review_message: str        # Review评论内容
    severity: str              # 严重程度
    category: str              # 分类
    author: str                # 作者
    start_line: int            # 起始行号
    end_line: int              # 结束行号
    code_with_line: str        # 带行号的代码
```

**使用场景**:
- Zeta数据集解析
- Git历史分析
- Code Review信息提取

---

### 1.2 BenchmarkEntry (Benchmark数据格式)

**定义位置**: 隐式定义，通过JSON Schema体现

```python
{
    "prompt": str,              # 完整的prompt文本
    "domain": str,              # 领域标识 (nl2code_java)
    "id": str,                  # 唯一标识符
    "good_example_response": str,  # 期望的代码响应
    "reward_command": str,      # 测试命令
    "extra_content": {          # 额外元数据
        "query": str,           # 功能查询描述
        "diff_path": str,       # diff文件路径
        "test_result": str,     # 测试结果 (pass/fail)
        "file_path": str,       # 源文件路径
        "start_line": int,      # 起始行号
        "end_line": int,        # 结束行号
        "work_dir": str         # 工作目录
    }
}
```

**使用场景**:
- Benchmark数据存储
- 模型训练输入
- 评测数据加载

---

### 1.3 CodeContext (代码上下文)

**定义位置**: `scripts/end_to_end_processor.py`

```python
{
    'context_above': str,       # 上文代码 (带行号)
    'context_below': str,       # 下文代码 (带行号)
    'selected_region': str,     # 选中的代码区域
    'target_implementation': str,  # 目标实现代码
    'final_code_with_annotations': str  # 完整代码(带标注)
}
```

**使用场景**:
- 代码上下文提取
- Prompt构建
- RC生成输入

---

### 1.4 RecentChange (Recent Changes)

**定义位置**: `create_multi_rc_benchmarks.py`

```python
{
    'number': int,              # RC编号 (1/2/3)
    'content': str,             # RC完整内容
    'description': str,         # 描述 (Latest/Intermediate/Earliest)
    'diff_content': str         # Diff内容
}
```

**使用场景**:
- RC信息存储
- 多版本生成
- Prompt组装

---

## 2. 模块间调用关系

### 2.1 数据下载模块

```
download_zeta_dataset.py
    ├── huggingface_hub.snapshot_download()
    │   └── 下载完整数据集到 zeta_full/
    │
    └── datasets.load_dataset()
        └── 加载并导出为JSONL/Parquet
            ├── train.jsonl
            ├── eval.jsonl
            └── dpo.jsonl
```

**调用示例**:
```python
# 1. 快照下载
local_path = snapshot_download(
    repo_id="zed-industries/zeta",
    repo_type="dataset",
    local_dir="zeta_full"
)

# 2. 结构化导出
ds = load_dataset("zed-industries/zeta")
ds['train'].to_json("zeta_exports/train.jsonl")
```

---

### 2.2 数据处理模块

```
data_processor.py
    ├── CursorPositionInferrer
    │   ├── infer_cursor_position(GitDiffRecord)
    │   │   ├── _parse_code_with_line()
    │   │   ├── _analyze_diff_type()
    │   │   └── _find_modification_point()
    │   └── 返回: (line_num, col_pos)
    │
    ├── ContextExtractor
    │   ├── extract_context(GitDiffRecord, cursor_pos)
    │   │   ├── _split_code_by_cursor()
    │   │   ├── _get_context_window()
    │   │   └── _format_with_line_numbers()
    │   └── 返回: CodeContext
    │
    └── RecentChangesBuilder
        ├── build_recent_changes(GitDiffRecord)
        │   ├── _extract_diff_hunks()
        │   ├── _format_as_unified_diff()
        │   └── _add_line_annotations()
        └── 返回: List[RecentChange]
```

**调用链示例**:
```python
# 完整处理流程
git_record = parse_git_diff(raw_data)
    ↓
cursor_pos = CursorPositionInferrer().infer_cursor_position(git_record)
    ↓
context = ContextExtractor().extract_context(git_record, cursor_pos)
    ↓
recent_changes = RecentChangesBuilder().build_recent_changes(git_record)
    ↓
prompt = build_prompt(context, recent_changes)
```

---

### 2.3 端到端处理模块

```
end_to_end_processor.py
    ├── EndToEndProcessor
    │   ├── load_benchmark_data()
    │   │   └── 读取JSONL → List[BenchmarkEntry]
    │   │
    │   ├── extract_code_info(BenchmarkEntry)
    │   │   ├── 提取selected_region
    │   │   ├── 提取target_implementation
    │   │   └── reconstruct_full_code()
    │   │       └── 返回: CodeContext
    │   │
    │   ├── build_rc_prompt(CodeContext)
    │   │   ├── load_rc_prompt_template()
    │   │   ├── 填充代码信息
    │   │   └── 返回: RC生成prompt
    │   │
    │   ├── call_llm_api(prompt)
    │   │   └── GPT-4o/GPT-5 → RC响应
    │   │
    │   ├── parse_rc_response(response)
    │   │   ├── 提取diff块
    │   │   ├── 解析行号
    │   │   └── 返回: List[RecentChange]
    │   │
    │   └── build_final_prompt(context, recent_changes)
    │       └── 返回: 完整Benchmark prompt
```

**调用示例**:
```python
processor = EndToEndProcessor()

# 1. 加载数据
data = processor.load_benchmark_data()

# 2. 处理每条数据
for entry in data:
    # 提取代码信息
    code_info = processor.extract_code_info(entry)
    
    # 生成RC
    rc_prompt = processor.build_rc_prompt(code_info)
    rc_response = processor.call_llm_api(rc_prompt)
    recent_changes = processor.parse_rc_response(rc_response)
    
    # 构建最终prompt
    final_prompt = processor.build_final_prompt(
        code_info, recent_changes
    )
    
    # 保存结果
    processor.save_to_jsonl(final_prompt)
```

---

### 2.4 格式标准化模块

```
generate_separated_benchmark.py
    ├── split_context(prompt)
    │   ├── 查找"context above"标记
    │   ├── 查找"context below"标记
    │   └── 返回: (context_above, context_below)
    │
    ├── add_line_numbers(code_lines, start_line)
    │   ├── 遍历每行代码
    │   ├── 格式化为 "行号: 代码"
    │   └── 返回: List[numbered_line]
    │
    └── format_separated_benchmark(entry)
        ├── split_context()
        ├── add_line_numbers()
        ├── extract_recent_changes()
        └── 返回: Separated格式entry
```

---

### 2.5 RC修复模块

```
fix_rc_strict.py
    ├── RCFixer
    │   ├── extract_rc_blocks(prompt)
    │   │   ├── 正则匹配RC块
    │   │   └── 返回: List[RC块]
    │   │
    │   ├── parse_diff_lines(rc_content)
    │   │   ├── 解析@@头信息
    │   │   ├── 分类diff行 (+/-/空格)
    │   │   └── 返回: List[DiffLine]
    │   │
    │   ├── match_in_context(diff_line, context)
    │   │   ├── 标准化代码
    │   │   ├── 精确匹配
    │   │   ├── 模糊匹配 (相似度>40%)
    │   │   └── 返回: (line_num, original_content)
    │   │
    │   ├── sort_diff_lines(diff_lines)
    │   │   ├── 删除行排序
    │   │   ├── 添加行排序
    │   │   ├── 上下文行排序
    │   │   └── 返回: 排序后的diff_lines
    │   │
    │   └── format_as_unified_diff(diff_lines)
    │       ├── 生成@@头
    │       ├── 格式化每行
    │       └── 返回: 标准unified diff
```

**调用示例**:
```python
fixer = RCFixer()

# 1. 提取RC块
rc_blocks = fixer.extract_rc_blocks(prompt)

# 2. 处理每个RC块
for rc in rc_blocks:
    # 解析diff行
    diff_lines = fixer.parse_diff_lines(rc['content'])
    
    # 匹配context
    for diff_line in diff_lines:
        line_num, content = fixer.match_in_context(
            diff_line, context
        )
        diff_line.line_num = line_num
        diff_line.content = content
    
    # 排序和格式化
    sorted_lines = fixer.sort_diff_lines(diff_lines)
    formatted_diff = fixer.format_as_unified_diff(sorted_lines)
    
    # 更新RC块
    rc['content'] = formatted_diff
```

---

### 2.6 多版本生成模块

```
create_multi_rc_benchmarks.py
    ├── load_existing_data()
    │   ├── 读取3RC源文件
    │   ├── 读取2RC源文件
    │   └── 返回: List[BenchmarkEntry]
    │
    ├── extract_recent_changes(prompt)
    │   ├── 查找RC section
    │   ├── 正则提取每个RC
    │   ├── 按编号排序
    │   └── 返回: List[RecentChange]
    │
    ├── create_rc_version(entry, num_changes)
    │   ├── extract_recent_changes()
    │   ├── 选择前num_changes个RC
    │   ├── 重建RC section
    │   ├── 替换原prompt中的RC
    │   └── 返回: 新的BenchmarkEntry
    │
    └── main()
        ├── load_existing_data()
        ├── 对每条数据:
        │   ├── create_rc_version(entry, 3)
        │   ├── create_rc_version(entry, 2)
        │   └── create_rc_version(entry, 1)
        └── 保存到3个文件
```

**调用示例**:
```python
# 1. 加载数据
all_data = load_existing_data()

# 2. 生成多版本
for entry in all_data:
    # 提取RC
    changes = extract_recent_changes(entry['prompt'])
    
    # 生成3个版本
    entry_3rc = create_rc_version(entry, 3)  # RC1+RC2+RC3
    entry_2rc = create_rc_version(entry, 2)  # RC1+RC2
    entry_1rc = create_rc_version(entry, 1)  # RC1
    
    # 保存
    save_to_file(entry_3rc, '3RC.jsonl')
    save_to_file(entry_2rc, '2RC.jsonl')
    save_to_file(entry_1rc, '1RC.jsonl')
```

---

## 3. 数据转换流程

### 3.1 Zeta → Benchmark转换

```
Zeta原始数据
    ↓ parse_git_diff()
GitDiffRecord {
    old_file, new_file,
    old_hunk, new_hunk,
    review_line, ...
}
    ↓ infer_cursor_position()
(line_num, col_pos)
    ↓ extract_context()
CodeContext {
    context_above,
    context_below,
    selected_region
}
    ↓ build_recent_changes()
List[RecentChange]
    ↓ build_prompt()
BenchmarkEntry {
    prompt: "...",
    domain: "nl2code_java",
    id: "...",
    ...
}
```

---

### 3.2 原始格式 → Separated格式转换

```
原始Benchmark (混合context)
{
    prompt: "...context above and below mixed..."
}
    ↓ split_context()
{
    context_above: "...",
    context_below: "..."
}
    ↓ add_line_numbers()
{
    context_above: "  1: ...\n  2: ...",
    context_below: "101: ...\n102: ..."
}
    ↓ extract_recent_changes()
{
    recent_changes: [RC1, RC2, RC3]
}
    ↓ format_separated_benchmark()
Separated Benchmark
{
    prompt: "...properly formatted with line numbers..."
}
```

---

### 3.3 完整数据 → 多版本转换

```
完整Benchmark (3RC)
{
    prompt: "...RC1, RC2, RC3..."
}
    ↓ extract_recent_changes()
[
    {number: 1, content: "..."},
    {number: 2, content: "..."},
    {number: 3, content: "..."}
]
    ↓ create_rc_version(entry, 2)
2RC Benchmark
{
    prompt: "...RC1, RC2..."
}
    ↓ create_rc_version(entry, 1)
1RC Benchmark
{
    prompt: "...RC1..."
}
```

---

## 4. 关键函数调用链

### 4.1 完整处理链 (端到端)

```python
# 入口
run_end_to_end.py
    ↓
EndToEndProcessor.process()
    ↓
├─ load_benchmark_data()
│   └─ json.loads() × N条
│
├─ extract_code_info(entry)
│   ├─ re.search() 提取代码块
│   └─ reconstruct_full_code()
│
├─ build_rc_prompt(code_info)
│   ├─ load_rc_prompt_template()
│   └─ template.format(**code_info)
│
├─ call_llm_api(prompt)
│   └─ requests.post(GPT_API)
│
├─ parse_rc_response(response)
│   ├─ re.findall() 提取RC块
│   └─ parse_diff_content()
│
└─ save_to_jsonl(result)
    └─ json.dump()
```

---

### 4.2 RC修复链

```python
# 入口
fix_rc_strict.py
    ↓
RCFixer.fix_all_entries()
    ↓
├─ extract_rc_blocks(prompt)
│   └─ re.findall(r'### Recent Change \d+.*?```diff.*?```')
│
├─ parse_diff_lines(rc_content)
│   ├─ re.search(r'@@ -(\d+),(\d+) \+(\d+),(\d+) @@')
│   └─ classify_diff_lines()
│
├─ match_in_context(diff_line, context)
│   ├─ normalize_code()
│   ├─ exact_match()
│   └─ fuzzy_match() if needed
│
├─ sort_diff_lines(diff_lines)
│   ├─ sort(deletion_lines)
│   ├─ sort(addition_lines)
│   └─ sort(context_lines)
│
└─ format_as_unified_diff(sorted_lines)
    ├─ generate_header()
    └─ format_each_line()
```

---

### 4.3 多版本生成链

```python
# 入口
create_multi_rc_benchmarks.py
    ↓
main()
    ↓
├─ load_existing_data()
│   ├─ open('3RC.jsonl')
│   └─ json.loads() × 40条
│
├─ extract_recent_changes(prompt)
│   ├─ prompt.find('## Recent Changes Context')
│   ├─ re.findall(r'### Recent Change (\d+)(.*?)')
│   └─ sort(key=lambda x: x['number'])
│
├─ create_rc_version(entry, num_changes)
│   ├─ extract_recent_changes()
│   ├─ selected = changes[:num_changes]
│   ├─ rebuild_rc_section(selected)
│   └─ replace_in_prompt()
│
└─ save_to_file()
    ├─ open('1RC.jsonl', 'w')
    ├─ open('2RC.jsonl', 'w')
    └─ open('3RC.jsonl', 'w')
```

---

## 5. 数据流向追踪

### 5.1 从Zeta到Benchmark

```
HuggingFace: zed-industries/zeta
    ↓ download
zeta_full/*.md (原始Markdown文件)
    ↓ parse
zeta_exports/train.jsonl (结构化数据)
    ↓ data_processor.py
GitDiffRecord对象
    ↓ extract_context
CodeContext对象
    ↓ build_prompt
Benchmark JSONL
```

### 5.2 从原始到Separated

```
benchmark/nl2code_F*.jsonl (原始)
    ↓ generate_separated_benchmark.py
临时处理数据
    ↓ improve_line_numbers.py
行号对齐数据
    ↓ fix_rc_strict.py
benchmark/*_separated_final_fixed.jsonl (最终)
```

### 5.3 从完整到多版本

```
benchmark/nl2code_java_F20-40_with_rc_separated_final_fixed.jsonl (20条)
benchmark/nl2code_java_all_20_with_rc_separated_final.jsonl (20条)
    ↓ merge
40条完整数据
    ↓ create_multi_rc_benchmarks.py
benchmark/nl2code_java_complete_3RC.jsonl (40条)
benchmark/nl2code_java_complete_2RC.jsonl (40条)
benchmark/nl2code_java_complete_1RC.jsonl (40条)
```

---

## 6. 配置与依赖

### 6.1 配置文件

```python
# tools/config.py
INPUT_BENCHMARK_FILE = "benchmark/nl2code_F*.jsonl"
OUTPUT_DIR = "final_gpt4o_output_*/"
RC_PROMPT_TEMPLATE = "templates/RC_prompt_v9_improved.txt"
GPT_API_ENDPOINT = "..."
GPT_API_KEY = "..."
```

### 6.2 依赖关系

```
download_zeta_dataset.py
    ├─ huggingface_hub
    └─ datasets

data_processor.py
    ├─ difflib
    └─ ast

end_to_end_processor.py
    ├─ config.py
    └─ json

fix_rc_strict.py
    ├─ re
    └─ difflib

create_multi_rc_benchmarks.py
    ├─ json
    └─ re
```

---

## 7. 总结

### 核心数据流

```
原始数据源
    ↓ 下载/解析
结构化数据
    ↓ 上下文提取
代码上下文
    ↓ RC生成
Recent Changes
    ↓ Prompt构建
Benchmark数据
    ↓ 格式标准化
Separated格式
    ↓ 质量修复
高质量Benchmark
    ↓ 多版本生成
1RC/2RC/3RC版本
```

### 关键转换点

1. **Zeta → GitDiffRecord**: 原始数据解析
2. **GitDiffRecord → CodeContext**: 上下文提取
3. **CodeContext → RecentChanges**: RC生成
4. **RecentChanges → Prompt**: Benchmark构建
5. **Prompt → Separated**: 格式标准化
6. **Separated → Fixed**: 质量修复
7. **Fixed → Multi-version**: 多版本生成

### 数据质量保证

- **每个转换点都有验证**
- **关键步骤有备份**
- **完整的日志记录**
- **可追溯的处理链路**

