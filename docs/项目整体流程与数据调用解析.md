# InLineRCRepo 项目整体流程与数据调用解析

## 📋 项目概述

InLineRCRepo是一个**代码补全Benchmark构建与评测项目**，核心目标是通过引入**Recent Changes (RC)上下文**来增强InlineEdit代码生成质量。项目包含两大核心功能：

1. **Benchmark数据构建**：从原始Java代码生成包含RC上下文的训练/评测数据
2. **多版本RC数据生成**：创建1RC、2RC、3RC不同版本用于对比实验

---

## 🏗️ 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        数据源层                                   │
├─────────────────────────────────────────────────────────────────┤
│  • Zeta数据集 (HuggingFace)                                      │
│  • ShenYu开源项目代码                                             │
│  • 原始benchmark JSONL文件                                        │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      数据处理层                                   │
├─────────────────────────────────────────────────────────────────┤
│  • 数据下载与解析 (download_zeta_dataset.py)                     │
│  • Git Diff提取与分析 (data_processor.py)                        │
│  • 代码上下文构建 (end_to_end_processor.py)                       │
│  • Recent Changes生成 (GPT-4o/GPT-5)                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Benchmark构建层                                │
├─────────────────────────────────────────────────────────────────┤
│  • 格式标准化 (generate_separated_benchmark.py)                  │
│  • 行号对齐与验证 (improve_line_numbers.py)                       │
│  • Diff格式修复 (fix_rc_strict.py)                               │
│  • 质量验证 (validate_separated_benchmark.py)                    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    多版本生成层                                   │
├─────────────────────────────────────────────────────────────────┤
│  • 3RC版本 (完整RC上下文)                                         │
│  • 2RC版本 (RC1 + RC2)                                           │
│  • 1RC版本 (仅RC1)                                               │
│  → create_multi_rc_benchmarks.py                                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      输出层                                       │
├─────────────────────────────────────────────────────────────────┤
│  • benchmark/*.jsonl (标准JSONL格式)                             │
│  • final_gpt4o_output_*/ (GPT处理结果)                           │
│  • gpt5_results_*/ (GPT-5生成的RC)                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🔄 核心数据流

### 1️⃣ 数据获取阶段

#### 1.1 Zeta数据集下载
**脚本**: `edit_prediction/download_zeta_dataset.py`

```python
# 数据流向
HuggingFace (zed-industries/zeta)
    ↓ snapshot_download
zeta_full/ (完整数据集)
    ↓ load_dataset + export
zeta_exports/ (JSONL/Parquet格式)
    ├── train.jsonl (训练集)
    ├── eval.jsonl (评测集)
    └── dpo.jsonl (DPO数据)
```

**数据结构**:
```json
{
  "events": "...",           // 编辑事件序列
  "input": "...",            // 输入代码上下文
  "output": "...",           // 期望输出代码
  "labels": "...",           // 标签信息
  "assertions": "..."        // 断言信息
}
```

#### 1.2 原始Benchmark加载
**脚本**: `scripts/end_to_end_processor.py`

```python
# 数据流向
benchmark/nl2code_F*.jsonl (原始数据)
    ↓ load_benchmark_data()
List[Dict] (内存中的数据列表)
    ↓ extract_code_info()
代码信息字典 {
    'selected_region': "...",
    'target_implementation': "...",
    'final_code_with_annotations': "..."
}
```

---

### 2️⃣ 数据处理阶段

#### 2.1 Git Diff解析
**脚本**: `zeta_full/data_processor.py`

```python
# 核心类: GitDiffRecord
@dataclass
class GitDiffRecord:
    mrcr_url: str              # MR/CR链接
    file_path: str             # 文件路径
    code_type: str             # 代码语言
    old_file: str              # 修改前完整文件
    new_file: str              # 修改后完整文件
    old_hunk: str              # 修改前代码块
    new_hunk: str              # 修改后代码块
    old_commit_id: str         # 旧commit ID
    new_commit_id: str         # 新commit ID
    review_line: int           # Review行号
    review_message: str        # Review消息
    start_line: int            # 起始行
    end_line: int              # 结束行
    code_with_line: str        # 带行号的代码
```

**处理流程**:
```python
# 1. 光标位置推断
CursorPositionInferrer.infer_cursor_position()
    ↓ 分析diff类型 (deletion/modification/addition)
    ↓ 定位修改点
(line_num, col_pos)

# 2. 代码上下文提取
ContextExtractor.extract_context()
    ↓ 解析code_with_line
    ↓ 分割above/below context
{
    'context_above': "...",
    'context_below': "...",
    'selected_code': "..."
}

# 3. Recent Changes构建
RecentChangesBuilder.build_recent_changes()
    ↓ 提取git diff
    ↓ 格式化为unified diff
    ↓ 添加行号标注
"### Recent Change 1\n```diff\n@@ -10,3 +10,4 @@\n..."
```

#### 2.2 端到端处理
**脚本**: `scripts/end_to_end_processor.py`

```python
# 完整处理流程
class EndToEndProcessor:
    
    def process():
        # 1. 加载数据
        data = load_benchmark_data()
        
        # 2. 提取代码信息
        for item in data:
            code_info = extract_code_info(item)
            
            # 3. 构建RC prompt
            rc_prompt = build_rc_prompt(code_info)
            
            # 4. 调用LLM生成RC
            rc_result = call_llm_api(rc_prompt)
            
            # 5. 解析并验证RC
            recent_changes = parse_rc_response(rc_result)
            
            # 6. 构建最终prompt
            final_prompt = build_final_prompt(
                context_above,
                context_below,
                recent_changes,
                target_feature
            )
            
            # 7. 保存结果
            save_to_jsonl(final_prompt)
```

---

### 3️⃣ Benchmark构建阶段

#### 3.1 Separated格式生成
**脚本**: `scripts/generate_separated_benchmark.py`

```python
# 数据转换流程
原始格式 (混合context)
    ↓ split_context()
Separated格式 {
    "context_above": "带行号的上文代码",
    "context_below": "带行号的下文代码",
    "recent_changes": [RC1, RC2, RC3]
}
    ↓ format_with_line_numbers()
标准化格式 (行号对齐)
```

**行号处理**:
```python
def add_line_numbers(code_lines, start_line):
    """为代码添加行号"""
    numbered_lines = []
    for i, line in enumerate(code_lines):
        line_num = start_line + i
        # 格式: "  1: public class Foo {"
        numbered_lines.append(f"{line_num:3d}: {line}")
    return numbered_lines
```

#### 3.2 Recent Changes格式修复
**脚本**: `tools/fix_rc_strict.py`

```python
# RC修复流程
class RCFixer:
    
    def fix_recent_changes():
        # 1. 提取RC块
        rc_blocks = extract_rc_blocks(prompt)
        
        # 2. 解析diff内容
        for rc in rc_blocks:
            diff_lines = parse_diff(rc['content'])
            
            # 3. 匹配context代码
            for diff_line in diff_lines:
                matched_code = match_in_context(
                    diff_line.code,
                    context_above + context_below
                )
                
                # 4. 更新行号
                diff_line.line_num = matched_code.line_num
                
                # 5. 保留原始缩进
                diff_line.content = matched_code.content
            
            # 6. 排序diff行
            sorted_diff = sort_diff_lines(diff_lines)
            # 顺序: 删除行 → 添加行 → 上下文行
            
            # 7. 重新格式化
            formatted_rc = format_as_unified_diff(sorted_diff)
```

**Diff格式标准**:
```diff
### Recent Change 1
```diff
@@ -10,5 +10,6 @@
  10:     private static final Logger LOGGER = ...;
- 11:     // TODO: implement
+ 11:     private void processData() {
+ 12:         LOGGER.info("Processing...");
+ 13:     }
  14: }
```
```

#### 3.3 质量验证
**脚本**: `scripts/validate_separated_benchmark.py`

```python
# 验证检查项
def validate_benchmark(data):
    checks = {
        # 1. 结构完整性
        'has_prompt': check_field_exists('prompt'),
        'has_domain': check_field_exists('domain'),
        'has_id': check_field_exists('id'),
        'has_response': check_field_exists('good_example_response'),
        
        # 2. 行号一致性
        'line_numbers_continuous': check_line_numbers_continuous(),
        'line_numbers_match_context': check_line_numbers_match(),
        
        # 3. Diff格式正确性
        'diff_format_valid': check_diff_format(),
        'diff_order_correct': check_diff_order(),
        
        # 4. 代码完整性
        'code_snippet_complete': check_code_snippet(),
        'context_not_empty': check_context_exists(),
        
        # 5. RC质量
        'rc_count_valid': check_rc_count(),
        'rc_format_standard': check_rc_format()
    }
    
    return all(checks.values())
```

---

### 4️⃣ 多版本生成阶段

#### 4.1 RC版本创建
**脚本**: `create_multi_rc_benchmarks.py`

```python
# 多版本生成流程
def create_multi_versions():
    # 1. 加载完整数据 (40条)
    all_data = load_existing_data()
    
    # 2. 提取RC信息
    for entry in all_data:
        changes = extract_recent_changes(entry['prompt'])
        # changes = [RC1, RC2, RC3] (按优先级排序)
        
        # 3. 生成3个版本
        entry_3rc = create_rc_version(entry, num_changes=3)
        entry_2rc = create_rc_version(entry, num_changes=2)
        entry_1rc = create_rc_version(entry, num_changes=1)
        
        # 4. 保存到不同文件
        save_to_file(entry_3rc, '3RC.jsonl')
        save_to_file(entry_2rc, '2RC.jsonl')
        save_to_file(entry_1rc, '1RC.jsonl')
```

**RC优先级策略**:
```python
# RC优先级: rc1 > rc2 > rc3
# rc1: 最近的准备工作 (Latest preparation)
# rc2: 中间的准备工作 (Intermediate preparation)
# rc3: 最早的准备工作 (Earliest preparation)

def select_rc_by_priority(changes, num_changes):
    """选择高优先级的RC"""
    # 按编号排序 (1, 2, 3)
    changes.sort(key=lambda x: x['number'])
    
    # 选择前num_changes个
    selected = changes[:num_changes]
    
    return selected
```

---

## 📊 数据结构详解

### Benchmark数据格式

```json
{
  "prompt": "完整的prompt文本，包含:\n- 外部类信息\n- context above\n- context below\n- Recent Changes\n- 目标功能描述\n- 代码片段",
  
  "domain": "nl2code_java",
  
  "id": "AdminCtrlService_z00806805#106",
  
  "good_example_response": "```java\n期望的代码实现\n```",
  
  "reward_command": "mvn test命令",
  
  "extra_content": {
    "query": "功能描述",
    "diff_path": "diff文件路径",
    "test_result": "pass/fail",
    "file_path": "源文件路径",
    "start_line": 121,
    "end_line": 137,
    "work_dir": "工作目录"
  }
}
```

### Prompt结构

```
A user is developing a new feature...

Below are some information from external classes:
```java
[外部类方法签名]
```

The context above is:
```java
  1: public class Foo {
  2:     private static final Logger LOGGER = ...;
  ...
```

The context below is:
```java
101:     public void bar() {
102:         ...
```

## Recent Changes Context
Here are some recent changes...

### Recent Change 3 (Earliest preparation work)
```diff
@@ -2,5 +2,0 @@
   2: public class Foo {
-  3: // TODO
+  3: private static final Logger LOGGER = ...;
```

### Recent Change 2 (Intermediate preparation)
...

### Recent Change 1 (Latest preparation work)
...

These recent changes show the development progression...

The new feature is [功能描述].

And here is the code snippet you are asked to modify:
```java
public void newMethod() {
```

Please analyze the mission carefully...
```

---

## 🔧 关键工具与脚本

### 1. 数据下载
- `edit_prediction/download_zeta_dataset.py`: 下载Zeta数据集

### 2. 数据处理
- `zeta_full/data_processor.py`: Git Diff解析和处理
- `scripts/end_to_end_processor.py`: 端到端自动化处理

### 3. Benchmark构建
- `scripts/generate_separated_benchmark.py`: 生成separated格式
- `scripts/improve_line_numbers.py`: 行号改进
- `tools/fix_rc_strict.py`: RC格式修复

### 4. 质量保证
- `scripts/validate_separated_benchmark.py`: 质量验证
- `validate_final.py`: 最终验证
- `final_check.py`: 完整检查

### 5. 多版本生成
- `create_multi_rc_benchmarks.py`: 创建1RC/2RC/3RC版本

---

## 📈 数据统计

### 当前数据规模
- **总数据量**: 40条高质量benchmark
- **数据分布**:
  - F1-10: 10条
  - F11-20: 10条
  - F21-40: 20条

### RC统计
- **3RC版本**: 40条 (每条3个RC)
- **2RC版本**: 40条 (每条2个RC)
- **1RC版本**: 40条 (每条1个RC)
- **特殊情况**: 4条数据RC不足，保持原样

### 质量指标
- **处理成功率**: 100%
- **格式一致性**: 100%
- **行号准确性**: 100%
- **Diff格式正确性**: 100%

---

## 🎯 使用场景

### 场景1: 处理新的benchmark数据
```bash
python scripts/run_end_to_end.py benchmark/nl2code_F40-60.jsonl 40-60
```

### 场景2: 生成多版本RC数据
```bash
python create_multi_rc_benchmarks.py
```

### 场景3: 修复RC格式
```bash
python tools/fix_rc_strict.py
```

### 场景4: 验证数据质量
```bash
python scripts/validate_separated_benchmark.py
```

---

## 🔍 调试与问题排查

### 常见问题

1. **行号不对齐**
   - 检查: `improve_line_numbers.py`
   - 验证: `validate_separated_benchmark.py`

2. **Diff格式错误**
   - 修复: `fix_rc_strict.py`
   - 标准: 删除行 → 添加行 → 上下文行

3. **代码片段不完整**
   - 检查: `extract_code_info()` 函数
   - 确保使用正确的marker定位

4. **缩进丢失**
   - 原因: 字符串处理破坏缩进
   - 解决: 从context获取原始内容

---

## 📚 相关文档

- [快速开始指南](QUICK_START.md)
- [详细指令文档](instruction.md)
- [修复流程指南](process.md)
- [技术方案](InlineEdit_Recent_Changes_Technical_Proposal.md)

