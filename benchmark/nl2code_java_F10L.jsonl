{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\n@Slf4j\npublic class ClassLoaderUtils {\n    private ClassLoaderUtils() {\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static URL[] getURLs(ClassLoader classLoader) {\n        if (classLoader instanceof URLClassLoader) {\n            return ((URLClassLoader) classLoader).getURLs();\n        }\n        try {\n            Field ucpField = classLoader.getClass().getDeclaredField(\"ucp\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                ucpField.setAccessible(true);\n                return null;\n            });\n            Object ucp = ucpField.get(classLoader);\n            Field pathField = ucp.getClass().getDeclaredField(\"path\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                pathField.setAccessible(true);\n                return null;\n            });\n            ArrayList<URL> path = (ArrayList<URL>) pathField.get(ucp);\n            return path.toArray(new URL[0]);\n        } catch (Exception e) {\n            throw new DevsporeCicException(e);\n        }\n    }\n```\n\nThe context below is:\n```java\n\n    public static boolean isBootstrapClassLoader(String className) {\n        try {\n            Class<?> langClass = Class.forName(className);\n            return langClass.getClassLoader() == null;\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n        return false;\n    }\n\n    public static URL[] getExtensionClassLoaderUrls() {\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        ClassLoader extensionClassLoader = systemClassLoader.getParent();\n\n        if (extensionClassLoader instanceof URLClassLoader) {\n            URLClassLoader urlClassLoader = (URLClassLoader) extensionClassLoader;\n            return urlClassLoader.getURLs();\n        }\n        return null;\n    }\n\n    /**\n     * 动态加载类并执行指定方法\n     *\n     * @param loader 类加载器\n     * @param className 完整类名（如 \"com.example.Plugin\"）\n     * @param methodName 方法名（如 \"run\"）\n     * @param parameterTypes 方法参数类型数组（无参数传 null）\n     * @param args 方法参数值数组（无参数传 null）\n     * @return 方法执行结果（无返回值方法返回 null）\n     * @throws Exception 封装所有可能的反射异常\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName,\n        Class<?>[] parameterTypes, Object[] args, Class<T> returnType) throws Exception {\n\n        // 1. 加载目标类\n        Class<?> clazz = loader.loadClass(className);\n\n        // 2. 实例化对象（使用无参构造函数）\n        Constructor<?> constructor = clazz.getDeclaredConstructor();\n        constructor.setAccessible(true); // 允许调用私有构造方法\n        Object instance = constructor.newInstance();\n\n        // 3. 获取并执行方法\n        Method method = clazz.getMethod(methodName, parameterTypes);\n\n        // 判断是否为静态方法\n        if (Modifier.isStatic(method.getModifiers())) {\n            return returnType.cast(method.invoke(null, args));// 静态方法无需实例\n        } else {\n            // 非静态方法\n            return returnType.cast(method.invoke(instance, args));\n        }\n    }\n\n    /**\n     * 重载方法：简化无参方法的调用\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName, Class<T> returnType)\n        throws Exception {\n        Object result = loadAndInvoke(loader, className, methodName, null, null, returnType);\n        return returnType.cast(result);\n    }\n}\n```\n\nThe new feature is 使用系统的Application ClassLoader来加载一个指定的类.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\npublic static void loadClassWithApplicationLoader(String className)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "devspore-cic_30036124#4", "good_example_response": "```java\n    public static void loadClassWithApplicationLoader(String className) {\n        try {\n            ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();\n            log.info(\"Application ClassLoader: {}\", appClassLoader);\n\n            Class<?> loadedClass = appClassLoader.loadClass(className);\n            log.info(\"Loaded Class: {}\", loadedClass.getName());\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n    }```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352  &&  export PATH=$JAVA_HOME/bin:$PATH && mvn -Dmaven.test.failure.ignore=true -f /docker/JavaRunProject/devspore-cic_30036124/devspore-cic-core/pom.xml -Dtest=com.huaweicloud.devspore.cic.core.utils.ClassLoaderUtilsTest#testLoadClassWithApplicationLoader clean test", "extra_content": {"query": "使用系统的Application ClassLoader来加载一个指定的类", "diff_path": "/docker/JavaRunProject/devspore-cic_30036124/diff/4.patch", "test_result": "fail", "file_path": "/devspore-cic-core/src/main/java/com/huaweicloud/devspore/cic/core/utils/ClassLoaderUtils.java", "start_line": 53, "end_line": 63, "work_dir": "/docker/JavaRunProject/devspore-cic_30036124/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\npublic class RedisRecoveryTimer {\n    public static void markRedisRecovery(); /* 提供外部使用接口，标记redis已恢复，监控组件尝试重启工厂以达到恢复连接的效果 */\n    public static void addInstance(WrappedRedisConnectionFactory factory, RedisMessageListenerContainer container); /* 添加待监控的连接工厂和redis消息监听容器,将其维护到监控集合 */\n}\n```\n\nThe context above is:\n```java\n@Slf4j\npublic class RedisConnectFactoryBuilder {\n    /**\n     * redis模式——standalone\n     */\n    public static final String REDIS_MODE_STANDALONE = \"standalone\";\n\n    /**\n     * redis模式——cluster\n     */\n    public static final String REDIS_MODE_CLUSTER = \"cluster\";\n\n    /**\n     * redis模式——sentinel\n     */\n    public static final String REDIS_MODE_SENTINEL = \"sentinel\";\n\n    /**\n     * redis客户端类型——jedis\n     */\n    public static final String REDIS_CLIENT_TYPE_JEDIS = \"jedis\";\n\n    /**\n     * redis客户端类型——lettuce\n     */\n    public static final String REDIS_CLIENT_TYPE_LETTUCE = \"lettuce\";\n\n    private RedisConnectFactoryBuilder() {\n    }\n\n    /**\n     * 根据config构建响应的redis连接工厂\n     *\n     * @param redisConfig redis配置项\n     * @return redis连接工厂\n     */\n    public static RedisConnectionFactory build(JinCacheRedisConfiguration redisConfig) {\n        return switch (redisConfig.getClientType()) {\n            case REDIS_CLIENT_TYPE_JEDIS -> buildJedisConnectFactory(redisConfig);\n            case REDIS_CLIENT_TYPE_LETTUCE -> buildLettuceConnectFactory(redisConfig);\n            default ->\n                throw new JinCacheException(String.format(\"not supported client type %s\", redisConfig.getClientType()));\n        };\n    }\n\n    private static JedisConnectionFactory buildJedisConnectFactory(JinCacheRedisConfiguration redisConfig) {\n        JedisClientConfiguration clientConfiguration = JedisClientConfiguration.builder()\n            .connectTimeout(redisConfig.getConnectTimeout())\n            .readTimeout(redisConfig.getReadTimeout())\n            .usePooling()\n            .poolConfig(redisConfig.getPool())\n            .build();\n        switch (redisConfig.getRedisMode()) {\n            case REDIS_MODE_STANDALONE -> {\n                RedisStandaloneConfiguration standaloneConfiguration =\n                    createStandaloneConfiguration(redisConfig, redisConfig.getHosts());\n                return new JedisConnectionFactory(standaloneConfiguration, clientConfiguration);\n            }\n            case REDIS_MODE_CLUSTER -> {\n                RedisClusterConfiguration clusterConfiguration = createClusterConfiguration(redisConfig);\n                return new JedisConnectionFactory(clusterConfiguration, clientConfiguration);\n            }\n            case REDIS_MODE_SENTINEL -> {\n                RedisSentinelConfiguration sentinelConfiguration = createSentinelConfiguration(redisConfig);\n                return new JedisConnectionFactory(sentinelConfiguration, clientConfiguration);\n            }\n            default ->\n                throw new JinCacheException(String.format(\"not supported redis mode %s\", redisConfig.getRedisMode()));\n        }\n    }\n```\n\nThe context below is:\n```java\n\n    private static RedisStandaloneConfiguration createStandaloneConfiguration(JinCacheRedisConfiguration redisConfig,\n        String host) {\n        RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration();\n        configuration.setPassword(redisConfig.getPassword());\n        String[] items = host.trim().split(\":\");\n        configuration.setHostName(items[0].trim());\n        configuration.setPort(Integer.parseInt(items[1].trim()));\n        configuration.setDatabase(redisConfig.getDatabase());\n        return configuration;\n    }\n\n    private static RedisClusterConfiguration createClusterConfiguration(JinCacheRedisConfiguration redisConfig) {\n        RedisClusterConfiguration configuration = new RedisClusterConfiguration();\n        List<RedisNode> redisNodes = Arrays.stream(redisConfig.getHosts().split(\",\")).map(host -> {\n            String[] items = host.split(\":\");\n            return new RedisNode(items[0], Integer.parseInt(items[1]));\n        }).collect(Collectors.toList());\n        configuration.setMaxRedirects(redisConfig.getMaxRedirects());\n        configuration.setClusterNodes(redisNodes);\n        configuration.setPassword(redisConfig.getPassword());\n        return configuration;\n    }\n\n    private static RedisSentinelConfiguration createSentinelConfiguration(JinCacheRedisConfiguration redisConfig) {\n        Set<String> sentinelHostAndPorts = Arrays.stream(redisConfig.getHosts().split(\",\")).collect(Collectors.toSet());\n        RedisSentinelConfiguration configuration =\n            new RedisSentinelConfiguration(redisConfig.getMasterName(), sentinelHostAndPorts);\n        configuration.setPassword(redisConfig.getPassword());\n        return configuration;\n    }\n}\n```\n\nThe new feature is 根据JinCacheRedisConfiguration创建RedisClusterConfiguration，并生成JedisConnectionFactory.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\nprivate static LettuceConnectionFactory buildLettuceConnectFactory(JinCacheRedisConfiguration redisConfig)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "DevUC-common_x00636091#6", "good_example_response": "```java\n    public static RedisConnectionFactory build(JinCacheRedisConfiguration redisConfig) {\n        return switch (redisConfig.getClientType()) {\n            case REDIS_CLIENT_TYPE_JEDIS -> buildJedisConnectFactory(redisConfig);\n            case REDIS_CLIENT_TYPE_LETTUCE -> buildLettuceConnectFactory(redisConfig);\n            default ->\n                throw new JinCacheException(String.format(\"not supported client type %s\", redisConfig.getClientType()));\n        };\n    }```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk-17.0.6 && export PATH=$JAVA_HOME/bin:$PATH && mvn clean test -pl jin-cache", "extra_content": {"query": "根据JinCacheRedisConfiguration创建RedisClusterConfiguration，并生成JedisConnectionFactory", "diff_path": "/docker/JavaRunProject/DevUC-common_x00636091/diff/6.patch", "test_result": "pass", "file_path": "/jin-cache/src/main/java/com/huawei/coral/cache/redis/connection/RedisConnectFactoryBuilder.java", "start_line": 75, "end_line": 82, "work_dir": "/docker/JavaRunProject/DevUC-common_x00636091/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\n@ConditionalOnProperty(prefix = \"apitest.dynamicglobalvariable\", name = \"storage\", havingValue = \"redis\")\n@Service\npublic class RedisDynamicGlobalVariableService implements DynamicGlobalVariableService {\n\n    private int ttlSeconds = 86400;\n\n    @Value(\"${envcommunication.amountLimitPerTask:100}\")\n    private int amountLimitPerTask;\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    private String keyPrefix = \"APITestExecuteDaemonService::dynamic-global-variable::\";\n```\n\nThe context below is:\n```java\n\n    @Override\n    public void put(String taskId, String key, String value) {\n        BoundHashOperations<String, String, String> boundHashOperations = redisTemplate.boundHashOps(prefix(taskId));\n        if (boundHashOperations.get(key) == null && boundHashOperations.size() >= amountLimitPerTask) {\n            throwLimitExceedException(amountLimitPerTask);\n        }\n        boundHashOperations.put(key, value);\n        boundHashOperations.expire(Duration.ofSeconds(ttlSeconds));\n    }\n\n    @Override\n    public long remove(String taskId, String key) {\n        Long ret = redisTemplate.boundHashOps(prefix(taskId)).delete(key);\n        if (ret == null) {\n            return 0;\n        }\n        return ret;\n    }\n\n    @Override\n    public void removeAll(String taskId) {\n        redisTemplate.delete(prefix(taskId));\n    }\n\n    @Override\n    public Map<String, String> listAll(String taskId) {\n        Map<String, String> valMap = new HashMap<>();\n        // 分页获取所有动态变量, 当数据量较大时, 按照20对K-V为一组分批次获取\n        try (Cursor<Map.Entry<Object, Object>> cursor = redisTemplate.opsForHash()\n                .scan(prefix(taskId), ScanOptions.scanOptions().count(20).build())) {\n            while (cursor.hasNext()) {\n                addToValMap(valMap, cursor.next());\n            }\n            return valMap;\n        }\n    }\n\n    /**\n     * 添加元素至Map\n     */\n    public void addToValMap(Map<String, String> valMap, Map.Entry<Object, Object> entry) {\n        String key = entry.getKey() == null ? \"\" : entry.getKey().toString();\n        String value = entry.getValue() == null ? \"\" : entry.getValue().toString();\n        valMap.put(key, value);\n    }\n\n    private String prefix(String taskId) {\n        return keyPrefix + taskId;\n    }\n}\n```\n\nThe new feature is 使用RedisTemplate实现taskid前缀的hash查询.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\npublic String get(String taskId, String key)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "APITestDesign-l00617778#10", "good_example_response": "```java\n    public String get(String taskId, String key) {\n        BoundHashOperations<String, String, String> boundHashOperations = redisTemplate.boundHashOps(prefix(taskId));\n        return boundHashOperations.get(key);\n    }\n```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk-17.0.6   &&  export PATH=$JAVA_HOME/bin:$PATH && mvn -Dmaven.test.failure.ignore=true -Dtest=com/huawei/cloudtest/apitest/executedaemonservice/webcommon/dynamicglobalvariable/controller/DynamicGlobalVariableControllerTest.java#testGetKeyNotExist -Dsurefire.failIfNoSpecifiedTests=false clean test", "extra_content": {"query": "使用RedisTemplate实现taskid前缀的hash查询", "diff_path": "/docker/JavaRunProject/APITestDesign-l00617778/diff/10.patch", "test_result": "pass", "file_path": "/dynamic-global-variable/src/main/java/com/huawei/cloudtest/apitest/executedaemonservice/webcommon/dynamicglobalvariable/service/RedisDynamicGlobalVariableService.java", "start_line": 39, "end_line": 43, "work_dir": "/docker/JavaRunProject/APITestDesign-l00617778/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\n@Slf4j\npublic class ClassLoaderUtils {\n    private ClassLoaderUtils() {\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static URL[] getURLs(ClassLoader classLoader) {\n        if (classLoader instanceof URLClassLoader) {\n            return ((URLClassLoader) classLoader).getURLs();\n        }\n        try {\n            Field ucpField = classLoader.getClass().getDeclaredField(\"ucp\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                ucpField.setAccessible(true);\n                return null;\n            });\n            Object ucp = ucpField.get(classLoader);\n            Field pathField = ucp.getClass().getDeclaredField(\"path\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                pathField.setAccessible(true);\n                return null;\n            });\n            ArrayList<URL> path = (ArrayList<URL>) pathField.get(ucp);\n            return path.toArray(new URL[0]);\n        } catch (Exception e) {\n            throw new DevsporeCicException(e);\n        }\n    }\n\n    public static void loadClassWithApplicationLoader(String className) {\n        try {\n            ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();\n            log.info(\"Application ClassLoader: {}\", appClassLoader);\n\n            Class<?> loadedClass = appClassLoader.loadClass(className);\n            log.info(\"Loaded Class: {}\", loadedClass.getName());\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n    }\n```\n\nThe context below is:\n```java\n\n    public static URL[] getExtensionClassLoaderUrls() {\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        ClassLoader extensionClassLoader = systemClassLoader.getParent();\n\n        if (extensionClassLoader instanceof URLClassLoader) {\n            URLClassLoader urlClassLoader = (URLClassLoader) extensionClassLoader;\n            return urlClassLoader.getURLs();\n        }\n        return null;\n    }\n\n    /**\n     * 动态加载类并执行指定方法\n     *\n     * @param loader 类加载器\n     * @param className 完整类名（如 \"com.example.Plugin\"）\n     * @param methodName 方法名（如 \"run\"）\n     * @param parameterTypes 方法参数类型数组（无参数传 null）\n     * @param args 方法参数值数组（无参数传 null）\n     * @return 方法执行结果（无返回值方法返回 null）\n     * @throws Exception 封装所有可能的反射异常\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName,\n        Class<?>[] parameterTypes, Object[] args, Class<T> returnType) throws Exception {\n\n        // 1. 加载目标类\n        Class<?> clazz = loader.loadClass(className);\n\n        // 2. 实例化对象（使用无参构造函数）\n        Constructor<?> constructor = clazz.getDeclaredConstructor();\n        constructor.setAccessible(true); // 允许调用私有构造方法\n        Object instance = constructor.newInstance();\n\n        // 3. 获取并执行方法\n        Method method = clazz.getMethod(methodName, parameterTypes);\n\n        // 判断是否为静态方法\n        if (Modifier.isStatic(method.getModifiers())) {\n            return returnType.cast(method.invoke(null, args));// 静态方法无需实例\n        } else {\n            // 非静态方法\n            return returnType.cast(method.invoke(instance, args));\n        }\n    }\n\n    /**\n     * 重载方法：简化无参方法的调用\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName, Class<T> returnType)\n        throws Exception {\n        Object result = loadAndInvoke(loader, className, methodName, null, null, returnType);\n        return returnType.cast(result);\n    }\n}\n```\n\nThe new feature is 判断给定类是否为Bootstrap ClassLoader.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\npublic static boolean isBootstrapClassLoader(String className)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "devspore-cic_30036124#21", "good_example_response": "```java\n    public static boolean isBootstrapClassLoader(String className) {\n        try {\n            Class<?> langClass = Class.forName(className);\n            return langClass.getClassLoader() == null;\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n        return false;\n    }```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352  &&  export PATH=$JAVA_HOME/bin:$PATH && mvn -Dmaven.test.failure.ignore=true -f /docker/JavaRunProject/devspore-cic_30036124/devspore-cic-core/pom.xml -Dtest=com.huaweicloud.devspore.cic.core.utils.ClassLoaderUtilsTest#testIsBootstrapClassLoader clean test", "extra_content": {"query": "判断给定类是否为Bootstrap ClassLoader", "diff_path": "/docker/JavaRunProject/devspore-cic_30036124/diff/21.patch", "test_result": "pass", "file_path": "/devspore-cic-core/src/main/java/com/huaweicloud/devspore/cic/core/utils/ClassLoaderUtils.java", "start_line": 65, "end_line": 73, "work_dir": "/docker/JavaRunProject/devspore-cic_30036124/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\n@Slf4j\npublic class ClassLoaderUtils {\n    private ClassLoaderUtils() {\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static URL[] getURLs(ClassLoader classLoader) {\n        if (classLoader instanceof URLClassLoader) {\n            return ((URLClassLoader) classLoader).getURLs();\n        }\n        try {\n            Field ucpField = classLoader.getClass().getDeclaredField(\"ucp\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                ucpField.setAccessible(true);\n                return null;\n            });\n            Object ucp = ucpField.get(classLoader);\n            Field pathField = ucp.getClass().getDeclaredField(\"path\");\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                pathField.setAccessible(true);\n                return null;\n            });\n            ArrayList<URL> path = (ArrayList<URL>) pathField.get(ucp);\n            return path.toArray(new URL[0]);\n        } catch (Exception e) {\n            throw new DevsporeCicException(e);\n        }\n    }\n\n    public static void loadClassWithApplicationLoader(String className) {\n        try {\n            ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();\n            log.info(\"Application ClassLoader: {}\", appClassLoader);\n\n            Class<?> loadedClass = appClassLoader.loadClass(className);\n            log.info(\"Loaded Class: {}\", loadedClass.getName());\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n    }\n\n    public static boolean isBootstrapClassLoader(String className) {\n        try {\n            Class<?> langClass = Class.forName(className);\n            return langClass.getClassLoader() == null;\n        } catch (ClassNotFoundException e) {\n            log.error(\"load error: {}\", e.getMessage());\n        }\n        return false;\n    }\n```\n\nThe context below is:\n```java\n\n    /**\n     * 动态加载类并执行指定方法\n     *\n     * @param loader 类加载器\n     * @param className 完整类名（如 \"com.example.Plugin\"）\n     * @param methodName 方法名（如 \"run\"）\n     * @param parameterTypes 方法参数类型数组（无参数传 null）\n     * @param args 方法参数值数组（无参数传 null）\n     * @return 方法执行结果（无返回值方法返回 null）\n     * @throws Exception 封装所有可能的反射异常\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName,\n        Class<?>[] parameterTypes, Object[] args, Class<T> returnType) throws Exception {\n\n        // 1. 加载目标类\n        Class<?> clazz = loader.loadClass(className);\n\n        // 2. 实例化对象（使用无参构造函数）\n        Constructor<?> constructor = clazz.getDeclaredConstructor();\n        constructor.setAccessible(true); // 允许调用私有构造方法\n        Object instance = constructor.newInstance();\n\n        // 3. 获取并执行方法\n        Method method = clazz.getMethod(methodName, parameterTypes);\n\n        // 判断是否为静态方法\n        if (Modifier.isStatic(method.getModifiers())) {\n            return returnType.cast(method.invoke(null, args));// 静态方法无需实例\n        } else {\n            // 非静态方法\n            return returnType.cast(method.invoke(instance, args));\n        }\n    }\n\n    /**\n     * 重载方法：简化无参方法的调用\n     */\n    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName, Class<T> returnType)\n        throws Exception {\n        Object result = loadAndInvoke(loader, className, methodName, null, null, returnType);\n        return returnType.cast(result);\n    }\n}\n```\n\nThe new feature is 获取Extension ClassLoader加载路径.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\npublic static URL[] getExtensionClassLoaderUrls()\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "devspore-cic_30036124#22", "good_example_response": "```java\n    public static URL[] getExtensionClassLoaderUrls() {\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        ClassLoader extensionClassLoader = systemClassLoader.getParent();\n\n        if (extensionClassLoader instanceof URLClassLoader) {\n            URLClassLoader urlClassLoader = (URLClassLoader) extensionClassLoader;\n            return urlClassLoader.getURLs();\n        }\n        return null;\n    }```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352  &&  export PATH=$JAVA_HOME/bin:$PATH && mvn -Dmaven.test.failure.ignore=true -f /docker/JavaRunProject/devspore-cic_30036124/devspore-cic-core/pom.xml -Dtest=com.huaweicloud.devspore.cic.core.utils.ClassLoaderUtilsTest#testGetExtensionClassLoaderUrls clean test", "extra_content": {"query": "获取Extension ClassLoader加载路径", "diff_path": "/docker/JavaRunProject/devspore-cic_30036124/diff/22.patch", "test_result": "pass", "file_path": "/devspore-cic-core/src/main/java/com/huaweicloud/devspore/cic/core/utils/ClassLoaderUtils.java", "start_line": 75, "end_line": 84, "work_dir": "/docker/JavaRunProject/devspore-cic_30036124/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\npublic class StringUtils {\n    public static final String LF;\n    public static final String EMPTY;\n    public static final String COMMA;\n    public static final String DOT;\n    public static String capitalize(String str); /* Capitalize a {@code String}, changing the first letter to upper case as per {@link Character#toUpperCase(char)}. No other letters are changed. */\n    public static String getFilename(String path); /* Extract the filename from the given Java resource path, e.g. {@code \"mypath/myfile.txt\" &rarr; \"myfile.txt\"}. */\n    public static String applyRelativePath(String path, String relativePath); /* Apply the given relative path to the given Java resource path, assuming standard Java folder separation (i.e. \"/\" separators). */\n    public static String replace(String inString, String oldPattern, String newPattern); /* Replace all occurrences of a substring within a string with another string. */\n    public static String deleteAny(String inString, String charsToDelete); /* Delete any character in a given {@code String}. */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete); /* Take a {@code String} that is a delimited list and convert it into a {@code String} array. <p>A single {@code delimiter} may consist of more than one character, but it will still be considered as a single delimiter string, rather than as bunch of potential delimiter characters, in contrast to {@link #tokenizeToStringArray}. delimiter characters) delete all new lines and line feeds in a {@code String} */\n    public static String[] delimitedListToStringArray(String str, String delimiter); /* Take a {@code String} that is a delimited list and convert it into a {@code String} array. <p>A single {@code delimiter} may consist of more than one character, but it will still be considered as a single delimiter string, rather than as bunch of potential delimiter characters, in contrast to {@link #tokenizeToStringArray}. delimiter characters) */\n    public static boolean hasLength(String str); /* Check that the given {@code String} is neither {@code null} nor of length 0. <p>Note: this method returns {@code true} for a {@code String} that purely consists of whitespace. */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix); /* Convert a {@link Collection} to a delimited {@code String} (e.g. CSV). <p>Useful for {@code toString()} implementations. */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim); /* Convert a {@code Collection} into a delimited {@code String} (e.g. CSV). <p>Useful for {@code toString()} implementations. */\n    public static String cleanPath(String path); /* Normalize the path by suppressing sequences like \"path/..\" and inner simple dots. <p>The result is convenient for path comparison. For other uses, notice that Windows separators (\"\\\") are replaced by simple slashes. <p><strong>NOTE</strong> that {@code cleanPath} should not be depended upon in a security context. Other mechanisms should be used to prevent path-traversal issues. */\n    public static boolean hasText(String str); /* Check whether the given {@code String} contains actual <em>text</em>. <p>More specifically, this method returns {@code true} if the {@code String} is not {@code null}, its length is greater than 0, and it contains at least one non-whitespace character. contain whitespace only */\n    public static String[] toStringArray(Collection<String> collection); /* Copy the given {@link Collection} into a {@code String} array. <p>The {@code Collection} must contain {@code String} elements only. */\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens,\n            boolean ignoreEmptyTokens); /* Tokenize the given {@code String} into a {@code String} array via a {@link StringTokenizer}. <p>The given {@code delimiters} string can consist of any number of delimiter characters. Each of those characters can be used to separate tokens. A delimiter is always a single character; individually considered as a delimiter) trimming; StringTokenizer will not consider subsequent delimiters as token in the first place). */\n    public static boolean equalsIgnoreCase(String str1, String str2); /* <p>Compares two CharSequences, returning {@code true} if they represent equal sequences of characters, ignoring case.</p> */\n    public static String deleteWhitespace(String str); /* <p>Deletes all whitespaces from a String as defined by {@link Character#isWhitespace(char)}.</p> */\n    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix); /* <p>Case insensitive check if a CharSequence starts with a specified prefix.</p> <p>{@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The comparison is case insensitive.</p> */\n    public static boolean startsWith(final CharSequence str, final CharSequence prefix); /* <p>Check if a CharSequence starts with a specified prefix.</p> <p>{@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The comparison is case sensitive.</p> */\n    public static boolean isAnyBlank(final CharSequence... css); /* <p>Checks if any one of the CharSequences are blank (\"\") or null and not whitespace only..</p> */\n    public static boolean isNoneBlank(final CharSequence... css); /* <p>Checks if none of the CharSequences are blank (\"\") or null and whitespace only..</p> */\n    public static boolean contains(final CharSequence str, final CharSequence searchStr); /* Checks if CharSequence contains a search CharSequence. */\n    public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr); /* Checks if CharSequence contains a search CharSequence irrespective of case, handling {@code null}. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. <p>A {@code null} CharSequence will return {@code false}.</p> null} string input */\n    public static String escapeJavaScript(String str);\n    public static String join(Collection collection, String separator); /* <p>Joins the elements of the provided array into a single String containing the provided list of elements.</p> */\n    public static String substringBetween(String str, String open, String close); /* Substring between two index. */\n    public static String trim(final String str); /* <p>Removes control characters (char &lt;= 32) from both ends of this String, handling {@code null} by returning {@code null}.</p> */\n    public static boolean equals(String str1, String str2); /* <p>Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.</p> */\n    public static String defaultIfEmpty(String str, String defaultStr); /* <p>Returns either the passed in CharSequence, or if the CharSequence is empty or {@code null}, the value of {@code defaultStr}.</p> */\n    public static boolean isEmpty(String str); /* <p>Checks if a str is empty (\"\") or null.</p> */\n    public static boolean isNotEmpty(String str); /* <p>Checks if a str is not empty (\"\") or not null.</p> */\n    public static boolean isNotBlank(String str); /* <p>Checks if a string is not empty (\"\"), not null and not whitespace only.</p> */\n    public static boolean isBlank(final CharSequence cs); /* <p>Checks if a string is  empty (\"\"), null and  whitespace only.</p> */\n    public static String newStringForUtf8(byte[] bytes); /* <p>Create a string with encoding format as utf8.</p> */\n}\n\npublic class NacosUser {\n    public void setGlobalAdmin(boolean globalAdmin);\n    public boolean isGlobalAdmin();\n    public void setToken(String token);\n    public String getToken();\n}\n\npublic final class JacksonUtils {\n    public static JavaType constructJavaType(Type type); /* construct java type -> Jackson Java Type. */\n    public static JsonNode transferToJsonNode(Object obj); /* Parse object to Jackson {@link JsonNode}. */\n    public static ArrayNode createEmptyArrayNode(); /* Create a new empty Jackson {@link ArrayNode}. */\n    public static ObjectNode createEmptyJsonNode(); /* Create a new empty Jackson {@link ObjectNode}. */\n    public static void registerSubtype(Class<?> clz, String type); /* Register sub type for child class. */\n    public static JsonNode toObj(String json); /* Json string deserialize to Jackson {@link JsonNode}. */\n    public static <T> T toObj(InputStream inputStream, Type type); /* Json string deserialize to Object. */\n    public static <T> T toObj(String json, TypeReference<T> typeReference); /* Json string deserialize to Object. */\n    public static <T> T toObj(String json, Type type); /* Json string deserialize to Object. */\n    public static <T> T toObj(String json, Class<T> cls); /* Json string deserialize to Object. */\n    public static <T> T toObj(byte[] json, TypeReference<T> typeReference); /* Json string deserialize to Object. */\n    public static <T> T toObj(InputStream inputStream, Class<T> cls); /* Json string deserialize to Object. */\n    public static <T> T toObj(byte[] json, Type cls); /* Json string deserialize to Object. */\n    public static <T> T toObj(byte[] json, Class<T> cls); /* Json string deserialize to Object. */\n    public static byte[] toJsonBytes(Object obj); /* Object to json string byte array. */\n    public static String toJson(Object obj); /* Object to json string. */\n}\n```\n\nThe context above is:\n```java\npublic final class NacosSignatureAlgorithm {\n\n    private static final String JWT_SEPERATOR = \".\";\n\n    private static final int HEADER_POSITION = 0;\n\n    private static final int PAYLOAD_POSITION = 1;\n\n    private static final int SIGNATURE_POSITION = 2;\n\n    private static final int JWT_PARTS = 3;\n\n    private static final String HS256_JWT_HEADER = \"eyJhbGciOiJIUzI1NiJ9\";\n\n    private static final String HS384_JWT_HEADER = \"eyJhbGciOiJIUzM4NCJ9\";\n\n    private static final String HS512_JWT_HEADER_OLD = \"eyJhbGciOiJIUzUxMiJ9\";\n\n    private static final String HS512_JWT_HEADER = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9\";\n\n    private static final Base64.Encoder URL_BASE64_ENCODER = Base64.getUrlEncoder().withoutPadding();\n\n    private static final Base64.Decoder URL_BASE64_DECODER = Base64.getUrlDecoder();\n\n    private static final Map<String, NacosSignatureAlgorithm> MAP = new HashMap<>(4);\n\n    public static final NacosSignatureAlgorithm HS256 = new NacosSignatureAlgorithm(\"HS256\", \"HmacSHA256\",\n            HS256_JWT_HEADER);\n\n    public static final NacosSignatureAlgorithm HS384 = new NacosSignatureAlgorithm(\"HS384\", \"HmacSHA384\",\n            HS384_JWT_HEADER);\n\n    public static final NacosSignatureAlgorithm HS512 = new NacosSignatureAlgorithm(\"HS512\", \"HmacSHA512\",\n            HS512_JWT_HEADER);\n\n    public static final NacosSignatureAlgorithm HS512_OLD = new NacosSignatureAlgorithm(\"HS512\", \"HmacSHA512\",\n        HS512_JWT_HEADER_OLD);\n\n    private final String algorithm;\n\n    private final String jcaName;\n\n    private final String header;\n\n    static {\n        MAP.put(HS256_JWT_HEADER, HS256);\n        MAP.put(HS384_JWT_HEADER, HS384);\n        MAP.put(HS512_JWT_HEADER, HS512);\n        MAP.put(HS512_JWT_HEADER_OLD, HS512_OLD);\n    }\n\n    /**\n     * verify jwt.\n     *\n     * @param jwt complete jwt string\n     * @param key for signature\n     * @return object for payload\n     * @throws AccessException access exception\n     */\n    public static NacosUser verify(String jwt, Key key) throws AccessException {\n        if (StringUtils.isBlank(jwt)) {\n            throw new AccessException(\"user not found!\");\n        }\n        String[] split = jwt.split(\"\\\\.\");\n        if (split.length != JWT_PARTS) {\n            throw new AccessException(\"token invalid!\");\n        }\n        String header = split[HEADER_POSITION];\n        String payload = split[PAYLOAD_POSITION];\n        String signature = split[SIGNATURE_POSITION];\n\n        NacosSignatureAlgorithm signatureAlgorithm = MAP.get(header);\n        if (signatureAlgorithm == null) {\n            throw new AccessException(\"unsupported signature algorithm\");\n        }\n        NacosUser user = signatureAlgorithm.verify(header, payload, signature, key);\n        // add by cse, validate user info\n        if (user.getUserName().equals(\"cse\") && AuthConstants.GLOBAL_ADMIN_ROLE.equals(user.getAuth())) {\n            user.setGlobalAdmin(true);\n        }\n        user.setToken(jwt);\n        return user;\n    }\n\n    /**\n     * verify jwt.\n     *\n     * @param header    header of jwt\n     * @param payload   payload of jwt\n     * @param signature signature of jwt\n     * @param key       for signature\n     * @return object for payload\n     * @throws AccessException access exception\n     */\n    public NacosUser verify(String header, String payload, String signature, Key key) throws AccessException {\n        Mac macInstance = getMacInstance(key);\n        byte[] bytes = macInstance.doFinal((header + JWT_SEPERATOR + payload).getBytes(StandardCharsets.US_ASCII));\n        if (!URL_BASE64_ENCODER.encodeToString(bytes).equals(signature)) {\n            throw new AccessException(\"Invalid signature\");\n        }\n        NacosJwtPayload nacosJwtPayload = JacksonUtils.toObj(URL_BASE64_DECODER.decode(payload), NacosJwtPayload.class);\n        if (nacosJwtPayload.getExp() >= TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis())) {\n            // add by cse, valid token info\n            NacosUser nacosUser = new NacosUser();\n            nacosUser.setAuth(nacosJwtPayload.getAuth());\n            nacosUser.setPerm(nacosJwtPayload.getPerm());\n            nacosUser.setUserName(nacosJwtPayload.getSub());\n            return nacosUser;\n        }\n\n        throw new AccessException(\"token expired!\");\n    }\n\n    /**\n     * get jwt expire time in seconds.\n     *\n     * @param jwt complete jwt string\n     * @param key for signature\n     * @return expire time in seconds\n     * @throws AccessException access exception\n     */\n    public static long getExpiredTimeInSeconds(String jwt, Key key) throws AccessException {\n        if (StringUtils.isBlank(jwt)) {\n            throw new AccessException(\"user not found!\");\n        }\n        String[] split = jwt.split(\"\\\\.\");\n        if (split.length != JWT_PARTS) {\n            throw new AccessException(\"token invalid!\");\n        }\n        String header = split[HEADER_POSITION];\n        String payload = split[PAYLOAD_POSITION];\n        String signature = split[SIGNATURE_POSITION];\n\n        NacosSignatureAlgorithm signatureAlgorithm = MAP.get(header);\n        if (signatureAlgorithm == null) {\n            throw new AccessException(\"unsupported signature algorithm\");\n        }\n        return signatureAlgorithm.getExpireTimeInSeconds(header, payload, signature, key);\n    }\n\n    /**\n     * get jwt expire time in seconds.\n     *\n     * @param header    header of jwt\n     * @param payload   payload of jwt\n     * @param signature signature of jwt\n     * @param key       for signature\n     * @return expire time in seconds\n     * @throws AccessException access exception\n     */\n    public long getExpireTimeInSeconds(String header, String payload, String signature, Key key)\n            throws AccessException {\n        Mac macInstance = getMacInstance(key);\n        byte[] bytes = macInstance.doFinal((header + JWT_SEPERATOR + payload).getBytes(StandardCharsets.US_ASCII));\n        if (!URL_BASE64_ENCODER.encodeToString(bytes).equals(signature)) {\n            throw new AccessException(\"Invalid signature\");\n        }\n        NacosJwtPayload nacosJwtPayload = JacksonUtils.toObj(URL_BASE64_DECODER.decode(payload), NacosJwtPayload.class);\n        return nacosJwtPayload.getExp();\n    }\n\n    private NacosSignatureAlgorithm(String alg, String jcaName, String header) {\n        this.algorithm = alg;\n        this.jcaName = jcaName;\n        this.header = header;\n    }\n```\n\nThe context below is:\n```java\n\n    private Mac getMacInstance(Key key) {\n        try {\n            Mac instance = Mac.getInstance(jcaName);\n            instance.init(key);\n            return instance;\n        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n            throw new IllegalArgumentException(\"Invalid key: \" + key);\n        }\n    }\n\n    public String getAlgorithm() {\n        return algorithm;\n    }\n\n    public String getJcaName() {\n        return jcaName;\n    }\n\n    public String getHeader() {\n        return header;\n    }\n}\n```\n\nThe new feature is 根据JWT token的结构，生成JWT token.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\n String sign(NacosJwtPayload nacosJwtPayload, Key key)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "nacos_f00563108#25", "good_example_response": "```java\n    String sign(NacosJwtPayload nacosJwtPayload, Key key) {\n        String jwtWithoutSign = header + JWT_SEPERATOR + URL_BASE64_ENCODER.encodeToString(\n                nacosJwtPayload.toString().getBytes(StandardCharsets.UTF_8));\n        Mac macInstance = getMacInstance(key);\n        byte[] bytes = jwtWithoutSign.getBytes(StandardCharsets.US_ASCII);\n        String signature = URL_BASE64_ENCODER.encodeToString(macInstance.doFinal(bytes));\n        return jwtWithoutSign + JWT_SEPERATOR + signature;\n    }\n    ```", "reward_command": "cd /docker/JavaRunProject/nacos_f00563108;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true -Dcheckstyle.skip=true clean test -f pom.xml -Dtest=com.alibaba.nacos.plugin.auth.impl.token.impl.JwtTokenManagerTest.java", "extra_content": {"query": "根据JWT token的结构，生成JWT token", "diff_path": "/docker/JavaRunProject/nacos_f00563108/diff/25.patch", "test_result": "fail", "file_path": "/plugin-default-impl/src/main/java/com/alibaba/nacos/plugin/auth/impl/jwt/NacosSignatureAlgorithm.java", "start_line": 209, "end_line": 217, "work_dir": "/docker/JavaRunProject/nacos_f00563108/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\npublic class ShardingContext {\n    public static void clean();\n    public static List<Handler> getHandlerList();\n    public static void addHandler(Handler handler);\n    public static Object getParams(String key);\n    public static void setParams(String key, Object value);\n}\n```\n\nThe context above is:\n```java\n@Intercepts({\n    @Signature(\n            type = StatementHandler.class,\n            method = \"prepare\",\n            args = {Connection.class, Integer.class})\n})\n/**\n * 表分片处理拦截器\n *\n */\npublic class TableShardInterceptor implements Interceptor {\n    private static final ReflectorFactory DEFAULT_REFLECTOR_FACTORY = new DefaultReflectorFactory();\n```\n\nThe context below is:\n```java\n\n    @Override\n    public Object plugin(final Object target) {\n        if (target instanceof StatementHandler) {\n            return Plugin.wrap(target, this);\n        } else {\n            return target;\n        }\n    }\n\n    @Override\n    public void setProperties(final Properties properties) {}\n}\n```\n\nThe new feature is 自定义一个mybatis的拦截器，拦截sql后增加自定义行为并执行.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\npublic Object intercept(final Invocation invocation) throws Throwable\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "octopusscheduler_f00563108#27", "good_example_response": "```java\n    public Object intercept(final Invocation invocation) throws Throwable {\n        List<Handler> handlerList = ShardingContext.getHandlerList();\n        if (handlerList == null) {\n            return invocation.proceed();\n        }\n\n        final StatementHandler statementHandler = (StatementHandler) invocation.getTarget();\n        final MetaObject metaObject =\n            MetaObject.forObject(\n                statementHandler,\n                SystemMetaObject.DEFAULT_OBJECT_FACTORY,\n                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,\n                DEFAULT_REFLECTOR_FACTORY);\n        String SQL = (String) metaObject.getValue(\"delegate.boundSql.sql\");\n\n        for (Handler handler : handlerList) {\n            SQL = handler.replace(SQL);\n        }\n        metaObject.setValue(\"delegate.boundSql.sql\", SQL);\n\n        return invocation.proceed();\n    }\n```", "reward_command": "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true clean test -f pom.xml -Dtest=com.huawei.devcloud.octopusscheduler.powerschedule.sharding.interceptor.TableShardInterceptorTest.java", "extra_content": {"query": "自定义一个mybatis的拦截器，拦截sql后增加自定义行为并执行", "diff_path": "/docker/JavaRunProject/octopusscheduler_f00563108/diff/27.patch", "test_result": "pass", "file_path": "/service/src/main/java/com/huawei/devcloud/octopusscheduler/powerschedule/sharding/interceptor/TableShardInterceptor.java", "start_line": 34, "end_line": 56, "work_dir": "/docker/JavaRunProject/octopusscheduler_f00563108/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\npublic class RiskComplianceManager {\n    public static final int SENSITIVE_WORD_MAX_LEN; /* 敏感词的数据库表内容字段最大长度 */\n    public static final String RESPONSE_PHASE; /* 表示是输出时被风控拦截的字符串 */\n    public static final String REQUEST_PHASE; /* 表示是输入时被风控拦截的字符串 */\n    public static final int TEXT_CHECK_TASK_UUID_LEN;\n    public int getRiskCheckWordLength(); /* 获取风控检查的敏感词长度 */\n    public boolean isSensitiveCheckPromptEnable(); /* 获取prompt攻击检测开关状态 */\n    public static String truncateRiskInfo(String riskInfo); /* 对记录入库的数据进行截断，避免字符串超过数据库字段risk_info长度限制 */\n    public MatchedResult riskTextAttackDetect(String userId, String taskId, String text, boolean isConfidential,\n        String traceId); /* 执行aics prompt注入攻击检查 */\n    public MatchedResult riskComplianceCheck(String userId, String taskId, String text, boolean isConfidential, String domainId); /* 风险控制检查方法实现 */\n    public boolean languageCheck(String taskId, String text, boolean isConfidential, String backendServiceName,\n        String traceId); /* 小语种检查 */\n}\n\npublic class EngineProperties {\n    public boolean isHcsSiteEnv(); /* 判断是否为hcs站点 */\n    public boolean isHcEnv(); /* 判断是否为hc站点 */\n}\n\npublic class SseServer {\n    public void closeWithError(String connectionId, Throwable throwable); /* 错误情况下关闭上游连接 */\n    public void close(String connectionId); /* 正常情况下关闭连接，主要是关闭到上游的连接 */\n    public void send(String connectionId, String content, String traceId); /* 向客户端发送消息, 这个方法用于向上游（插件、web端等)发送数据 */\n    public SseEmitter connect(String connectionId, String traceId); /* 客户端连接sse服务器, 这里是建立engine和插件的长连接 */\n    public static int getCurrentConcurrency(); /* 获取当前系统容量 */\n}\n```\n\nThe context above is:\n```java\n@Async\n@Service\npublic class AsyncService {\n    private static final Logger LOGGER = Logger.getLogger(AsyncService.class);\n\n    @Resource\n    private RiskComplianceManager riskComplianceManager;\n\n    @Resource\n    private UserRiskManageService riskManageService;\n\n    @Resource\n    private EngineProperties engineProperties;\n\n    @Resource\n    private SseServer sseServer;\n\n    /**\n     * 异步执行aics prompt注入攻击检查\n     *\n     * @param sessionId 会话id\n     * @param checkData 检查内容\n     * @param isConfidential 是否为敏感数据\n     * @param userRiskRecord 访问记录对象\n     * @param phase 执行检查的阶段\n     */\n    public void attackCheck(String sessionId, String checkData, boolean isConfidential, UserRiskRecord userRiskRecord,\n        String phase) {\n        // request阶段，判断是否为对话场景，不是对话场景无需执行检查\n        if (StringUtils.equals(REQUEST_PHASE, phase) && !AgentType.ChatAgent.name()\n            .equals(userRiskRecord.getAgentType())) {\n            return;\n        }\n        String traceId = userRiskRecord.getTraceId();\n        String userId = userRiskRecord.getUserId();\n\n        LOGGER.info(\"begin text attack detect, phase:{}, traceId:{}, sessionId:{}\", phase, traceId, sessionId);\n        MatchedResult result = riskComplianceManager.riskTextAttackDetect(userId, sessionId, checkData, isConfidential,\n            traceId);\n        if (!result.isMatched()) {\n            LOGGER.info(\"end text attack detect, phase:{}, traceId:{}, sessionId:{}\", phase, traceId, sessionId);\n            return;\n        }\n        LOGGER.warn(\"text attack detect failed, phase:{}, connectionId:{}, userId:{}, traceId:{}\", phase, sessionId,\n            userId, traceId);\n        checkResultAndRecordAsync(result);\n        interceptAttack(sessionId, phase, userRiskRecord);\n    }\n```\n\nThe context below is:\n```java\n\n    private void interceptAttack(String sessionId, String phase, UserRiskRecord userRiskRecord) {\n        if (!engineProperties.isSensitiveCheckAicsInterceptEnable()) {\n            LOGGER.info(\"aics intercept is not enable, skip forbidden user and close connection\");\n            return;\n        }\n        riskManageService.autoForbiddenUserAsync(userRiskRecord);\n        LOGGER.warn(\"start to close connection, phase:{}, connectionId:{}, userId:{}, traceId:{}\", phase, sessionId,\n            userRiskRecord.getUserId(), userRiskRecord.getTraceId());\n        // 关闭上下游连接\n        sseServer.closeWithError(sessionId, new NotSafePromptException(ErrorCode.NOT_SAFE_PROMPT_ERROR));\n        LOGGER.warn(\"end to close connection, phase:{}, connectionId: {}, userId:{}, traceId:{}\", phase, sessionId,\n            userRiskRecord.getUserId(), userRiskRecord.getTraceId());\n    }\n}\n```\n\nThe new feature is 异步记录风控拦截记录.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\nprivate void checkResultAndRecordAsync(MatchedResult result)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "SnapEngineService_h00636345#28", "good_example_response": "```java\n    private void checkResultAndRecordAsync(MatchedResult result) {\n        CompletableFuture.completedFuture(result).thenAcceptAsync(matchedResult -> {\n            UserRiskRecord userRiskRecord = new UserRiskRecord();\n            userRiskRecord.setRiskInfo(result.getMatchWord());\n            userRiskRecord.setRiskType(result.getMatchType());\n            userRiskRecord.setRiskScore(result.getRiskScore());\n            riskManageService.addUserRiskRecord(userRiskRecord);\n        });\n    }\n```", "reward_command": "cd /docker/JavaRunProject/SnapEngineService_h00636345;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true -Dcheckstyle.skip=true clean test -f pom.xml -Dtest=com.huawei.codearts.engine.service.AsyncServiceTest#test_attackCheck_should_close_connection_when_risk_compliance_not_pass_and_intercept_unable", "extra_content": {"query": "异步记录风控拦截记录", "diff_path": "/docker/JavaRunProject/SnapEngineService_h00636345/diff/28.patch", "test_result": "pass", "file_path": "/service/src/main/java/com/huawei/codearts/engine/service/AsyncService.java", "start_line": 81, "end_line": 90, "work_dir": "/docker/JavaRunProject/SnapEngineService_h00636345/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\n@MappedJdbcTypes(JdbcType.LONGVARCHAR)\n@MappedTypes(Cddl.class)\npublic class CddlTypeHandler extends JsonValueTypeHandler<Cddl> {\n```\n\nThe context below is:\n```java\n}\n```\n\nThe new feature is 自定义mybatis json typeHandler.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\nprotected Type type()\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "octopusscheduler_f00563108#31", "good_example_response": "```java\n    protected Type type() {\n        return (new TypeToken<Cddl>() {\n        }).getType();\n    }```", "reward_command": "cd /docker/JavaRunProject/octopusscheduler_f00563108;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true clean test -f pom.xml -Dtest=com.huawei.devcloud.octopusscheduler.mapper.typehandler.CddlTypeHandlerTest.java", "extra_content": {"query": "自定义mybatis json typeHandler", "diff_path": "/docker/JavaRunProject/octopusscheduler_f00563108/diff/31.patch", "test_result": "pass", "file_path": "/service/src/main/java/com/huawei/devcloud/octopusscheduler/mapper/typehandler/CddlTypeHandler.java", "start_line": 25, "end_line": 28, "work_dir": "/docker/JavaRunProject/octopusscheduler_f00563108/"}}
{"prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\npublic class ListElemtIsStringTypeHandler extends ListTypeHandler<List<String>> {\n```\n\nThe context below is:\n```java\n}\n```\n\nThe new feature is 自定义mybatis List typeHandler.\n\nAnd here is the code snippet you are asked to modify:\n```java\n\nprotected Type type()\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.", "domain": "nl2code_java", "id": "octopusscheduler_f00563108#32", "good_example_response": "```java\n    protected Type type() {\n        return (new TypeToken<List<String>>() {\n        }).getType();\n    }```", "reward_command": "cd /docker/JavaRunProject/octopusscheduler_f00563108;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_352 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true clean test -f pom.xml -Dtest=com.huawei.devcloud.octopusscheduler.mapper.typehandler.ListElemtIsStringTypeHandlerTest.java", "extra_content": {"query": "自定义mybatis List typeHandler", "diff_path": "/docker/JavaRunProject/octopusscheduler_f00563108/diff/32.patch", "test_result": "pass", "file_path": "/service/src/main/java/com/huawei/devcloud/octopusscheduler/mapper/typehandler/ListElemtIsStringTypeHandler.java", "start_line": 18, "end_line": 21, "work_dir": "/docker/JavaRunProject/octopusscheduler_f00563108/"}}