{
  "benchmark_id": "DubheProbeOrchestration_z00806805#41",
  "timestamp": "2025-09-17T16:13:58.842356",
  "model_used": "gpt-5-manual-20",
  "prompt_version": "v9_improved",
  "selected_region": "// 构建查询条件，包括条件查询和按字段排序。\npublic QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey)",
  "target_implementation": "public QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey) {\n        QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n        buildCondition(request, queryWrapper);\n        buildOrder(request, queryWrapper, uniqueKey);\n        return queryWrapper;\n    }",
  "final_code_with_annotations": "  1: public class BaseDao<T> {\n  2: \n  3:     /**\n  4:      * 构建分页查询\n  5:      *\n  6:      * @param request 查询条件\n  7:      * @return IPage<T>\n  8:      */\n  9:     public IPage<T> buildIPage(QueryRequest request) {\n 10:         IPage<T> iPage = new Page<>();\n 11:         iPage.setCurrent(request.getPageIndex());\n 12:         iPage.setSize(request.getPageSize());\n 13:         return iPage;\n 14:     }\n 15: \n 16:     /**\n 17:      * 构建查询条件，包括条件查询和按字段排序。\n 18:      *\n 19:      * @param request   查询条件\n 20:      * @return QueryWrapper<T>\n 21:      */\n 22:     public QueryWrapper<T> buildQueryWrapper(QueryRequest request) {\n 23:         QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n 24:         buildCondition(request, queryWrapper);\n 25:         buildOrder(request, queryWrapper, null);\n 26:         return queryWrapper;\n 27:     }\n 28: public QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey) { // [禁止修改-目标实现]\n 29:         QueryWrapper<T> queryWrapper = new QueryWrapper<>(); // [禁止修改-目标实现]\n 30:         buildCondition(request, queryWrapper); // [禁止修改-目标实现]\n 31:         buildOrder(request, queryWrapper, uniqueKey); // [禁止修改-目标实现]\n 32:         return queryWrapper; // [禁止修改-目标实现]\n 33:     } // [禁止修改-目标实现]\n 34: /**\n 35:      * 构建查询条件\n 36:      * 因为in和notIn这两个条件特殊，在for循环外分别单独构建。对于同一列名，把所有的值放到一起。\n 37:      *\n 38:      * @param request      查询条件\n 39:      * @param queryWrapper 构建对象\n 40:      */\n 41:     public void buildCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n 42:         if (request.getSelectors() == null) {\n 43:             return;\n 44:         }\n 45:         buildInCondition(request, queryWrapper);\n 46:         buildNotInCondition(request, queryWrapper);\n 47:         for (QueryRequest.Selector selector : request.getSelectors()) {\n 48:             switch (selector.getFilterType()) {\n 49:                 case LIKE:\n 50:                     queryWrapper.like(selector.getColumnName(), selector.getFilterValue());\n 51:                     break;\n 52:                 case EQUAL:\n 53:                     queryWrapper.eq(selector.getColumnName(), selector.getFilterValue());\n 54:                     break;\n 55:                 case BIGGER:\n 56:                     queryWrapper.gt(selector.getColumnName(), selector.getFilterValue());\n 57:                     break;\n 58:                 case BIGGEREQUAL:\n 59:                     queryWrapper.ge(selector.getColumnName(), selector.getFilterValue());\n 60:                     break;\n 61:                 case LESS:\n 62:                     queryWrapper.lt(selector.getColumnName(), selector.getFilterValue());\n 63:                     break;\n 64:                 case LESSEQUAL:\n 65:                     queryWrapper.le(selector.getColumnName(), selector.getFilterValue());\n 66:                     break;\n 67:                 case ISNULL:\n 68:                     queryWrapper.isNull(selector.getColumnName());\n 69:                     break;\n 70:                 case ISNOTNULL:\n 71:                     queryWrapper.isNotNull(selector.getColumnName());\n 72:                     break;\n 73:                 default:\n 74:                     break;\n 75:             }\n 76:         }\n 77:     }\n 78: \n 79:     /**\n 80:      * 构建排序条件\n 81:      *\n 82:      * @param request      查询条件\n 83:      * @param queryWrapper 构建对象\n 84:      * @param uniqueKey    唯一主键（传入如果不为空，则自动添加一条根据默认主键升序方法）\n 85:      */\n 86:     public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper, String uniqueKey) {\n 87:         if (request.getSortOrder() != null && request.getSortColumn() != null) {\n 88:             queryWrapper.orderBy(\n 89:                     true, SortOrderEnum.ASC.equals(request.getSortOrder()), request.getSortColumn());\n 90:         }\n 91: \n 92:         if (ObjectUtils.isNotEmpty(uniqueKey)) {\n 93:             queryWrapper.orderBy(true, true, uniqueKey);\n 94:         }\n 95:     }\n 96: \n 97:     private void buildInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n 98:         Map<String, List<QueryRequest.Selector>> inColumnMap =\n 99:                 getFilterColumnMap(request, FilterTypeEnum.IN);\n100:         inColumnMap.forEach(\n101:                 (columnName, fieldSelector) ->\n102:                         queryWrapper.in(\n103:                                 columnName,\n104:                                 fieldSelector.stream()\n105:                                         .map(QueryRequest.Selector::getFilterValue)\n106:                                         .collect(Collectors.toList())));\n107:     }\n108: \n109:     private void buildNotInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n110:         Map<String, List<QueryRequest.Selector>> notInColumnMap =\n111:                 getFilterColumnMap(request, FilterTypeEnum.NOTIN);\n112:         notInColumnMap.forEach(\n113:                 (columnName, fieldSelector) ->\n114:                         queryWrapper.notIn(\n115:                                 columnName,\n116:                                 fieldSelector.stream()\n117:                                         .map(QueryRequest.Selector::getFilterValue)\n118:                                         .collect(Collectors.toList())));\n119:     }\n120: \n121:     /**\n122:      * 根据列名称分组\n123:      *\n124:      * @param request    查询条件\n125:      * @param filterType 过滤类型\n126:      * @return key是列名，value是List<RequestFieldSelector>的map\n127:      */\n128:     private Map<String, List<QueryRequest.Selector>> getFilterColumnMap(\n129:             QueryRequest request, FilterTypeEnum filterType) {\n130:         return request.getSelectors().stream()\n131:                 .filter(selector -> filterType == selector.getFilterType())\n132:                 .collect(Collectors.groupingBy(QueryRequest.Selector::getColumnName));\n133:     }\n134: }",
  "prompt": {
    "system_prompt": "你是资深 Java 工程师。现在给你一个完整的代码文件（最终状态），你需要**倒推**出为了达到这个最终状态而**刚刚**做过的3次递进式代码修改（Recent Changes）。\n\n核心逻辑：\n- 给出的代码是最终完整状态，每行都有行号标注\n- 你需要倒推出3个历史版本的修改过程\n- 演进路径：初始版本 → RC3 → RC2 → RC1 → 当前最终版本\n- **关键**：不要在最终状态基础上再做修改，而是倒推出达到最终状态的历史修改过程\n\n重要约束：\n1. **禁止修改区域**：不能修改标注为\"禁止修改\"的代码部分\n2. **只能修改**：其他未标注为禁止修改的代码部分\n3. **不新增**：import/依赖；不修改方法签名/可见性；不创建/删除类\n4. **RC目标**：每个RC都应该为实现目标功能做准备工作\n5. **diff格式**：使用标准的unified diff格式，包含行号和+/-操作\n6. **行号准确性**：diff中的行号必须与给出的带行号代码完全一致\n7. **倒推逻辑**：从最终状态向前倒推，不是在最终状态上继续修改\n\n**🔥 DIFF方向关键说明**：\n- hunks_3 / hunks_2 / hunks_1：每一步都是\"RC_k ➜ 下一步更接近最终\"的**正向补丁**\n- **+ 行**：在\"更接近最终的版本/最终版\"中存在的行（应与最终版行号、内容一致）\n- **- 行**：只存在于\"更早版本\"的行（在演进过程中被替换掉的内容）\n- **所有行号以你给的最终代码为准**，在 diff_content 的可见行里必须匹配\n\n技术要求：\n- 每个 hunk 包含：file_path、start_line、end_line、diff_content（标准unified diff格式）\n- 使用精确的行号定位，基于给出的带行号的代码\n- diff_content必须包含真实的删除(-)和新增(+)操作\n- **重要**：diff中的行号必须与最终代码的实际行号匹配",
    "user_prompt": "[SELECTED_REGION] - 禁止修改\n选中的代码区域（不可修改）：\n// 构建查询条件，包括条件查询和按字段排序。\npublic QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey)\n\n[TARGET_IMPLEMENTATION] - 禁止修改\n目标实现代码（不可修改）：\npublic QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey) {\n        QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n        buildCondition(request, queryWrapper);\n        buildOrder(request, queryWrapper, uniqueKey);\n        return queryWrapper;\n    }\n\n[FINAL_CODE_WITH_LINE_NUMBERS] - 最终状态（带行号和标注）\n以下是最终完整代码状态，每行都有行号标注，并标注了禁止修改的区域：\n  1: public class BaseDao<T> {\n  2: \n  3:     /**\n  4:      * 构建分页查询\n  5:      *\n  6:      * @param request 查询条件\n  7:      * @return IPage<T>\n  8:      */\n  9:     public IPage<T> buildIPage(QueryRequest request) {\n 10:         IPage<T> iPage = new Page<>();\n 11:         iPage.setCurrent(request.getPageIndex());\n 12:         iPage.setSize(request.getPageSize());\n 13:         return iPage;\n 14:     }\n 15: \n 16:     /**\n 17:      * 构建查询条件，包括条件查询和按字段排序。\n 18:      *\n 19:      * @param request   查询条件\n 20:      * @return QueryWrapper<T>\n 21:      */\n 22:     public QueryWrapper<T> buildQueryWrapper(QueryRequest request) {\n 23:         QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n 24:         buildCondition(request, queryWrapper);\n 25:         buildOrder(request, queryWrapper, null);\n 26:         return queryWrapper;\n 27:     }\n 28: public QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey) { // [禁止修改-目标实现]\n 29:         QueryWrapper<T> queryWrapper = new QueryWrapper<>(); // [禁止修改-目标实现]\n 30:         buildCondition(request, queryWrapper); // [禁止修改-目标实现]\n 31:         buildOrder(request, queryWrapper, uniqueKey); // [禁止修改-目标实现]\n 32:         return queryWrapper; // [禁止修改-目标实现]\n 33:     } // [禁止修改-目标实现]\n 34: /**\n 35:      * 构建查询条件\n 36:      * 因为in和notIn这两个条件特殊，在for循环外分别单独构建。对于同一列名，把所有的值放到一起。\n 37:      *\n 38:      * @param request      查询条件\n 39:      * @param queryWrapper 构建对象\n 40:      */\n 41:     public void buildCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n 42:         if (request.getSelectors() == null) {\n 43:             return;\n 44:         }\n 45:         buildInCondition(request, queryWrapper);\n 46:         buildNotInCondition(request, queryWrapper);\n 47:         for (QueryRequest.Selector selector : request.getSelectors()) {\n 48:             switch (selector.getFilterType()) {\n 49:                 case LIKE:\n 50:                     queryWrapper.like(selector.getColumnName(), selector.getFilterValue());\n 51:                     break;\n 52:                 case EQUAL:\n 53:                     queryWrapper.eq(selector.getColumnName(), selector.getFilterValue());\n 54:                     break;\n 55:                 case BIGGER:\n 56:                     queryWrapper.gt(selector.getColumnName(), selector.getFilterValue());\n 57:                     break;\n 58:                 case BIGGEREQUAL:\n 59:                     queryWrapper.ge(selector.getColumnName(), selector.getFilterValue());\n 60:                     break;\n 61:                 case LESS:\n 62:                     queryWrapper.lt(selector.getColumnName(), selector.getFilterValue());\n 63:                     break;\n 64:                 case LESSEQUAL:\n 65:                     queryWrapper.le(selector.getColumnName(), selector.getFilterValue());\n 66:                     break;\n 67:                 case ISNULL:\n 68:                     queryWrapper.isNull(selector.getColumnName());\n 69:                     break;\n 70:                 case ISNOTNULL:\n 71:                     queryWrapper.isNotNull(selector.getColumnName());\n 72:                     break;\n 73:                 default:\n 74:                     break;\n 75:             }\n 76:         }\n 77:     }\n 78: \n 79:     /**\n 80:      * 构建排序条件\n 81:      *\n 82:      * @param request      查询条件\n 83:      * @param queryWrapper 构建对象\n 84:      * @param uniqueKey    唯一主键（传入如果不为空，则自动添加一条根据默认主键升序方法）\n 85:      */\n 86:     public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper, String uniqueKey) {\n 87:         if (request.getSortOrder() != null && request.getSortColumn() != null) {\n 88:             queryWrapper.orderBy(\n 89:                     true, SortOrderEnum.ASC.equals(request.getSortOrder()), request.getSortColumn());\n 90:         }\n 91: \n 92:         if (ObjectUtils.isNotEmpty(uniqueKey)) {\n 93:             queryWrapper.orderBy(true, true, uniqueKey);\n 94:         }\n 95:     }\n 96: \n 97:     private void buildInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n 98:         Map<String, List<QueryRequest.Selector>> inColumnMap =\n 99:                 getFilterColumnMap(request, FilterTypeEnum.IN);\n100:         inColumnMap.forEach(\n101:                 (columnName, fieldSelector) ->\n102:                         queryWrapper.in(\n103:                                 columnName,\n104:                                 fieldSelector.stream()\n105:                                         .map(QueryRequest.Selector::getFilterValue)\n106:                                         .collect(Collectors.toList())));\n107:     }\n108: \n109:     private void buildNotInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n110:         Map<String, List<QueryRequest.Selector>> notInColumnMap =\n111:                 getFilterColumnMap(request, FilterTypeEnum.NOTIN);\n112:         notInColumnMap.forEach(\n113:                 (columnName, fieldSelector) ->\n114:                         queryWrapper.notIn(\n115:                                 columnName,\n116:                                 fieldSelector.stream()\n117:                                         .map(QueryRequest.Selector::getFilterValue)\n118:                                         .collect(Collectors.toList())));\n119:     }\n120: \n121:     /**\n122:      * 根据列名称分组\n123:      *\n124:      * @param request    查询条件\n125:      * @param filterType 过滤类型\n126:      * @return key是列名，value是List<RequestFieldSelector>的map\n127:      */\n128:     private Map<String, List<QueryRequest.Selector>> getFilterColumnMap(\n129:             QueryRequest request, FilterTypeEnum filterType) {\n130:         return request.getSelectors().stream()\n131:                 .filter(selector -> filterType == selector.getFilterType())\n132:                 .collect(Collectors.groupingBy(QueryRequest.Selector::getColumnName));\n133:     }\n134: }\n\n[RC_CONSTRAINTS]\nRecent Changes约束：\n1. 只能修改未标注为\"禁止修改\"的代码部分\n2. 每个RC都应该为实现TARGET_IMPLEMENTATION做准备工作\n3. 使用精确的行号定位和标准diff格式\n4. RC应该体现真实的开发演进过程\n5. **关键**：diff中的行号必须与上面给出的最终代码行号完全一致\n6. **倒推思维**：从最终状态倒推历史修改，不是在最终状态上继续开发\n\n**🎯 DIFF方向再次强调**：\n- 每个RC都是朝着最终状态的**正向演进**\n- **+ 行**：最终版本中存在的内容（目标状态的行）\n- **- 行**：历史版本中存在但被替换的内容（旧状态的行）\n- **验证方法**：+ 行的内容应该能在最终代码的对应行号找到\n\n[INTENT]\n请倒推出为了实现TARGET_IMPLEMENTATION，开发者做过的3次递进式准备工作：\n- hunks_3: 倒数第三次修改（最早的准备工作）\n- hunks_2: 倒数第二次修改（中间准备）\n- hunks_1: 最近一次修改（最后的准备工作）\n\n每次修改都应该：\n1. 基于精确的行号定位（与最终代码行号完全一致）\n2. 使用标准的unified diff格式\n3. 为实现TARGET_IMPLEMENTATION做必要准备\n4. 体现真实的开发思维过程\n5. **验证**：确保diff中的行号与最终代码中的实际行号匹配\n6. **倒推验证**：确保是从最终状态向前倒推的修改过程\n7. **方向验证**：+ 行内容应该在最终代码中存在，- 行内容应该是被替换的历史内容\n\n[RETURN FORMAT]\n### hunks_3 (倒数第三次修改，最早的准备工作)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### hunks_2 (倒数第二次修改，中间准备)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### hunks_1 (最近一次修改，最后的准备工作)\n```json\n[\n    {\n        \"file_path\": \"ClassName.java\",\n        \"start_line\": 实际行号,\n        \"end_line\": 实际行号,\n        \"diff_content\": \"@@ -实际行号,行数 +实际行号,行数 @@\\\\n 上下文行\\\\n-删除的行\\\\n+新增的行\\\\n 上下文行\"\n    }\n]\n```\n\n### notes\n简要说明这3次准备工作如何为实现TARGET_IMPLEMENTATION做准备，体现倒推的逻辑思维"
  },
  "llm_response": "好的！基于你给的**最终代码**（行号以最终版为准），我倒推出 3 次**正向补丁**（RC3→RC2→RC1），且严格不触碰 **\\[禁止修改-目标实现]**（第 28–33 行）。\n\n---\n\n### hunks\\_3 (倒数第三次修改，最早的准备工作)\n\n> 为后续新增 `uniqueKey` 语义做文档准备：在 `buildOrder` 的 Javadoc 中补充 `@param uniqueKey` 的说明。\n\n```json\n[\n  {\n    \"file_path\": \"BaseDao.java\",\n    \"start_line\": 82,\n    \"end_line\": 85,\n    \"diff_content\": \"@@ -82,4 +82,4 @@\\n-     * @param request      查询条件\\n-     * @param queryWrapper 构建对象\\n-     *\\n-     */\\n+     * @param request      查询条件\\n+     * @param queryWrapper 构建对象\\n+     * @param uniqueKey    唯一主键（传入如果不为空，则自动添加一条根据默认主键升序方法）\\n+     */\\n\"\n  }\n]\n```\n\n### hunks\\_2 (倒数第二次修改，中间准备)\n\n> 落地 `uniqueKey` 能力：将 `buildOrder` 方法签名扩展为三参，并在排序逻辑中在末尾补充按 `uniqueKey` 升序的稳定排序。\n\n```json\n[\n  {\n    \"file_path\": \"BaseDao.java\",\n    \"start_line\": 86,\n    \"end_line\": 95,\n    \"diff_content\": \"@@ -86,10 +86,10 @@\\n-    public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper) {\\n+    public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper, String uniqueKey) {\\n         if (request.getSortOrder() != null && request.getSortColumn() != null) {\\n             queryWrapper.orderBy(\\n                     true, SortOrderEnum.ASC.equals(request.getSortOrder()), request.getSortColumn());\\n         }\\n-\\n+        \\n+        if (ObjectUtils.isNotEmpty(uniqueKey)) {\\n+            queryWrapper.orderBy(true, true, uniqueKey);\\n+        }\\n     }\\n\"\n  }\n]\n```\n\n### hunks\\_1 (最近一次修改，最后的准备工作)\n\n> 适配调用方：将已有的无 `uniqueKey` 重载实现改为向新签名透传 `null`，保持行为不变同时兼容新能力。\n\n```json\n[\n  {\n    \"file_path\": \"BaseDao.java\",\n    \"start_line\": 22,\n    \"end_line\": 26,\n    \"diff_content\": \"@@ -22,5 +22,5 @@\\n     public QueryWrapper<T> buildQueryWrapper(QueryRequest request) {\\n         QueryWrapper<T> queryWrapper = new QueryWrapper<>();\\n         buildCondition(request, queryWrapper);\\n-        buildOrder(request, queryWrapper);\\n+        buildOrder(request, queryWrapper, null);\\n         return queryWrapper;\\n     }\\n\"\n  }\n]\n```\n\n---\n\n### notes\n\n* **RC3** 只改注释，先给团队传达即将引入的 `uniqueKey` 语义，避免误解；\n* **RC2** 扩展 `buildOrder` 为三参并实现“若提供 `uniqueKey` 则追加升序”的稳定排序，奠定能力基础；\n* **RC1** 更新无 `uniqueKey` 的封装调用，显式传 `null`，既不改变原行为又与新签名对齐；\n* 三个补丁均为**正向演进**，`+` 行完全匹配最终代码；且未改动 **\\[禁止修改-目标实现]**（28–33 行）。",
  "parsed_hunks": {
    "hunks_3": [
      {
        "file_path": "BaseDao.java",
        "start_line": 82,
        "end_line": 85,
        "diff_content": "@@ -82,4 +82,4 @@\n-     * @param request      查询条件\n-     * @param queryWrapper 构建对象\n-     *\n-     */\n+     * @param request      查询条件\n+     * @param queryWrapper 构建对象\n+     * @param uniqueKey    唯一主键（传入如果不为空，则自动添加一条根据默认主键升序方法）\n+     */\n"
      }
    ],
    "hunks_2": [
      {
        "file_path": "BaseDao.java",
        "start_line": 86,
        "end_line": 95,
        "diff_content": "@@ -86,10 +86,10 @@\n-    public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper) {\n+    public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper, String uniqueKey) {\n         if (request.getSortOrder() != null && request.getSortColumn() != null) {\n             queryWrapper.orderBy(\n                     true, SortOrderEnum.ASC.equals(request.getSortOrder()), request.getSortColumn());\n         }\n-\n+        \n+        if (ObjectUtils.isNotEmpty(uniqueKey)) {\n+            queryWrapper.orderBy(true, true, uniqueKey);\n+        }\n     }\n"
      }
    ],
    "hunks_1": [
      {
        "file_path": "BaseDao.java",
        "start_line": 22,
        "end_line": 26,
        "diff_content": "@@ -22,5 +22,5 @@\n     public QueryWrapper<T> buildQueryWrapper(QueryRequest request) {\n         QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n         buildCondition(request, queryWrapper);\n-        buildOrder(request, queryWrapper);\n+        buildOrder(request, queryWrapper, null);\n         return queryWrapper;\n     }\n"
      }
    ]
  },
  "validation_results": {
    "total_issues": 0,
    "total_lines": 134
  },
  "fix_info": {
    "total_fixes": 0,
    "fix_details": [],
    "fixed_at": "2025-09-17T16:13:58.842389"
  },
  "original_benchmark": {
    "prompt": "A user is developing a new feature. Based on the known code information, help him implement this new feature.\n\nBelow are some information from external classes imported by current file:\n```java\n\n```\n\nThe context above is:\n```java\npublic class BaseDao<T> {\n\n    /**\n     * 构建分页查询\n     *\n     * @param request 查询条件\n     * @return IPage<T>\n     */\n    public IPage<T> buildIPage(QueryRequest request) {\n        IPage<T> iPage = new Page<>();\n        iPage.setCurrent(request.getPageIndex());\n        iPage.setSize(request.getPageSize());\n        return iPage;\n    }\n\n    /**\n     * 构建查询条件，包括条件查询和按字段排序。\n     *\n     * @param request   查询条件\n     * @return QueryWrapper<T>\n     */\n    public QueryWrapper<T> buildQueryWrapper(QueryRequest request) {\n        QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n        buildCondition(request, queryWrapper);\n        buildOrder(request, queryWrapper, null);\n        return queryWrapper;\n    }\n```\n\nThe context below is:\n```java\n\n    /**\n     * 构建查询条件\n     * 因为in和notIn这两个条件特殊，在for循环外分别单独构建。对于同一列名，把所有的值放到一起。\n     *\n     * @param request      查询条件\n     * @param queryWrapper 构建对象\n     */\n    public void buildCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n        if (request.getSelectors() == null) {\n            return;\n        }\n        buildInCondition(request, queryWrapper);\n        buildNotInCondition(request, queryWrapper);\n        for (QueryRequest.Selector selector : request.getSelectors()) {\n            switch (selector.getFilterType()) {\n                case LIKE:\n                    queryWrapper.like(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case EQUAL:\n                    queryWrapper.eq(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case BIGGER:\n                    queryWrapper.gt(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case BIGGEREQUAL:\n                    queryWrapper.ge(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case LESS:\n                    queryWrapper.lt(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case LESSEQUAL:\n                    queryWrapper.le(selector.getColumnName(), selector.getFilterValue());\n                    break;\n                case ISNULL:\n                    queryWrapper.isNull(selector.getColumnName());\n                    break;\n                case ISNOTNULL:\n                    queryWrapper.isNotNull(selector.getColumnName());\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    /**\n     * 构建排序条件\n     *\n     * @param request      查询条件\n     * @param queryWrapper 构建对象\n     * @param uniqueKey    唯一主键（传入如果不为空，则自动添加一条根据默认主键升序方法）\n     */\n    public void buildOrder(QueryRequest request, QueryWrapper<T> queryWrapper, String uniqueKey) {\n        if (request.getSortOrder() != null && request.getSortColumn() != null) {\n            queryWrapper.orderBy(\n                    true, SortOrderEnum.ASC.equals(request.getSortOrder()), request.getSortColumn());\n        }\n\n        if (ObjectUtils.isNotEmpty(uniqueKey)) {\n            queryWrapper.orderBy(true, true, uniqueKey);\n        }\n    }\n\n    private void buildInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n        Map<String, List<QueryRequest.Selector>> inColumnMap =\n                getFilterColumnMap(request, FilterTypeEnum.IN);\n        inColumnMap.forEach(\n                (columnName, fieldSelector) ->\n                        queryWrapper.in(\n                                columnName,\n                                fieldSelector.stream()\n                                        .map(QueryRequest.Selector::getFilterValue)\n                                        .collect(Collectors.toList())));\n    }\n\n    private void buildNotInCondition(QueryRequest request, QueryWrapper<T> queryWrapper) {\n        Map<String, List<QueryRequest.Selector>> notInColumnMap =\n                getFilterColumnMap(request, FilterTypeEnum.NOTIN);\n        notInColumnMap.forEach(\n                (columnName, fieldSelector) ->\n                        queryWrapper.notIn(\n                                columnName,\n                                fieldSelector.stream()\n                                        .map(QueryRequest.Selector::getFilterValue)\n                                        .collect(Collectors.toList())));\n    }\n\n    /**\n     * 根据列名称分组\n     *\n     * @param request    查询条件\n     * @param filterType 过滤类型\n     * @return key是列名，value是List<RequestFieldSelector>的map\n     */\n    private Map<String, List<QueryRequest.Selector>> getFilterColumnMap(\n            QueryRequest request, FilterTypeEnum filterType) {\n        return request.getSelectors().stream()\n                .filter(selector -> filterType == selector.getFilterType())\n                .collect(Collectors.groupingBy(QueryRequest.Selector::getColumnName));\n    }\n}\n```\n\nThe new feature is 使用mybatis-plus-querywrapper构建查询条件.\n\nAnd here is the code snippet you are asked to modify:\n```java\n// 构建查询条件，包括条件查询和按字段排序。\npublic QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey)\n```\n\nPlease analyze the mission carefully and thoroughly first, and then give a definitely runnable code. You should put your code between ```java and ```.",
    "domain": "nl2code_java",
    "id": "DubheProbeOrchestration_z00806805#41",
    "good_example_response": "```java\n    public QueryWrapper<T> buildQueryWrapper(QueryRequest request, String uniqueKey) {\n        QueryWrapper<T> queryWrapper = new QueryWrapper<>();\n        buildCondition(request, queryWrapper);\n        buildOrder(request, queryWrapper, uniqueKey);\n        return queryWrapper;\n    }\n```",
    "reward_command": "cd /docker/JavaRunProject/DubheProbeOrchestration_z00806805; export JAVA_HOME=/usr/lib/jvm/jdk-17.0.6 && export PATH=$JAVA_HOME/bin:$PATH && mvn -DfailIfNoTests=false -Dmaven.test.failure.ignore=true -Dcheckstyle.skip=true clean test -f pom.xml  -e -Dtest=com/huawei/cbu/dubheprobeorchestration/dao/BaseDaoTest.java",
    "extra_content": {
      "query": "使用mybatis-plus-querywrapper构建查询条件",
      "diff_path": "/docker/JavaRunProject/DubheProbeOrchestration_z00806805/diff/41.patch",
      "test_result": "pass",
      "file_path": "/DubheProbeOrchestration/src/main/java/com/huawei/cbu/dubheprobeorchestration/dao/BaseDao.java",
      "start_line": 54,
      "end_line": 60,
      "work_dir": "/docker/JavaRunProject/DubheProbeOrchestration_z00806805/"
    }
  }
}