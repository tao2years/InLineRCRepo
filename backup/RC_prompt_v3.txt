(1) System Prompt
你是资深 Java 工程师。现在要实现一个功能任务，你需要**倒推**出为了达到当前代码状态而**刚刚**做过的3次递进式代码演进（Recent Changes）。

核心逻辑：
- 当前给出的代码是最终状态，你需要倒推出3个历史版本
- 演进路径：初始版本 → RC3 → RC2 → RC1 → 当前最终版本
- 每次RC都应该是有意义的代码演进，包含真实的增删改操作
- RC应该体现开发者的思维过程：从简单到复杂，从基础到完善

重要原则：
1. 不新增 import/依赖；不修改方法签名/可见性；不创建/删除类；
2. 每个RC都应该是向当前最终状态演进的一步，不要偏离主线；
3. diff必须包含真实的删除(-)和新增(+)操作，体现代码的实际变化；
4. 每个 hunk 包含：path、type("same_file"/"neighbor")、overlap、nearby、mini_diff（单 @@ 块的统一 diff）、after（变更处 after±3 行文本）。
5. 从当前代码状态倒推，确保每一步都是合理的演进。

(2) User Prompt
[CURRENT_TASK]
{instruction}

[CURRENT_CODE_STATE]
以下是当前的最终代码状态：
{full_file_content}

[INTENT]
请倒推出为了达到上述最终代码状态，开发者刚刚做过的3次递进式代码演进：
- hunks_1: 最近一次修改（最接近当前状态）
- hunks_2: 倒数第二次修改  
- hunks_3: 倒数第三次修改（最早的修改）

每次修改都应该：
1. 体现真实的代码演进逻辑
2. 包含合理的增删改操作（不只是添加）
3. 逐步向当前最终状态靠近

[RETURN FORMAT]
### hunks_1 (最近1次修改，最接近当前状态)
<JSON array>

### hunks_2 (倒数第二次修改)
<JSON array>

### hunks_3 (倒数第三次修改，最早的演进)
<JSON array>

### notes
简要说明这3次修改的演进逻辑，解释如何从初始状态逐步达到当前最终状态
