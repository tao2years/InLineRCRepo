=== SYSTEM PROMPT ===
你是资深 Java 工程师。现在要实现一个新功能，你需要**倒推**出为了实现这个新功能而**刚刚**做过的3次递进式准备工作（Recent Changes）。

核心逻辑：
- 给出的是当前代码状态（不包含新功能）和要实现的新功能
- 你需要倒推出为了实现新功能而做的3次准备工作
- 演进路径：当前状态 → RC3 → RC2 → RC1 → 最终状态（包含新功能）
- 每次RC都应该是为实现新功能做准备，不要修改与新功能无关的代码

重要原则：
1. 不新增 import/依赖；不修改方法签名/可见性；不创建/删除类；
2. 每个RC都应该是为实现新功能做准备，不要偏离主线；
3. RC可以包含增删改操作，但必须与新功能相关；
4. 每个 hunk 包含：path、type("same_file"/"neighbor")、overlap、nearby、mini_diff（单 @@ 块的统一 diff）、after（变更处 after±3 行文本）。
5. 重点关注新功能需要什么准备工作，而不是修改无关的现有代码。

=== USER PROMPT ===
[CURRENT_TASK]
要实现的新功能：使用系统的Application ClassLoader来加载一个指定的类

[CURRENT_CODE_STATE]
当前代码状态（不包含新功能）：
@Slf4j
public class ClassLoaderUtils {
    private ClassLoaderUtils() {
    }

    @SuppressWarnings({"unchecked"})
    public static URL[] getURLs(ClassLoader classLoader) {
        if (classLoader instanceof URLClassLoader) {
            return ((URLClassLoader) classLoader).getURLs();
        }
        try {
            Field ucpField = classLoader.getClass().getDeclaredField("ucp");
            AccessController.doPrivileged((PrivilegedAction) () -> {
                ucpField.setAccessible(true);
                return null;
            });
            Object ucp = ucpField.get(classLoader);
            Field pathField = ucp.getClass().getDeclaredField("path");
            AccessController.doPrivileged((PrivilegedAction) () -> {
                pathField.setAccessible(true);
                return null;
            });
            ArrayList<URL> path = (ArrayList<URL>) pathField.get(ucp);
            return path.toArray(new URL[0]);
        } catch (Exception e) {
            throw new DevsporeCicException(e);
        }
    }
public static boolean isBootstrapClassLoader(String className) {
        try {
            Class<?> langClass = Class.forName(className);
            return langClass.getClassLoader() == null;
        } catch (ClassNotFoundException e) {
            log.error("load error: {}", e.getMessage());
        }
        return false;
    }

    public static URL[] getExtensionClassLoaderUrls() {
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        ClassLoader extensionClassLoader = systemClassLoader.getParent();

        if (extensionClassLoader instanceof URLClassLoader) {
            URLClassLoader urlClassLoader = (URLClassLoader) extensionClassLoader;
            return urlClassLoader.getURLs();
        }
        return null;
    }

    /**
     * 动态加载类并执行指定方法
     *
     * @param loader 类加载器
     * @param className 完整类名（如 "com.example.Plugin"）
     * @param methodName 方法名（如 "run"）
     * @param parameterTypes 方法参数类型数组（无参数传 null）
     * @param args 方法参数值数组（无参数传 null）
     * @return 方法执行结果（无返回值方法返回 null）
     * @throws Exception 封装所有可能的反射异常
     */
    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName,
        Class<?>[] parameterTypes, Object[] args, Class<T> returnType) throws Exception {

        // 1. 加载目标类
        Class<?> clazz = loader.loadClass(className);

        // 2. 实例化对象（使用无参构造函数）
        Constructor<?> constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true); // 允许调用私有构造方法
        Object instance = constructor.newInstance();

        // 3. 获取并执行方法
        Method method = clazz.getMethod(methodName, parameterTypes);

        // 判断是否为静态方法
        if (Modifier.isStatic(method.getModifiers())) {
            return returnType.cast(method.invoke(null, args));// 静态方法无需实例
        } else {
            // 非静态方法
            return returnType.cast(method.invoke(instance, args));
        }
    }

    /**
     * 重载方法：简化无参方法的调用
     */
    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName, Class<T> returnType)
        throws Exception {
        Object result = loadAndInvoke(loader, className, methodName, null, null, returnType);
        return returnType.cast(result);
    }
}

[NEW_METHOD_TO_IMPLEMENT]
要实现的新方法：
public static void loadClassWithApplicationLoader(String className)

[NEW_METHOD_IMPLEMENTATION]
新方法的实现：
public static void loadClassWithApplicationLoader(String className) {
        try {
            ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();
            log.info("Application ClassLoader: {}", appClassLoader);

            Class<?> loadedClass = appClassLoader.loadClass(className);
            log.info("Loaded Class: {}", loadedClass.getName());
        } catch (ClassNotFoundException e) {
            log.error("load error: {}", e.getMessage());
        }
    }```

[FINAL_CODE_STATE]
最终代码状态（包含新功能）：
@Slf4j
public class ClassLoaderUtils {
    private ClassLoaderUtils() {
    }

    @SuppressWarnings({"unchecked"})
    public static URL[] getURLs(ClassLoader classLoader) {
        if (classLoader instanceof URLClassLoader) {
            return ((URLClassLoader) classLoader).getURLs();
        }
        try {
            Field ucpField = classLoader.getClass().getDeclaredField("ucp");
            AccessController.doPrivileged((PrivilegedAction) () -> {
                ucpField.setAccessible(true);
                return null;
            });
            Object ucp = ucpField.get(classLoader);
            Field pathField = ucp.getClass().getDeclaredField("path");
            AccessController.doPrivileged((PrivilegedAction) () -> {
                pathField.setAccessible(true);
                return null;
            });
            ArrayList<URL> path = (ArrayList<URL>) pathField.get(ucp);
            return path.toArray(new URL[0]);
        } catch (Exception e) {
            throw new DevsporeCicException(e);
        }
    }
public static boolean isBootstrapClassLoader(String className) {
        try {
            Class<?> langClass = Class.forName(className);
            return langClass.getClassLoader() == null;
        } catch (ClassNotFoundException e) {
            log.error("load error: {}", e.getMessage());
        }
        return false;
    }

    public static URL[] getExtensionClassLoaderUrls() {
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        ClassLoader extensionClassLoader = systemClassLoader.getParent();

        if (extensionClassLoader instanceof URLClassLoader) {
            URLClassLoader urlClassLoader = (URLClassLoader) extensionClassLoader;
            return urlClassLoader.getURLs();
        }
        return null;
    }

    /**
     * 动态加载类并执行指定方法
     *
     * @param loader 类加载器
     * @param className 完整类名（如 "com.example.Plugin"）
     * @param methodName 方法名（如 "run"）
     * @param parameterTypes 方法参数类型数组（无参数传 null）
     * @param args 方法参数值数组（无参数传 null）
     * @return 方法执行结果（无返回值方法返回 null）
     * @throws Exception 封装所有可能的反射异常
     */
    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName,
        Class<?>[] parameterTypes, Object[] args, Class<T> returnType) throws Exception {

        // 1. 加载目标类
        Class<?> clazz = loader.loadClass(className);

        // 2. 实例化对象（使用无参构造函数）
        Constructor<?> constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true); // 允许调用私有构造方法
        Object instance = constructor.newInstance();

        // 3. 获取并执行方法
        Method method = clazz.getMethod(methodName, parameterTypes);

        // 判断是否为静态方法
        if (Modifier.isStatic(method.getModifiers())) {
            return returnType.cast(method.invoke(null, args));// 静态方法无需实例
        } else {
            // 非静态方法
            return returnType.cast(method.invoke(instance, args));
        }
    }

    /**
     * 重载方法：简化无参方法的调用
     */
    public static <T> T loadAndInvoke(ClassLoader loader, String className, String methodName, Class<T> returnType)
        throws Exception {
        Object result = loadAndInvoke(loader, className, methodName, null, null, returnType);
        return returnType.cast(result);
    }

public static void loadClassWithApplicationLoader(String className) {
        try {
            ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();
            log.info("Application ClassLoader: {}", appClassLoader);

            Class<?> loadedClass = appClassLoader.loadClass(className);
            log.info("Loaded Class: {}", loadedClass.getName());
        } catch (ClassNotFoundException e) {
            log.error("load error: {}", e.getMessage());
        }
    }```
}

[INTENT]
请倒推出为了实现上述新功能，开发者刚刚做过的3次递进式准备工作：
- hunks_3: 最早的准备工作（为新功能奠定基础）
- hunks_2: 倒数第二次准备工作
- hunks_1: 最近的准备工作（最接近实现新功能）

每次准备工作都应该：
1. 与新功能直接相关
2. 为实现新功能做必要的准备
3. 不修改与新功能无关的现有代码

[RETURN FORMAT]
### hunks_3 (最早的准备工作，为新功能奠定基础)
<JSON array>

### hunks_2 (倒数第二次准备工作)
<JSON array>

### hunks_1 (最近的准备工作，最接近实现新功能)
<JSON array>

### notes
简要说明这3次准备工作如何为实现新功能做准备